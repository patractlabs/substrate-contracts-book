"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[2725],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=u(t),m=r,k=d["".concat(s,".").concat(m)]||d[m]||p[m]||o;return t?a.createElement(k,l(l({ref:n},c),{},{components:t})):a.createElement(k,l({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=d;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var u=2;u<o;u++)l[u]=t[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4359:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return c},default:function(){return d}});var a=t(7462),r=t(3366),o=(t(7294),t(3905)),l=["components"],i={},s="ERC777",u={unversionedId:"metis/guides/tokens/erc777",id:"metis/guides/tokens/erc777",isDocsHomePage:!1,title:"ERC777",description:"Details of ERC777 can be found in ERC777.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/metis/guides/tokens/erc777.md",sourceDirName:"metis/guides/tokens",slug:"/metis/guides/tokens/erc777",permalink:"/substrate-contracts-book/en/metis/guides/tokens/erc777",editUrl:"https://github.com/patractlabs/substrate-contracts-book/edit/master/docs/metis/guides/tokens/erc777.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"ERC721",permalink:"/substrate-contracts-book/en/metis/guides/tokens/erc721"},next:{title:"ERC1155",permalink:"/substrate-contracts-book/en/metis/guides/tokens/erc1155"}},c=[{value:"Dependency",id:"dependency",children:[]},{value:"Storage",id:"storage",children:[]},{value:"Mutable Functions",id:"mutable-functions",children:[{value:"send",id:"send",children:[]},{value:"transfer",id:"transfer",children:[]},{value:"burn",id:"burn",children:[]},{value:"authorize_operator",id:"authorize_operator",children:[]},{value:"revoke_operator",id:"revoke_operator",children:[]},{value:"operator_send",id:"operator_send",children:[]},{value:"operator_burn",id:"operator_burn",children:[]},{value:"approve",id:"approve",children:[]},{value:"transfer_from",id:"transfer_from",children:[]}]},{value:"Immutable Functions",id:"immutable-functions",children:[{value:"name",id:"name",children:[]},{value:"symbol",id:"symbol",children:[]},{value:"decimals",id:"decimals",children:[]},{value:"granularity",id:"granularity",children:[]},{value:"total_supply",id:"total_supply",children:[]},{value:"balance_of",id:"balance_of",children:[]},{value:"is_operator_for",id:"is_operator_for",children:[]},{value:"default_operators",id:"default_operators",children:[]},{value:"allowance",id:"allowance",children:[]}]},{value:"Internal Functions",id:"internal-functions",children:[{value:"_mint",id:"_mint",children:[]},{value:"_mint_required_reception_ack",id:"_mint_required_reception_ack",children:[]},{value:"_burn",id:"_burn",children:[]}]},{value:"Hooks",id:"hooks",children:[{value:"_before_token_transfer",id:"_before_token_transfer",children:[]}]},{value:"Events",id:"events",children:[{value:"Transfer",id:"transfer-1",children:[]},{value:"Approval",id:"approval",children:[]},{value:"Sent",id:"sent",children:[]},{value:"Minted",id:"minted",children:[]},{value:"Burned",id:"burned",children:[]},{value:"AuthorizedOperator",id:"authorizedoperator",children:[]},{value:"RevokedOperator",id:"revokedoperator",children:[]}]},{value:"Usage Example",id:"usage-example",children:[]}],p={toc:c};function d(e){var n=e.components,t=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"erc777"},"ERC777"),(0,o.kt)("p",null,"Details of ERC777 can be found in ",(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-777"},"ERC777"),"."),(0,o.kt)("h2",{id:"dependency"},"Dependency"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'metis_erc777 = { git = "https://github.com/patractlabs/metis", default-features = false }\n')),(0,o.kt)("h2",{id:"storage"},"Storage"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg_attr(feature = \"std\", derive(::ink_storage::traits::StorageLayout))]\n#[derive(Debug, SpreadLayout)]\npub struct Data<E: Env> {\n    /// Total token supply.\n    pub total_supply: Lazy<E::Balance>,\n    /// Mapping from owner to number of owned token.\n    pub balances: StorageHashMap<E::AccountId, E::Balance>,\n    /// Mapping of the token amount which an account is allowed to withdraw\n    /// from another account.\n    pub allowances: StorageHashMap<(E::AccountId, E::AccountId), E::Balance>,\n    /// Metadatas Symbols of ERC777 Token, by (name, symbol)\n    pub metadatas: Lazy<(u8, String, String)>,\n\n    /// This isn't ever read from - it's only used to respond to the defaultOperators query.\n    pub default_operators_array: Lazy<Vec<E::AccountId>>,\n\n    /// Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    pub default_operators: StorageHashMap<E::AccountId, ()>,\n\n    /// For each account, a mapping of its operators and revoked default operators.\n    pub operators: StorageHashMap<(E::AccountId, E::AccountId), ()>,\n    pub revoked_default_operators: StorageHashMap<(E::AccountId, E::AccountId), ()>,\n}\n")),(0,o.kt)("h2",{id:"mutable-functions"},"Mutable Functions"),(0,o.kt)("h3",{id:"send"},"send"),(0,o.kt)("p",null,"Moves ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens from the caller's account to ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),"."),(0,o.kt)("p",null,"If send or receive hooks are registered for the caller and ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),",\nthe corresponding functions will be called with ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," and empty\n",(0,o.kt)("inlineCode",{parentName:"p"},"operator_data"),". See ",(0,o.kt)("inlineCode",{parentName:"p"},"erc777_sender")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"erc777_recipient"),"."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Sent")," event."),(0,o.kt)("p",null,"Requirements"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the caller must have at least ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," tokens."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"recipient")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},"if ",(0,o.kt)("inlineCode",{parentName:"li"},"recipient")," is a contract, it must implement the ",(0,o.kt)("inlineCode",{parentName:"li"},"erc777_recipient")," interface.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn send(\n        &mut self,\n        recipient: E::AccountId,\n        amount: E::Balance,\n        data: Vec<u8>,\n    ) -> Result<()> {\n        self._send(\n            Self::caller(),\n            recipient,\n            amount,\n            data,\n            Vec::default(),\n            true,\n        )\n    }\n")),(0,o.kt)("h3",{id:"transfer"},"transfer"),(0,o.kt)("p",null,"Moves ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens from the caller's account to ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),"."),(0,o.kt)("p",null,"Returns a boolean value indicating whether the operation succeeded."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn transfer(&mut self, recipient: &E::AccountId, amount: E::Balance) -> Result<()> {\n        let null_account = &E::AccountId::default();\n        let from = &Self::caller();\n\n        if recipient == null_account {\n            return Err(Error::AccountIsZero)\n        }\n\n        let null_data = &Vec::<u8>::default();\n\n        self._call_tokens_to_send(\n            &from,\n            &Some(&from),\n            &Some(&recipient),\n            &amount,\n            null_data,\n            null_data,\n        );\n\n        self._move(&from, &from, &recipient, &amount, null_data, null_data)?;\n\n        self._call_tokens_received(\n            &from,\n            &Some(&from),\n            &Some(&recipient),\n            &amount,\n            null_data,\n            null_data,\n            false,\n        );\n\n        Ok(())\n    }\n")),(0,o.kt)("h3",{id:"burn"},"burn"),(0,o.kt)("p",null,"Destroys ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens from the caller's account, reducing the\ntotal supply."),(0,o.kt)("p",null,"If a send hook is registered for the caller, the corresponding function\nwill be called with ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," and empty ",(0,o.kt)("inlineCode",{parentName:"p"},"operator_data"),". See ",(0,o.kt)("inlineCode",{parentName:"p"},"erc777_sender"),"."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Burned")," event."),(0,o.kt)("p",null,"Requirements"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the caller must have at least ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," tokens.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn burn(&mut self, amount: E::Balance, data: Vec<u8>) -> Result<()> {\n        self._burn(Self::caller(), amount, data, Vec::default())\n    }\n")),(0,o.kt)("h3",{id:"authorize_operator"},"authorize_operator"),(0,o.kt)("p",null,"Make an account an operator of the caller."),(0,o.kt)("p",null,"See ",(0,o.kt)("inlineCode",{parentName:"p"},"is_operator_for"),"."),(0,o.kt)("p",null,"Emits an ",(0,o.kt)("inlineCode",{parentName:"p"},"AuthorizedOperator")," event."),(0,o.kt)("p",null,"Requirements"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"operator")," cannot be calling address.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn authorize_operator(&mut self, operator: E::AccountId) {\n        let caller = Self::caller();\n        assert!(caller != operator, "ERC777: authorizing self as operator");\n\n        let key = (caller.clone(), operator.clone());\n\n        if self.get().is_default_operator(&operator) {\n            self.get_mut().revoked_default_operators.take(&key);\n        } else {\n            self.get_mut().operators.insert(key, ());\n        }\n\n        self.emit_event_authorized_operator(operator, caller);\n    }\n')),(0,o.kt)("h3",{id:"revoke_operator"},"revoke_operator"),(0,o.kt)("p",null,"Revoke an account's operator status for the caller."),(0,o.kt)("p",null,"See ",(0,o.kt)("inlineCode",{parentName:"p"},"is_operator_for")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"default_operators"),"."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"RevokedOperator")," event."),(0,o.kt)("p",null,"Requirements"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"operator")," cannot be calling address.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn revoke_operator(&mut self, operator: E::AccountId) {\n        let caller = Self::caller();\n        assert!(caller != operator, "ERC777: revoke self as operator");\n\n        let key = (caller.clone(), operator.clone());\n\n        if self.get().is_default_operator(&operator) {\n            self.get_mut().revoked_default_operators.insert(key, ());\n        } else {\n            self.get_mut().operators.take(&key);\n        }\n\n        self.emit_event_revoked_operator(operator, caller);\n    }\n\n')),(0,o.kt)("h3",{id:"operator_send"},"operator_send"),(0,o.kt)("p",null,"Moves ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens from ",(0,o.kt)("inlineCode",{parentName:"p"},"sender")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),". The caller must\nbe an operator of ",(0,o.kt)("inlineCode",{parentName:"p"},"sender"),"."),(0,o.kt)("p",null,"If send or receive hooks are registered for ",(0,o.kt)("inlineCode",{parentName:"p"},"sender")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),",\nthe corresponding functions will be called with ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"operator_data"),". See ",(0,o.kt)("inlineCode",{parentName:"p"},"erc777_sender")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"erc777_recipient"),"."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Sent")," event."),(0,o.kt)("p",null,"Requirements"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sender")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sender")," must have at least ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," tokens."),(0,o.kt)("li",{parentName:"ul"},"the caller must be an operator for ",(0,o.kt)("inlineCode",{parentName:"li"},"sender"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"recipient")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},"if ",(0,o.kt)("inlineCode",{parentName:"li"},"recipient")," is a contract, it must implement the ",(0,o.kt)("inlineCode",{parentName:"li"},"erc777_recipient")," interface.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn operator_send(\n        &mut self,\n        sender: E::AccountId,\n        recipient: E::AccountId,\n        amount: E::Balance,\n        data: Vec<u8>,\n        operator_data: Vec<u8>,\n    ) -> Result<()> {\n        assert!(\n            self.get().is_operator_for(&Self::caller(), &sender),\n            "ERC777: caller is not an operator for holder"\n        );\n\n        self._send(sender, recipient, amount, data, operator_data, true)\n    }\n')),(0,o.kt)("h3",{id:"operator_burn"},"operator_burn"),(0,o.kt)("p",null,"Destroys ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens from ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),", reducing the total supply.\nThe caller must be an operator of ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),"."),(0,o.kt)("p",null,"If a send hook is registered for ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),", the corresponding function\nwill be called with ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"operator_data"),". See ",(0,o.kt)("inlineCode",{parentName:"p"},"erc777_sender"),"."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Burned")," event."),(0,o.kt)("p",null,"Requirements"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"account")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"account")," must have at least ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," tokens."),(0,o.kt)("li",{parentName:"ul"},"the caller must be an operator for ",(0,o.kt)("inlineCode",{parentName:"li"},"account"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn operator_burn(\n        &mut self,\n        account: E::AccountId,\n        amount: E::Balance,\n        data: Vec<u8>,\n        operator_data: Vec<u8>,\n    ) -> Result<()> {\n        assert!(\n            self.get().is_operator_for(&Self::caller(), &account),\n            "ERC777: caller is not an operator for holder"\n        );\n\n        self._burn(account, amount, data, operator_data)\n    }\n')),(0,o.kt)("h3",{id:"approve"},"approve"),(0,o.kt)("p",null,"Sets ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," as the allowance of ",(0,o.kt)("inlineCode",{parentName:"p"},"spender")," over the caller's tokens."),(0,o.kt)("p",null,"Returns a boolean value indicating whether the operation succeeded."),(0,o.kt)("p",null,"IMPORTANT: Beware that changing an allowance with this method brings the risk\nthat someone may use both the old and the new allowance by unfortunate\ntransaction ordering. One possible solution to mitigate this race\ncondition is to first reduce the spender's allowance to 0 and set the\ndesired value afterwards:\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729"},"https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729")),(0,o.kt)("p",null,"Emits an ",(0,o.kt)("inlineCode",{parentName:"p"},"Approval")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn approve(&mut self, spender: &E::AccountId, amount: E::Balance) -> Result<()> {\n        self._approve(&Self::caller(), spender, amount)\n    }\n")),(0,o.kt)("h3",{id:"transfer_from"},"transfer_from"),(0,o.kt)("p",null,"Moves ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens from ",(0,o.kt)("inlineCode",{parentName:"p"},"sender")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient")," using the\nallowance mechanism. ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," is then deducted from the caller's\nallowance."),(0,o.kt)("p",null,"Returns a boolean value indicating whether the operation succeeded."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn transfer_from(\n        &mut self,\n        holder: &E::AccountId,\n        recipient: &E::AccountId,\n        amount: E::Balance,\n    ) -> Result<()> {\n        let caller = &Self::caller();\n        let null_account = &E::AccountId::default();\n\n        if recipient == null_account {\n            return Err(Error::AccountIsZero)\n        }\n\n        let current_allowance = self.get().allowance(holder, caller);\n        if current_allowance < amount {\n            return Err(Error::InsufficientAllowance)\n        }\n\n        let spender = Self::caller();\n\n        self._call_tokens_to_send(\n            &spender,\n            &Some(&holder),\n            &Some(&recipient),\n            &amount,\n            &Vec::default(),\n            &Vec::default(),\n        );\n\n        self._approve(holder, caller, current_allowance - amount)?;\n\n        self._move(\n            &spender,\n            &holder,\n            &recipient,\n            &amount,\n            &Vec::default(),\n            &Vec::default(),\n        )?;\n\n        self._call_tokens_received(\n            &spender,\n            &Some(&holder),\n            &Some(&recipient),\n            &amount,\n            &Vec::default(),\n            &Vec::default(),\n            false,\n        );\n\n        Ok(())\n    }\n")),(0,o.kt)("h2",{id:"immutable-functions"},"Immutable Functions"),(0,o.kt)("h3",{id:"name"},"name"),(0,o.kt)("p",null,"Returns the name of the token."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn name(&self) -> String {\n        self.get().name().clone()\n    }\n")),(0,o.kt)("h3",{id:"symbol"},"symbol"),(0,o.kt)("p",null,"Returns the symbol of the token, usually a shorter version of the name."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn symbol(&self) -> String {\n        self.get().symbol().clone()\n    }\n")),(0,o.kt)("h3",{id:"decimals"},"decimals"),(0,o.kt)("p",null,"Returns the number of decimals used to get its user representation.\nFor example, if ",(0,o.kt)("inlineCode",{parentName:"p"},"decimals")," equals ",(0,o.kt)("inlineCode",{parentName:"p"},"2"),", a balance of ",(0,o.kt)("inlineCode",{parentName:"p"},"505")," tokens should\nbe displayed to a user as ",(0,o.kt)("inlineCode",{parentName:"p"},"5,05")," (",(0,o.kt)("inlineCode",{parentName:"p"},"505 / 10 ** 2"),")."),(0,o.kt)("p",null,"Tokens usually opt for a value of 18, imitating the relationship between\nEther and Wei in ETH. This is the value ",(0,o.kt)("inlineCode",{parentName:"p"},"ERC20")," uses, unless this function is\noverridden;"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"NOTE: This information is only used for ",(0,o.kt)("em",{parentName:"p"},"display")," purposes: it in\nno way affects any of the arithmetic of the contract")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn decimals(&self) -> u8 {\n        self.get().decimals().clone()\n    }\n")),(0,o.kt)("h3",{id:"granularity"},"granularity"),(0,o.kt)("p",null,"Returns the smallest part of the token that is not divisible. This\nmeans all token operations (creation, movement and destruction) must have\namounts that are a multiple of this number."),(0,o.kt)("p",null,"For most token contracts, this value will equal 1."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn granularity(&self) -> E::Balance {\n        E::Balance::from(1_u8)\n    }\n")),(0,o.kt)("h3",{id:"total_supply"},"total_supply"),(0,o.kt)("p",null,"Returns the amount of tokens in existence."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn total_supply(&self) -> E::Balance {\n        self.get().total_supply()\n    }\n")),(0,o.kt)("h3",{id:"balance_of"},"balance_of"),(0,o.kt)("p",null,"Returns the amount of tokens owned by ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn balance_of(&self, account: &E::AccountId) -> E::Balance {\n        self.get().balance_of(account)\n    }\n")),(0,o.kt)("h3",{id:"is_operator_for"},"is_operator_for"),(0,o.kt)("p",null,"Returns true if an account is an operator of ",(0,o.kt)("inlineCode",{parentName:"p"},"token_holder"),".\nOperators can send and burn tokens on behalf of their owners. All\naccounts are their own operator."),(0,o.kt)("p",null,"See ",(0,o.kt)("inlineCode",{parentName:"p"},"operator_send")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"operator_burn"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn is_operator_for(\n        &self,\n        operator: E::AccountId,\n        token_holder: E::AccountId,\n    ) -> bool {\n        self.get().is_operator_for(&operator, &token_holder)\n    }\n")),(0,o.kt)("h3",{id:"default_operators"},"default_operators"),(0,o.kt)("p",null,"Returns the list of default operators. These accounts are operators\nfor all token holders, even if ",(0,o.kt)("inlineCode",{parentName:"p"},"authorize_operator")," was never called on\nthem."),(0,o.kt)("p",null,"This list is immutable, but individual holders may revoke these via\n",(0,o.kt)("inlineCode",{parentName:"p"},"revoke_operator"),", in which case ",(0,o.kt)("inlineCode",{parentName:"p"},"is_operator_for")," will return false."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn default_operators(&self) -> Vec<E::AccountId> {\n        self.get().default_operators_array.clone()\n    }\n")),(0,o.kt)("h3",{id:"allowance"},"allowance"),(0,o.kt)("p",null,"Returns the remaining number of tokens that ",(0,o.kt)("inlineCode",{parentName:"p"},"spender")," will be\nallowed to spend on behalf of ",(0,o.kt)("inlineCode",{parentName:"p"},"owner")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer_from"),". This is\nzero by default."),(0,o.kt)("p",null,"This value changes when ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer_from")," are called."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn allowance(&self, owner: &E::AccountId, spender: &E::AccountId) -> E::Balance {\n        self.get().allowance(owner, spender)\n    }\n")),(0,o.kt)("h2",{id:"internal-functions"},"Internal Functions"),(0,o.kt)("p",null,"There are some internal functions can help developer to add self-defined messages:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_mint")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_mint_required_reception_ack")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_burn"))),(0,o.kt)("h3",{id:"_mint"},"_mint"),(0,o.kt)("p",null,"Creates ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens and assigns them to ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),", increasing\nthe total supply."),(0,o.kt)("p",null,"If a send hook is registered for ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),", the corresponding function\nwill be called with ",(0,o.kt)("inlineCode",{parentName:"p"},"operator"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"operator_data"),"."),(0,o.kt)("p",null,"See ",(0,o.kt)("inlineCode",{parentName:"p"},"erc777_sender")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"erc777_recipient"),"."),(0,o.kt)("p",null,"Emits ",(0,o.kt)("inlineCode",{parentName:"p"},"Minted")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," events."),(0,o.kt)("p",null,"Requirements"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"account")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},"if ",(0,o.kt)("inlineCode",{parentName:"li"},"account")," is a contract, it must implement the ",(0,o.kt)("inlineCode",{parentName:"li"},"erc777_recipient")," interface.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _mint(\n        &mut self,\n        account: E::AccountId,\n        amount: E::Balance,\n        user_data: Vec<u8>,\n        operator_data: Vec<u8>,\n    ) -> Result<()> {\n        self._mint_required_reception_ack(account, amount, user_data, operator_data, true)\n    }\n")),(0,o.kt)("h3",{id:"_mint_required_reception_ack"},"_mint_required_reception_ack"),(0,o.kt)("p",null,"Creates ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens and assigns them to ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),", increasing\nthe total supply."),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"requireReceptionAck")," is set to true, and if a send hook is\nregistered for ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),", the corresponding function will be called with\n",(0,o.kt)("inlineCode",{parentName:"p"},"operator"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"operator_data"),"."),(0,o.kt)("p",null,"See ",(0,o.kt)("inlineCode",{parentName:"p"},"erc777_sender")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"erc777_recipient"),"."),(0,o.kt)("p",null,"Emits ",(0,o.kt)("inlineCode",{parentName:"p"},"Minted")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," events."),(0,o.kt)("p",null,"Requirements"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"account")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},"if ",(0,o.kt)("inlineCode",{parentName:"li"},"account")," is a contract, it must implement the ",(0,o.kt)("inlineCode",{parentName:"li"},"erc777_recipient")," interface.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _mint_required_reception_ack(\n        &mut self,\n        account: E::AccountId,\n        amount: E::Balance,\n        user_data: Vec<u8>,\n        operator_data: Vec<u8>,\n        required_reception_ack: bool,\n    ) -> Result<()> {\n        let null_account = E::AccountId::default();\n\n        if account == null_account {\n            return Err(Error::AccountIsZero)\n        }\n\n        let operator = Self::caller();\n\n        self._before_token_transfer(&operator, &None, &Some(&account), &amount)?;\n\n        // Update state variables\n        let current_total = self.get().total_supply();\n        let current_balance = self.get().balance_of(&account);\n\n        self.get_mut().set_total_supply(current_total + amount);\n        self.get_mut()\n            .set_balance(&account, current_balance + amount);\n\n        self._call_tokens_received(\n            &operator,\n            &None,\n            &Some(&account),\n            &amount,\n            &user_data,\n            &operator_data,\n            required_reception_ack,\n        );\n\n        self.emit_event_minted(\n            operator,\n            account.clone(),\n            amount,\n            user_data,\n            operator_data,\n        );\n        self.emit_event_transfer(None, Some(account), amount);\n\n        Ok(())\n    }\n")),(0,o.kt)("h3",{id:"_burn"},"_burn"),(0,o.kt)("p",null,"Burn tokens"),(0,o.kt)("p",null,"Params:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"from address token holder address"),(0,o.kt)("li",{parentName:"ul"},"amount uint256 amount of tokens to burn"),(0,o.kt)("li",{parentName:"ul"},"data bytes extra information provided by the token holder"),(0,o.kt)("li",{parentName:"ul"},"operator_data bytes extra information provided by the operator (if any)")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn _burn(\n        &mut self,\n        from: E::AccountId,\n        amount: E::Balance,\n        data: Vec<u8>,\n        operator_data: Vec<u8>,\n    ) -> Result<()> {\n        let null_account = E::AccountId::default();\n\n        assert!(from != null_account, "ERC777: burn from the zero address");\n\n        let operator = Self::caller();\n\n        self._call_tokens_to_send(\n            &operator,\n            &Some(&from),\n            &None,\n            &amount,\n            &data,\n            &operator_data,\n        );\n\n        self._before_token_transfer(&operator, &Some(&from), &None, &amount)?;\n\n        // Update state variables\n        let from_balance = self.get().balance_of(&from);\n        assert!(\n            from_balance >= amount,\n            "ERC777: burn amount exceeds balance"\n        );\n        self.get_mut().set_balance(&from, from_balance - amount);\n\n        let current_total = self.get().total_supply();\n        self.get_mut().set_total_supply(current_total - amount);\n\n        self.emit_event_burned(operator, from.clone(), amount, data, operator_data);\n        self.emit_event_transfer(Some(from), None, amount);\n\n        Ok(())\n    }\n')),(0,o.kt)("h2",{id:"hooks"},"Hooks"),(0,o.kt)("h3",{id:"_before_token_transfer"},"_before_token_transfer"),(0,o.kt)("p",null,"Hook that is called before any token transfer. This includes\ncalls to ",(0,o.kt)("inlineCode",{parentName:"p"},"send"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"operator_send"),", minting and burning."),(0,o.kt)("p",null,"Calling conditions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"when ",(0,o.kt)("inlineCode",{parentName:"li"},"from")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," are both non-zero, ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," of ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),"'s tokens\nwill be to transferred to ",(0,o.kt)("inlineCode",{parentName:"li"},"to"),"."),(0,o.kt)("li",{parentName:"ul"},"when ",(0,o.kt)("inlineCode",{parentName:"li"},"from")," is zero, ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," tokens will be minted for ",(0,o.kt)("inlineCode",{parentName:"li"},"to"),"."),(0,o.kt)("li",{parentName:"ul"},"when ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," is zero, ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," of ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),"'s tokens will be burned."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"from")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," are never both zero.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _before_token_transfer(\n        &mut self,\n        _operator: &E::AccountId,\n        _from: &Option<&E::AccountId>,\n        _to: &Option<&E::AccountId>,\n        _amount: &E::Balance,\n    ) -> Result<()> {\n        Ok(())\n    }\n")),(0,o.kt)("h2",{id:"events"},"Events"),(0,o.kt)("h3",{id:"transfer-1"},"Transfer"),(0,o.kt)("p",null,"Event emitted when a token transfer occurs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc777)]\n    pub struct Transfer {\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        pub value: Balance,\n    }\n")),(0,o.kt)("h3",{id:"approval"},"Approval"),(0,o.kt)("p",null,"Event emitted when an approval occurs that ",(0,o.kt)("inlineCode",{parentName:"p"},"spender")," is allowed to\nwithdraw up to the amount of ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," tokens from ",(0,o.kt)("inlineCode",{parentName:"p"},"owner"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc777)]\n    pub struct Approval {\n        #[ink(topic)]\n        pub owner: AccountId,\n        #[ink(topic)]\n        pub spender: AccountId,\n        pub value: Balance,\n    }\n")),(0,o.kt)("h3",{id:"sent"},"Sent"),(0,o.kt)("p",null,"Indicate a send of ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," of tokens from the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," address to the ",(0,o.kt)("inlineCode",{parentName:"p"},"to"),"\naddress by the ",(0,o.kt)("inlineCode",{parentName:"p"},"operator")," address."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"NOTE: This event MUST NOT be emitted outside of a send or an ERC-20 transfer process.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc777)]\n    pub struct Sent {\n        #[ink(topic)]\n        pub operator: AccountId,\n        #[ink(topic)]\n        pub from: AccountId,\n        #[ink(topic)]\n        pub to: AccountId,\n        pub amount: Balance,\n        pub data: Vec<u8>,\n        pub operator_data: Vec<u8>,\n    }\n")),(0,o.kt)("h3",{id:"minted"},"Minted"),(0,o.kt)("p",null,"Indicate the minting of ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," of tokens to the ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," address by\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"operator")," address."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"NOTE: This event MUST NOT be emitted outside of a mint process.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc777)]\n    pub struct Minted {\n        #[ink(topic)]\n        pub operator: AccountId,\n        #[ink(topic)]\n        pub to: AccountId,\n        pub amount: Balance,\n        pub data: Vec<u8>,\n        pub operator_data: Vec<u8>,\n    }\n")),(0,o.kt)("h3",{id:"burned"},"Burned"),(0,o.kt)("p",null,"Indicate the burning of ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," of tokens from the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," address\nby the ",(0,o.kt)("inlineCode",{parentName:"p"},"operator")," address."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"NOTE: This event MUST NOT be emitted outside of a burn process.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc777)]\n    pub struct Burned {\n        #[ink(topic)]\n        pub operator: AccountId,\n        #[ink(topic)]\n        pub from: AccountId,\n        pub amount: Balance,\n        pub data: Vec<u8>,\n        pub operator_data: Vec<u8>,\n    }\n")),(0,o.kt)("h3",{id:"authorizedoperator"},"AuthorizedOperator"),(0,o.kt)("p",null,"Indicates the authorization of ",(0,o.kt)("inlineCode",{parentName:"p"},"operator")," as an operator for ",(0,o.kt)("inlineCode",{parentName:"p"},"holder"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"NOTE: This event MUST NOT be emitted outside of an operator authorization process.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc777)]\n    pub struct AuthorizedOperator {\n        #[ink(topic)]\n        pub operator: AccountId,\n        #[ink(topic)]\n        pub token_holder: AccountId,\n    }\n")),(0,o.kt)("h3",{id:"revokedoperator"},"RevokedOperator"),(0,o.kt)("p",null,"Indicates the revocation of ",(0,o.kt)("inlineCode",{parentName:"p"},"operator")," as an operator for ",(0,o.kt)("inlineCode",{parentName:"p"},"holder"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"NOTE: This event MUST NOT be emitted outside of an operator revocation process.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc777)]\n    pub struct RevokedOperator {\n        #[ink(topic)]\n        pub operator: AccountId,\n        #[ink(topic)]\n        pub token_holder: AccountId,\n    }\n")),(0,o.kt)("h2",{id:"usage-example"},"Usage Example"),(0,o.kt)("p",null,"To make a new erc777-like token, we should import erc777 at first:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[metis_lang::contract]\npub mod erc777_contract {\n    use super::super::behavior;\n    pub use erc777::{\n        Error,\n        Result,\n    };\n    use metis_erc777 as erc777;\n    use metis_lang::{\n        import,\n        metis,\n    };\n\n    #[ink(storage)]\n    #[import(erc777)]\n    pub struct Erc777 {\n        erc777: erc777::Data<Erc777>,\n    }\n\n    // Note: Now version of metis not support auto impl for erc777\n    #[cfg(not(feature = "ink-as-dependency"))]\n    impl erc777::Impl<Erc777> for Erc777 {}\n}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: Now version of metis not support auto impl for erc777."),(0,o.kt)("p",{parentName:"blockquote"},"Should add:"),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'   #[cfg(not(feature = "ink-as-dependency"))]\n   impl erc777::Impl<Erc777> for Erc777 {}\n'))),(0,o.kt)("p",null,"Then add the event for erc777:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"     /// Event emitted when a token transfer occurs.\n    #[ink(event)]\n    #[metis(erc777)]\n    pub struct Transfer {\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        pub value: Balance,\n    }\n\n    /// Event emitted when an approval occurs that `spender` is allowed to withdraw\n    /// up to the amount of `value` tokens from `owner`.\n    #[ink(event)]\n    #[metis(erc777)]\n    pub struct Approval {\n        #[ink(topic)]\n        pub owner: AccountId,\n        #[ink(topic)]\n        pub spender: AccountId,\n        pub value: Balance,\n    }\n\n    /// Indicate a send of `amount` of tokens from the `from` address to the `to`\n    /// address by the `operator` address.\n    /// \n    /// NOTE: This event MUST NOT be emitted outside of\n    /// a send or an ERC-20 transfer process.\n    #[ink(event)]\n    #[metis(erc777)]\n    pub struct Sent {\n        #[ink(topic)]\n        pub operator: AccountId,\n        #[ink(topic)]\n        pub from: AccountId,\n        #[ink(topic)]\n        pub to: AccountId,\n        pub amount: Balance,\n        pub data: Vec<u8>,\n        pub operator_data: Vec<u8>,\n    }\n\n    /// Indicate the minting of `amount` of tokens to the `to` address by\n    /// the `operator` address.\n    ///\n    /// NOTE: This event MUST NOT be emitted outside of a mint process.\n    #[ink(event)]\n    #[metis(erc777)]\n    pub struct Minted {\n        #[ink(topic)]\n        pub operator: AccountId,\n        #[ink(topic)]\n        pub to: AccountId,\n        pub amount: Balance,\n        pub data: Vec<u8>,\n        pub operator_data: Vec<u8>,\n    }\n\n    /// Indicate the burning of `amount` of tokens from the `from` address\n    /// by the `operator` address.\n    /// \n    /// NOTE: This event MUST NOT be emitted outside of a burn process.\n    #[ink(event)]\n    #[metis(erc777)]\n    pub struct Burned {\n        #[ink(topic)]\n        pub operator: AccountId,\n        #[ink(topic)]\n        pub from: AccountId,\n        pub amount: Balance,\n        pub data: Vec<u8>,\n        pub operator_data: Vec<u8>,\n    }\n\n    /// Indicates the authorization of `operator` as an operator for `holder`.\n    /// \n    /// NOTE: This event MUST NOT be emitted outside\n    /// of an operator authorization process.\n    #[ink(event)]\n    #[metis(erc777)]\n    pub struct AuthorizedOperator {\n        #[ink(topic)]\n        pub operator: AccountId,\n        #[ink(topic)]\n        pub token_holder: AccountId,\n    }\n\n    /// Indicates the revocation of `operator` as an operator for `holder`.\n    /// \n    /// NOTE: This event MUST NOT be emitted outside\n    /// of an operator revocation process.\n    #[ink(event)]\n    #[metis(erc777)]\n    pub struct RevokedOperator {\n        #[ink(topic)]\n        pub operator: AccountId,\n        #[ink(topic)]\n        pub token_holder: AccountId,\n    }\n")),(0,o.kt)("p",null,"impl the constructor for contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    impl Erc777 {\n        #[ink(constructor)]\n        pub fn new(\n            name: String,\n            symbol: String,\n            decimals: u8,\n            initial_supply: Balance,\n        ) -> Self {\n            let mut instance = Self {\n                erc777: erc777::Data::new(),\n            };\n\n            erc777::Impl::init(&mut instance, \n                name, symbol, decimals,\n                initial_supply);\n\n            // other logics\n            instance\n        }\n    }\n\nThen implement the messages for contract:\n\n```rust\n    impl Erc777 {\n        /// Returns the name of the token.\n        #[ink(message)]\n        pub fn name(&self) -> String {\n            erc777::Impl::name(self)\n        }\n\n        /// Returns the symbol of the token, usually a shorter version of the name.\n        #[ink(message)]\n        pub fn symbol(&self) -> String {\n            erc777::Impl::symbol(self)\n        }\n\n        /// Returns the number of decimals used to get its user representation.\n        /// For example, if `decimals` equals `2`, a balance of `505` tokens should\n        /// be displayed to a user as `5,05` (`505 / 10 ** 2`).\n        ///\n        /// Tokens usually opt for a value of 18, imitating the relationship between\n        /// Ether and Wei in ETH. This is the value `ERC20` uses, unless this function is\n        /// overridden;\n        ///\n        /// NOTE: This information is only used for _display_ purposes: it in\n        /// no way affects any of the arithmetic of the contract\n        #[ink(message)]\n        pub fn decimals(&self) -> u8 {\n            erc777::Impl::decimals(self)\n        }\n\n        /// Returns the smallest part of the token that is not divisible. This\n        /// means all token operations (creation, movement and destruction) must have\n        /// amounts that are a multiple of this number.\n        ///\n        /// For most token contracts, this value will equal 1.\n        #[ink(message)]\n        pub fn granularity(&self) -> Balance {\n            erc777::Impl::granularity(self)\n        }\n\n        /// Returns the amount of tokens in existence.\n        #[ink(message)]\n        pub fn total_supply(&self) -> Balance {\n            erc777::Impl::total_supply(self)\n        }\n\n        /// Returns the amount of tokens owned by `account`.\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> Balance {\n            erc777::Impl::balance_of(self, &owner)\n        }\n\n        /// Moves `amount` tokens from the caller's account to `recipient`.\n        ///\n        /// If send or receive hooks are registered for the caller and `recipient`,\n        /// the corresponding functions will be called with `data` and empty\n        /// `operator_data`. See `erc777_sender` and `erc777_recipient`.\n        ///\n        /// Emits a `Sent` event.\n        ///\n        /// Requirements\n        ///\n        /// - the caller must have at least `amount` tokens.\n        /// - `recipient` cannot be the zero address.\n        /// - if `recipient` is a contract, it must implement the `erc777_recipient` interface.\n        #[ink(message)]\n        pub fn send(\n            &mut self,\n            recipient: AccountId,\n            amount: Balance,\n            data: Vec<u8>,\n        ) -> Result<()> {\n            erc777::Impl::send(self, recipient, amount, data)\n        }\n\n        /// Moves `amount` tokens from the caller's account to `recipient`.\n        ///\n        /// Returns a boolean value indicating whether the operation succeeded.\n        ///\n        /// Emits a `Transfer` event.\n        #[ink(message)]\n        pub fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()> {\n            erc777::Impl::transfer(self, &to, value)\n        }\n\n        /// Destroys `amount` tokens from the caller's account, reducing the\n        /// total supply.\n        ///\n        /// If a send hook is registered for the caller, the corresponding function\n        /// will be called with `data` and empty `operator_data`. See `erc777_sender`.\n        ///\n        /// Emits a `Burned` event.\n        ///\n        /// Requirements\n        ///\n        /// - the caller must have at least `amount` tokens.\n        #[ink(message)]\n        pub fn burn(&mut self, amount: Balance, data: Vec<u8>) -> Result<()> {\n            erc777::Impl::burn(self, amount, data)\n        }\n\n        /// Returns true if an account is an operator of `token_holder`.\n        /// Operators can send and burn tokens on behalf of their owners. All\n        /// accounts are their own operator.\n        ///\n        /// See `operator_send` and `operator_burn`.\n        #[ink(message)]\n        pub fn is_operator_for(\n            &self,\n            operator: AccountId,\n            token_holder: AccountId,\n        ) -> bool {\n            erc777::Impl::is_operator_for(self, operator, token_holder)\n        }\n\n        /// Make an account an operator of the caller.\n        ///\n        /// See `is_operator_for`.\n        ///\n        /// Emits an `AuthorizedOperator` event.\n        ///\n        /// Requirements\n        ///\n        /// - `operator` cannot be calling address.\n        #[ink(message)]\n        pub fn authorize_operator(&mut self, operator: AccountId) {\n            erc777::Impl::authorize_operator(self, operator)\n        }\n\n        /// Revoke an account's operator status for the caller.\n        ///\n        /// See `is_operator_for` and `default_operators`.\n        ///\n        /// Emits a `RevokedOperator` event.\n        ///\n        /// Requirements\n        ///\n        /// - `operator` cannot be calling address.\n        #[ink(message)]\n        pub fn revoke_operator(&mut self, operator: AccountId) {\n            erc777::Impl::revoke_operator(self, operator)\n        }\n\n        /// Returns the list of default operators. These accounts are operators\n        /// for all token holders, even if `authorize_operator` was never called on\n        /// them.\n        ///\n        /// This list is immutable, but individual holders may revoke these via\n        /// `revoke_operator`, in which case `is_operator_for` will return false.\n        #[ink(message)]\n        pub fn default_operators(&self) -> Vec<AccountId> {\n            erc777::Impl::default_operators(self)\n        }\n\n        /// Moves `amount` tokens from `sender` to `recipient`. The caller must\n        /// be an operator of `sender`.\n        ///\n        /// If send or receive hooks are registered for `sender` and `recipient`,\n        /// the corresponding functions will be called with `data` and\n        /// `operator_data`. See `erc777_sender` and `erc777_recipient`.\n        ///\n        /// Emits a `Sent` event.\n        ///\n        /// Requirements\n        ///\n        /// - `sender` cannot be the zero address.\n        /// - `sender` must have at least `amount` tokens.\n        /// - the caller must be an operator for `sender`.\n        /// - `recipient` cannot be the zero address.\n        /// - if `recipient` is a contract, it must implement the `erc777_recipient` interface.\n        #[ink(message)]\n        pub fn operator_send(\n            &mut self,\n            sender: AccountId,\n            recipient: AccountId,\n            amount: Balance,\n            data: Vec<u8>,\n            operator_data: Vec<u8>,\n        ) -> Result<()> {\n            erc777::Impl::operator_send(\n                self,\n                sender,\n                recipient,\n                amount,\n                data,\n                operator_data,\n            )\n        }\n\n        /// Destroys `amount` tokens from `account`, reducing the total supply.\n        /// The caller must be an operator of `account`.\n        ///\n        /// If a send hook is registered for `account`, the corresponding function\n        /// will be called with `data` and `operator_data`. See `erc777_sender`.\n        ///\n        /// Emits a `Burned` event.\n        ///\n        /// Requirements\n        ///\n        /// - `account` cannot be the zero address.\n        /// - `account` must have at least `amount` tokens.\n        /// - the caller must be an operator for `account`.\n        #[ink(message)]\n        pub fn operator_burn(\n            &mut self,\n            account: AccountId,\n            amount: Balance,\n            data: Vec<u8>,\n            operator_data: Vec<u8>,\n        ) -> Result<()> {\n            erc777::Impl::operator_burn(self, account, amount, data, operator_data)\n        }\n\n        /// Returns the remaining number of tokens that `spender` will be\n        /// allowed to spend on behalf of `owner` through `transfer_from`. This is\n        /// zero by default.\n        ///\n        /// This value changes when `approve` or `transfer_from` are called.\n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance {\n            erc777::Impl::allowance(self, &owner, &spender)\n        }\n\n        /// Sets `amount` as the allowance of `spender` over the caller's tokens.\n        ///\n        /// Returns a boolean value indicating whether the operation succeeded.\n        ///\n        /// IMPORTANT: Beware that changing an allowance with this method brings the risk\n        /// that someone may use both the old and the new allowance by unfortunate\n        /// transaction ordering. One possible solution to mitigate this race\n        /// condition is to first reduce the spender's allowance to 0 and set the\n        /// desired value afterwards:\n        /// <https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729>\n        ///\n        /// Emits an `Approval` event.\n        #[ink(message)]\n        pub fn approve(&mut self, spender: AccountId, value: Balance) -> Result<()> {\n            erc777::Impl::approve(self, &spender, value)\n        }\n\n        /// Moves `amount` tokens from `sender` to `recipient` using the\n        /// allowance mechanism. `amount` is then deducted from the caller's\n        /// allowance.\n        ///\n        /// Returns a boolean value indicating whether the operation succeeded.\n        ///\n        /// Emits a `Transfer` event.\n        #[ink(message)]\n        pub fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            erc777::Impl::transfer_from(self, &from, &to, value)\n        }\n\n        /// Creates `amount` tokens and assigns them to `account`, increasing\n        /// the total supply.\n        ///\n        /// If a send hook is registered for `account`, the corresponding function\n        /// will be called with `operator`, `data` and `operator_data`.\n        ///\n        /// See `erc777_sender` and `erc777_recipient`.\n        ///\n        /// Emits `Minted` and `Transfer` events.\n        ///\n        /// Requirements\n        ///\n        /// - `account` cannot be the zero address.\n        /// - if `account` is a contract, it must implement the `erc777_recipient` interface.\n        #[ink(message)]\n        pub fn mint(&mut self, to: AccountId, value: Balance) -> Result<()> {\n            erc777::Impl::_mint(self, to, value, Vec::default(), Vec::default())\n        }\n    }\n")),(0,o.kt)("p",null,"In the end, we can add some other messages."))}d.isMDXComponent=!0}}]);