(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{547:function(t,s,a){"use strict";a.r(s);var e=a(6),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"入门"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#入门"}},[t._v("#")]),t._v(" 入门")]),t._v(" "),a("blockquote",[a("p",[t._v("当前 Ask! 只进行到了 Kusama 国库议案的第二期的开发，功能还未稳定，因此还未发布到 npm 等公开仓库中。")])]),t._v(" "),a("p",[t._v("该文档假定用户拥有基本的 AssemblyScript 或 Typescript 编程基础，如果用户之前未接触过 "),a("a",{attrs:{href:"https://www.assemblyscript.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("AssemblyScript"),a("OutboundLink")],1),t._v("，需要对它先有个基本的了解。")]),t._v(" "),a("h2",{attrs:{id:"下载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下载"}},[t._v("#")]),t._v(" 下载")]),t._v(" "),a("p",[t._v("目前 Ask 项目代码还未上传到 npm，所以需要直接 clone 仓库，待功能开发稳定后将会发布到 npm。")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" clone https://github.com/patractlabs/ask\n")])])]),a("p",[t._v("进入目录下载依赖：")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("yarn")]),t._v("\n")])])]),a("h2",{attrs:{id:"开始使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开始使用"}},[t._v("#")]),t._v(" 开始使用")]),t._v(" "),a("h3",{attrs:{id:"案例合约"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#案例合约"}},[t._v("#")]),t._v(" 案例合约")]),t._v(" "),a("p",[t._v("在 Ask! 项目中的"),a("code",[t._v("/examples")]),t._v("目录下维护了一些基本的示例合约例如"),a("code",[t._v("flipper")]),t._v("，"),a("code",[t._v("incrementer")]),t._v("等，开发者可以参考这些示例来编写智能合约。\n下面的智能合约编写流程以"),a("code",[t._v("/examples/flipper")]),t._v(" 目录下的合约为例来说明。")]),t._v(" "),a("p",[t._v("首先我们新建文件 "),a("code",[t._v("flipper.ts")]),t._v("作为入口点，后续编译生成的 wasm 代码中的 "),a("code",[t._v("export")]),t._v(" 段对应的是该文件编译后导出的函数。实际上 AS 单文件就可以作为一个项目，但在这里我们需要通过 package.json 引入开发依赖。")]),t._v(" "),a("p",[t._v("你也可以使用 AssemblyScript 官方提供的 "),a("a",{attrs:{href:"https://github.com/AssemblyScript/asbuild/",target:"_blank",rel:"noopener noreferrer"}},[t._v("asbuild"),a("OutboundLink")],1),t._v(" 构建工具来生成初始项目。")]),t._v(" "),a("p",[t._v("在工程创建完毕后，我们开始定义合约存储。\nAsk! 采用装饰器 "),a("code",[t._v("@storage")]),t._v(" 定义一个合约存储类。这个过程类似于 ink!中的 "),a("code",[t._v("#[ink(storage)]")]),t._v("宏。例如在这个案例中，我们定义以下合约存储类：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("@storage\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Stored")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  flag"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" bool"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这样"),a("code",[t._v("Stored")]),t._v("就可以作为存储类在合约里使用。下面展示合约类的定义。")]),t._v(" "),a("p",[t._v("Ask! 提供"),a("code",[t._v("@contract")]),t._v("装饰器来定义一个合约类，它类似于 ink!中的 "),a("code",[t._v("#[ink::contract]")]),t._v("宏。"),a("code",[t._v("@contract")]),t._v(" 支持继承。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("@contract\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Flipper")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Ask! 提供了"),a("code",[t._v("@constructor")]),t._v(" 和 "),a("code",[t._v("@message")]),t._v(" 装饰器可以装饰"),a("code",[t._v("@contract")]),t._v("合约类中的非静态方法，它们类似于 ink!中的 "),a("code",[t._v("#[ink(constructor)]")]),t._v(" 和 "),a("code",[t._v("#[ink(message)]")]),t._v("。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("@constructor")]),t._v(" 装饰的方法会成为合约的一个初始化函数，每个"),a("code",[t._v("@contract")]),t._v("装饰的类必须至少需要有一个"),a("code",[t._v("@constructor")]),t._v("方法（不包括父类），父类的初始化函数不会直接成为合约初始化的函数。")]),t._v(" "),a("li",[a("code",[t._v("@message")]),t._v(" 装饰的方法会成为合约的一个方法调用，每个"),a("code",[t._v("@contract")]),t._v("装饰的类必须至少需要有一个"),a("code",[t._v("@message")]),t._v("方法（包括父类），子类默认会继承父类的合约方法，用户可以重载继承的合约的方法。")])]),t._v(" "),a("p",[t._v("注意：每个合约类需要定义一个无参的构造函数来实例化合约，"),a("code",[t._v("@constructor")]),t._v(" 函数是在构造函数调用之后才被调用。")]),t._v(" "),a("p",[t._v("之后我们实现 Flipper 具体逻辑：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("@contract\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Flipper")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" stored"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Stored"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stored "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Stored")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  @"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("constructor")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("initFlag"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" bool"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stored"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("flag "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" initFlag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  @message\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("flip")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" v "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stored"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("flag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stored"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("flag "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  @"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("message")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mutates "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" bool "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stored"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("flag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("它提供了一个合约初始化函数和两个合约方法，其中 "),a("code",[t._v("get")]),t._v(" 方法是只读的，因为它设置了"),a("code",[t._v("mutates = false")]),t._v("。")]),t._v(" "),a("p",[t._v("这里简单介绍了"),a("code",[t._v("@storage")]),t._v(" 和 "),a("code",[t._v("@contract")]),t._v(" 装饰器，并且我们已经实现了一个最小合约示例。")]),t._v(" "),a("h3",{attrs:{id:"编译"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译"}},[t._v("#")]),t._v(" 编译")]),t._v(" "),a("p",[t._v("假设我们在 Ask! 项目的"),a("strong",[t._v("根目录")]),t._v("下编译合约，当前合约的路径位于"),a("code",[t._v("examples/flipper/flipper.ts")]),t._v("（也可以替换为自己合约文件的路径），则编译命令是：")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("npx ask examples/flipper/flipper.ts\n")])])]),a("p",[t._v("执行了这个命令后，会在合约文件的目录下生成一个目录 "),a("code",[t._v("extension")]),t._v("，里面存放的是展开后的代码，而合约的编译产物位于合约文件目录下的"),a("code",[t._v("target")]),t._v("目录：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("metadata.json")]),t._v("描述了这个合约的 ABI，它可以提供给支持该规范的链或工具。")]),t._v(" "),a("li",[a("code",[t._v("target.wasm")]),t._v(" 是最终的 wasm 合约代码，部署到相应的链上即可执行。")])]),t._v(" "),a("h3",{attrs:{id:"链上环境测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链上环境测试"}},[t._v("#")]),t._v(" 链上环境测试")]),t._v(" "),a("p",[t._v("Ask! 当前不支持单元测试。")]),t._v(" "),a("p",[t._v("开发者可以采用 Patract 提供的合约执行环境沙盒 "),a("RouterLink",{attrs:{to:"/europa/introduction.html"}},[t._v("Europa")]),t._v(" 进行合约的部署调用和测试。")],1),t._v(" "),a("p",[t._v("启动 Europa 后，开发者可以通过 "),a("a",{attrs:{href:"https://polkadot.js.org/apps",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://polkadot.js.org/apps"),a("OutboundLink")],1),t._v(" 将"),a("code",[t._v("target")]),t._v("目录下的合约进行部署和调用，这个过程和 ink! 合约的操作过程一致。")])])}),[],!1,null,null,null);s.default=n.exports}}]);