"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[2650],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return d}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),u=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(i.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=u(t),d=r,f=m["".concat(i,".").concat(d)]||m[d]||p[d]||o;return t?a.createElement(f,l(l({ref:n},c),{},{components:t})):a.createElement(f,l({ref:n},c))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=m;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var u=2;u<o;u++)l[u]=t[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7814:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return i},metadata:function(){return u},toc:function(){return c},default:function(){return m}});var a=t(7462),r=t(3366),o=(t(7294),t(3905)),l=["components"],s={},i="ERC20",u={unversionedId:"metis/guides/tokens/erc20",id:"metis/guides/tokens/erc20",isDocsHomePage:!1,title:"ERC20",description:"Details of ERC20's definitions can be found in ERC20.",source:"@site/docs/metis/guides/tokens/erc20.md",sourceDirName:"metis/guides/tokens",slug:"/metis/guides/tokens/erc20",permalink:"/substrate-contracts-book/metis/guides/tokens/erc20",editUrl:"https://github.com/patractlabs/substrate-contracts-book/edit/master/docs/metis/guides/tokens/erc20.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Reentrancy Guard",permalink:"/substrate-contracts-book/metis/guides/security/reentrancy-guard"},next:{title:"ERC721",permalink:"/substrate-contracts-book/metis/guides/tokens/erc721"}},c=[{value:"Dependency",id:"dependency",children:[]},{value:"Storage",id:"storage",children:[]},{value:"Mutable Messages",id:"mutable-messages",children:[{value:"transfer",id:"transfer",children:[]},{value:"approve",id:"approve",children:[]},{value:"transfer_from",id:"transfer_from",children:[]}]},{value:"Immutable Messages",id:"immutable-messages",children:[{value:"name",id:"name",children:[]},{value:"symbol",id:"symbol",children:[]},{value:"decimals",id:"decimals",children:[]},{value:"balance_of",id:"balance_of",children:[]},{value:"total_supply",id:"total_supply",children:[]},{value:"allowance",id:"allowance",children:[]}]},{value:"Internal Functions",id:"internal-functions",children:[{value:"_mint",id:"_mint",children:[]},{value:"_burn",id:"_burn",children:[]},{value:"_transfer_from_to",id:"_transfer_from_to",children:[]}]},{value:"Hooks",id:"hooks",children:[{value:"_before_token_transfer",id:"_before_token_transfer",children:[]}]},{value:"Events",id:"events",children:[{value:"Transfer",id:"transfer-1",children:[]},{value:"Approval",id:"approval",children:[]}]},{value:"Extensions",id:"extensions",children:[{value:"ERC20Pausable",id:"erc20pausable",children:[]},{value:"ERC20Burnable",id:"erc20burnable",children:[]},{value:"ERC20Capped",id:"erc20capped",children:[]}]},{value:"Usage Example",id:"usage-example",children:[]}],p={toc:c};function m(e){var n=e.components,t=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"erc20"},"ERC20"),(0,o.kt)("p",null,"Details of ERC20's definitions can be found in ",(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-20"},"ERC20"),"."),(0,o.kt)("h2",{id:"dependency"},"Dependency"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'metis_erc20 = { git = "https://github.com/patractlabs/metis", default-features = false }\n')),(0,o.kt)("h2",{id:"storage"},"Storage"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg_attr(feature = "std", derive(::ink_storage::traits::StorageLayout))]\n#[derive(Debug, SpreadLayout)]\npub struct Data<E: Env> {\n    /// Total token supply.\n    pub total_supply: Lazy<E::Balance>,\n    /// Mapping from owner to number of owned token.\n    pub balances: StorageHashMap<E::AccountId, E::Balance>,\n    /// Mapping of the token amount which an account is allowed to withdraw\n    /// from another account.\n    pub allowances: StorageHashMap<(E::AccountId, E::AccountId), E::Balance>,\n    /// Metadatas Symbols of ERC20 Token, by (name, symbol)\n    pub metadatas: Lazy<(u8, String, String)>,\n}\n')),(0,o.kt)("h2",{id:"mutable-messages"},"Mutable Messages"),(0,o.kt)("h3",{id:"transfer"},"transfer"),(0,o.kt)("p",null,"Moves ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens from the caller's account to ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),"."),(0,o.kt)("p",null,"Returns a Result indicating whether the operation succeeded."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn transfer(&mut self, to: E::AccountId, value: E::Balance) -> Result<()> {\n        self._transfer_from_to(Self::caller(), to, value)\n    }\n")),(0,o.kt)("h3",{id:"approve"},"approve"),(0,o.kt)("p",null,"Sets ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," as the allowance of ",(0,o.kt)("inlineCode",{parentName:"p"},"spender")," over the caller's tokens."),(0,o.kt)("p",null,"Returns a boolean value indicating whether the operation succeeded."),(0,o.kt)("p",null,"IMPORTANT: Beware that changing an allowance with this method brings the risk\nthat someone may use both the old and the new allowance by unfortunate\ntransaction ordering. One possible solution to mitigate this race\ncondition is to first reduce the spender's allowance to 0 and set the\ndesired value afterwards:\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729"},"https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729")),(0,o.kt)("p",null,"Emits an ",(0,o.kt)("inlineCode",{parentName:"p"},"Approval")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn approve(&mut self, spender: E::AccountId, amount: E::Balance) -> Result<()> {\n        self._approve(Self::caller(), spender, amount)\n    }\n")),(0,o.kt)("h3",{id:"transfer_from"},"transfer_from"),(0,o.kt)("p",null,"Moves ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens from ",(0,o.kt)("inlineCode",{parentName:"p"},"sender")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient")," using the\nallowance mechanism. ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," is then deducted from the caller's\nallowance."),(0,o.kt)("p",null,"Returns a boolean value indicating whether the operation succeeded."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn transfer_from(\n        &mut self,\n        from: E::AccountId,\n        to: E::AccountId,\n        amount: E::Balance,\n    ) -> Result<()> {\n        let caller = Self::caller();\n\n        let current_allowance = self.get().allowance(from.clone(), caller.clone());\n        if current_allowance < amount {\n            return Err(Error::InsufficientAllowance)\n        }\n\n        self._transfer_from_to(from.clone(), to.clone(), amount.clone())?;\n\n        self._approve(from, caller, current_allowance - amount)?;\n\n        Ok(())\n    }\n\n")),(0,o.kt)("h2",{id:"immutable-messages"},"Immutable Messages"),(0,o.kt)("h3",{id:"name"},"name"),(0,o.kt)("p",null,"Returns the name of the token."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Returns the name of the token.\n    fn name(&self) -> String {\n        self.get().name().clone()\n    }\n")),(0,o.kt)("h3",{id:"symbol"},"symbol"),(0,o.kt)("p",null,"Returns the symbol of the token, usually a shorter version of the name."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn symbol(&self) -> String {\n        self.get().symbol().clone()\n    }\n")),(0,o.kt)("h3",{id:"decimals"},"decimals"),(0,o.kt)("p",null,"Returns the number of decimals used to get its user representation.\nFor example, if ",(0,o.kt)("inlineCode",{parentName:"p"},"decimals")," equals ",(0,o.kt)("inlineCode",{parentName:"p"},"2"),", a balance of ",(0,o.kt)("inlineCode",{parentName:"p"},"505")," tokens should\nbe displayed to a user as ",(0,o.kt)("inlineCode",{parentName:"p"},"5,05")," (",(0,o.kt)("inlineCode",{parentName:"p"},"505 / 10 ** 2"),")."),(0,o.kt)("p",null,"Tokens usually opt for a value of 18, imitating the relationship between\nEther and Wei in ETH. This is the value {ERC20} uses, unless this function is\noverridden;"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"NOTE: This information is only used for ",(0,o.kt)("em",{parentName:"p"},"display")," purposes: it in\nno way affects any of the arithmetic of the contract")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn decimals(&self) -> u8 {\n        self.get().decimals().clone()\n    }\n")),(0,o.kt)("h3",{id:"balance_of"},"balance_of"),(0,o.kt)("p",null,"Returns the amount of tokens owned by ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn balance_of(&self, account: E::AccountId) -> E::Balance {\n        self.get().balance_of(&account)\n    }\n")),(0,o.kt)("h3",{id:"total_supply"},"total_supply"),(0,o.kt)("p",null,"Returns the amount of tokens in existence."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn total_supply(&self) -> E::Balance {\n        self.get().total_supply()\n    }\n")),(0,o.kt)("h3",{id:"allowance"},"allowance"),(0,o.kt)("p",null,"Returns the remaining number of tokens that ",(0,o.kt)("inlineCode",{parentName:"p"},"spender")," will be\nallowed to spend on behalf of ",(0,o.kt)("inlineCode",{parentName:"p"},"owner")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer_from"),". This is\nzero by default."),(0,o.kt)("p",null,"This value changes when ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer_from")," are called."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn allowance(&self, owner: E::AccountId, spender: E::AccountId) -> E::Balance {\n        self.get().allowance(owner, spender)\n    }\n")),(0,o.kt)("h2",{id:"internal-functions"},"Internal Functions"),(0,o.kt)("p",null,"If the contract need make some logic by token, developers can based on this apis:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_mint")," : mint token to a account with amount"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_burn")," : burn token from a account by amount"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_transfer_from_to")," : move token from a account to another")),(0,o.kt)("h3",{id:"_mint"},"_mint"),(0,o.kt)("p",null,"Creates ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens and assigns them to ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),", increasing\nthe total supply."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event with ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," set to the zero address."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"account")," cannot be the zero address.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _mint(&mut self, account: E::AccountId, amount: E::Balance) -> Result<()> {\n        let null_account = E::AccountId::default();\n        if account == null_account {\n            return Err(Error::AccountIsZero)\n        }\n\n        self._before_token_transfer(&null_account, &account, &amount)?;\n\n        let total_supply = self.get().total_supply();\n        let account_balance = self.get().balance_of(&account);\n\n        self.get_mut().set_total_supply(total_supply + amount);\n        self.get_mut()\n            .set_balance(account.clone(), account_balance + amount);\n\n        self.emit_event_transfer(None, Some(account), amount);\n\n        Ok(())\n    }\n")),(0,o.kt)("h3",{id:"_burn"},"_burn"),(0,o.kt)("p",null,"Destroys ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," tokens from ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),", reducing the total supply."),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event with ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," set to the None address."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"account")," must have at least ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," tokens.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _burn(&mut self, account: E::AccountId, amount: E::Balance) -> Result<()> {\n        let null_account = E::AccountId::default();\n\n        if account == null_account {\n            return Err(Error::AccountIsZero)\n        }\n\n        self._before_token_transfer(&account, &null_account, &amount)?;\n\n        let account_balance = self.get().balance_of(&account);\n        let total_supply = self.get().total_supply();\n\n        if account_balance < amount {\n            return Err(Error::InsufficientBalance)\n        }\n\n        self.get_mut()\n            .set_balance(account.clone(), account_balance - amount);\n        self.get_mut().set_total_supply(total_supply - amount);\n\n        self.emit_event_transfer(Some(account), None, amount);\n\n        Ok(())\n    }\n")),(0,o.kt)("h3",{id:"_transfer_from_to"},"_transfer_from_to"),(0,o.kt)("p",null,"Moves tokens ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," from ",(0,o.kt)("inlineCode",{parentName:"p"},"sender")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),"."),(0,o.kt)("p",null,"This is internal function is equivalent to ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer"),", and can be used to"),(0,o.kt)("p",null,"e.g. implement automatic token fees, slashing mechanisms, etc.\nEmits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sender")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"recipient")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sender")," must have a balance of at least ",(0,o.kt)("inlineCode",{parentName:"li"},"amount"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _transfer_from_to(\n        &mut self,\n        sender: E::AccountId,\n        recipient: E::AccountId,\n        amount: E::Balance,\n    ) -> Result<()> {\n        let null_account = E::AccountId::default();\n\n        if sender == null_account || recipient == null_account {\n            return Err(Error::AccountIsZero)\n        }\n\n        self._before_token_transfer(&sender, &recipient, &amount)?;\n\n        let sender_balance = self.get().balance_of(&sender);\n        if sender_balance < amount {\n            return Err(Error::InsufficientBalance)\n        }\n\n        self.get_mut().set_balance(sender.clone(), sender_balance - amount);\n        let recipient_balance = self.get().balance_of(&recipient);\n        self.get_mut()\n            .set_balance(recipient.clone(), recipient_balance + amount);\n\n        self.emit_event_transfer(Some(sender), Some(recipient), amount);\n\n        Ok(())\n    }\n")),(0,o.kt)("h2",{id:"hooks"},"Hooks"),(0,o.kt)("h3",{id:"_before_token_transfer"},"_before_token_transfer"),(0,o.kt)("p",null,"Hook that is called before any transfer of tokens. This includes\nminting and burning."),(0,o.kt)("p",null,"Calling conditions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"when ",(0,o.kt)("inlineCode",{parentName:"li"},"from")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," are both non-zero, ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," of ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),"'s tokens\nwill be to transferred to ",(0,o.kt)("inlineCode",{parentName:"li"},"to"),"."),(0,o.kt)("li",{parentName:"ul"},"when ",(0,o.kt)("inlineCode",{parentName:"li"},"from")," is zero, ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," tokens will be minted for ",(0,o.kt)("inlineCode",{parentName:"li"},"to"),"."),(0,o.kt)("li",{parentName:"ul"},"when ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," is zero, ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," of ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),"'s tokens will be burned."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"from")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," are never both zero.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _before_token_transfer(\n        &mut self,\n        _from: &E::AccountId,\n        _to: &E::AccountId,\n        _amount: &E::Balance,\n    ) -> Result<()>{\n        Ok(())\n    }\n")),(0,o.kt)("h2",{id:"events"},"Events"),(0,o.kt)("h3",{id:"transfer-1"},"Transfer"),(0,o.kt)("p",null,"Event emitted when a token transfer occurs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc20)]\n    pub struct Transfer {\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        pub value: Balance,\n    }\n")),(0,o.kt)("h3",{id:"approval"},"Approval"),(0,o.kt)("p",null,"Event emitted when an approval occurs that ",(0,o.kt)("inlineCode",{parentName:"p"},"spender")," is allowed to withdraw up to the amount of ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," tokens from ",(0,o.kt)("inlineCode",{parentName:"p"},"owner"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc20)]\n    pub struct Approval {\n        #[ink(topic)]\n        pub owner: AccountId,\n        #[ink(topic)]\n        pub spender: AccountId,\n        pub value: Balance,\n    }\n")),(0,o.kt)("h2",{id:"extensions"},"Extensions"),(0,o.kt)("h3",{id:"erc20pausable"},"ERC20Pausable"),(0,o.kt)("p",null,"ERC20 token with pausable token transfers, minting and burning."),(0,o.kt)("p",null,"Useful for scenarios such as preventing trades until the end of an evaluation period, or having an emergency switch for freezing all token transfers in the event of a large bug."),(0,o.kt)("p",null,"FUNCTIONS"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"_beforeTokenTransfer(from, to, amount)")),(0,o.kt)("p",null,"For details, please refer ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/crates/components/token/erc20/src/extensions/pausable.rs"},"ERC20Pausable")," for source code."),(0,o.kt)("p",null,"Usage examples can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/example/contracts/token/erc20-pausable/lib.rs"},"here")," "),(0,o.kt)("h3",{id:"erc20burnable"},"ERC20Burnable"),(0,o.kt)("p",null,"Extension of ERC20 that allows token holders to destroy both their own tokens and those that they have an allowance for, in a way that can be recognized off-chain (via event analysis)."),(0,o.kt)("p",null,"FUNCTIONS"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"burn(amount)")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"burnFrom(account, amount)")),(0,o.kt)("p",null,"For details, please refer ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/crates/components/token/erc20/src/extensions/burnable.rs"},"ERC20Burnable")," for source code."),(0,o.kt)("p",null,"Usage examples can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/example/contracts/token/erc20-burnable/lib.rs"},"here")," "),(0,o.kt)("h3",{id:"erc20capped"},"ERC20Capped"),(0,o.kt)("p",null,"Extension of ERC20 that adds a cap to the supply of tokens."),(0,o.kt)("p",null,"FUNCTIONS"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"constructor(cap_)")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"cap()")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"_mint(account, amount)")),(0,o.kt)("p",null,"For details, please refer ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/crates/components/token/erc20/src/extensions/capped.rs"},"ERC20Capped")," for source code."),(0,o.kt)("p",null,"Usage examples can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/example/contracts/token/erc20-capped/lib.rs"},"here")," "),(0,o.kt)("h2",{id:"usage-example"},"Usage Example"),(0,o.kt)("p",null,"To make a new erc20-like token, we should import erc20 at first:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[metis_lang::contract]\npub mod contract {\n    // use Error and Result for erc20\n    pub use erc20::{\n        Error,\n        Result,\n    };\n\n    // use erc20 component\n    use metis_erc20 as erc20;\n    use metis_lang::{\n        import,\n        metis,\n    };\n\n    /// ERC-20 contract.\n    #[ink(storage)]\n    #[import(erc20)]\n    pub struct Erc20 {\n        erc20: erc20::Data<Erc20>,\n    }\n\n    // other logics\n}\n")),(0,o.kt)("p",null,"Then add the event for erc20:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Event emitted when a token transfer occurs.\n    #[ink(event)]\n    #[metis(erc20)]\n    pub struct Transfer {\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        pub value: Balance,\n    }\n\n    /// Event emitted when an approval occurs that `spender` is allowed to withdraw\n    /// up to the amount of `value` tokens from `owner`.\n    #[ink(event)]\n    #[metis(erc20)]\n    pub struct Approval {\n        #[ink(topic)]\n        pub owner: AccountId,\n        #[ink(topic)]\n        pub spender: AccountId,\n        pub value: Balance,\n    }\n")),(0,o.kt)("p",null,"Then implement the component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[cfg(not(feature = \"ink-as-dependency\"))]\n    impl erc20::Impl<Erc20> for Erc20 {\n        /// Hook that is called before any transfer of tokens. This includes\n        /// minting and burning.\n        ///\n        /// Calling conditions:\n        ///\n        /// - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n        /// will be to transferred to `to`.\n        /// - when `from` is zero, `amount` tokens will be minted for `to`.\n        /// - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n        /// - `from` and `to` are never both zero.\n        fn _before_token_transfer(\n            &mut self,\n            _from: &E::AccountId,\n            _to: &E::AccountId,\n            _amount: &E::Balance,\n        ) -> Result<()>{\n            // some logic\n\n            Ok(())\n        }\n    }\n")),(0,o.kt)("p",null,"impl the constructor for contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"impl Erc20 {\n    /// the constructor of the contract\n    #[ink(constructor)]\n    pub fn new(\n        name: String,\n        symbol: String,\n        decimals: u8,\n        initial_supply: Balance,\n    ) -> Self {\n        let mut instance = Self {\n            erc20: erc20::Data::new(),\n        };\n\n        erc20::Impl::init(&mut instance, name, symbol, decimals, initial_supply);\n\n        // do some other logic here\n\n        instance\n    }\n  }\n")),(0,o.kt)("p",null,"Then implement the messages for contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    impl Erc20 {\n        /// Returns the name of the token.\n        #[ink(message)]\n        pub fn name(&self) -> String {\n            erc20::Impl::name(self)\n        }\n\n        /// Returns the symbol of the token,\n        /// usually a shorter version of the name.\n        #[ink(message)]\n        pub fn symbol(&self) -> String {\n            erc20::Impl::symbol(self)\n        }\n\n        /// Returns the number of decimals used to\n        /// get its user representation.\n        /// For example, if `decimals` equals `2`,\n        /// a balance of `505` tokens should\n        /// be displayed to a user as `5,05` (`505 / 10 ** 2`).\n        ///\n        /// Tokens usually opt for a value of 18,\n        /// imitating the relationship between\n        /// Ether and Wei in ETH. This is the value {ERC20} uses,\n        /// unless this function is\n        /// overridden;\n        ///\n        /// NOTE: This information is only used for _display_ purposes:\n        /// it in no way affects any of the arithmetic of the contract\n        #[ink(message)]\n        pub fn decimals(&self) -> u8 {\n            erc20::Impl::decimals(self)\n        }\n\n        /// Returns the amount of tokens in existence.\n        #[ink(message)]\n        pub fn total_supply(&self) -> Balance {\n            erc20::Impl::total_supply(self)\n        }\n\n        /// Returns the amount of tokens owned by `account`.\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> Balance {\n            erc20::Impl::balance_of(self, owner)\n        }\n\n        /// Returns the remaining number of tokens that `spender` will be\n        /// allowed to spend on behalf of `owner` through {transferFrom}. This is\n        /// zero by default.\n        ///\n        /// This value changes when {approve} or {transferFrom} are called.\n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance {\n            erc20::Impl::allowance(self, owner, spender)\n        }\n\n        /// Moves `amount` tokens from the caller's account to `recipient`.\n        ///\n        /// Returns a boolean value indicating whether the operation succeeded.\n        ///\n        /// Emits a {Transfer} event.\n        #[ink(message)]\n        pub fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()> {\n            erc20::Impl::transfer(self, to, value)\n        }\n\n        /// Sets `amount` as the allowance of `spender` over the caller's tokens.\n        ///\n        /// Returns a boolean value indicating whether the operation succeeded.\n        ///\n        /// IMPORTANT: Beware that changing an allowance with this method brings\n        /// the risk that someone may use both the old and the new allowance\n        /// by unfortunate transaction ordering. One possible solution to \n        /// mitigate this race condition is to first reduce the spender's \n        /// allowance to 0 and set the desired value afterwards:\n        /// <https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729>\n        ///\n        /// Emits an {Approval} event.\n        #[ink(message)]\n        pub fn approve(&mut self, spender: AccountId, value: Balance) -> Result<()> {\n            erc20::Impl::approve(self, spender, value)\n        }\n\n        /// Moves `amount` tokens from `sender` to `recipient` using the\n        /// allowance mechanism. `amount` is then deducted from the caller's\n        /// allowance.\n        ///\n        /// Returns a boolean value indicating whether the operation succeeded.\n        ///\n        /// Emits a {Transfer} event.\n        #[ink(message)]\n        pub fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            erc20::Impl::transfer_from(self, from, to, value)\n        }\n    }\n")),(0,o.kt)("p",null,"In the end, we can add some other messages."))}m.isMDXComponent=!0}}]);