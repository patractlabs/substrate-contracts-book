"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[5741],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=l(n),m=r,w=d["".concat(c,".").concat(m)]||d[m]||p[m]||s;return n?a.createElement(w,o(o({ref:t},u),{},{components:n})):a.createElement(w,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var l=2;l<s;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2322:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return d}});var a=n(7462),r=n(3366),s=(n(7294),n(3905)),o=["components"],i={},c="Escrow",l={unversionedId:"metis/guides/utilities/escrow",id:"metis/guides/utilities/escrow",isDocsHomePage:!1,title:"Escrow",description:"Base escrow contract, holds funds designated for a payee until they",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/metis/guides/utilities/escrow.md",sourceDirName:"metis/guides/utilities",slug:"/metis/guides/utilities/escrow",permalink:"/substrate-contracts-book/en/metis/guides/utilities/escrow",editUrl:"https://github.com/patractlabs/substrate-contracts-book/edit/master/docs/metis/guides/utilities/escrow.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"ERC165",permalink:"/substrate-contracts-book/en/metis/guides/tools/erc165"},next:{title:"Report for Metis proposals",permalink:"/substrate-contracts-book/en/metis/reports/reports"}},u=[{value:"Dependency",id:"dependency",children:[]},{value:"Storage",id:"storage",children:[]},{value:"Mutable Messages",id:"mutable-messages",children:[{value:"deposit",id:"deposit",children:[]},{value:"withdraw",id:"withdraw",children:[]}]},{value:"Immutable Messages",id:"immutable-messages",children:[{value:"deposits_of",id:"deposits_of",children:[]}]},{value:"Events",id:"events",children:[{value:"Deposited",id:"deposited",children:[]},{value:"Withdrawn",id:"withdrawn",children:[]}]},{value:"Usage Example",id:"usage-example",children:[]}],p={toc:u};function d(e){var t=e.components,n=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"escrow"},"Escrow"),(0,s.kt)("p",null,"Base escrow contract, holds funds designated for a payee until they\nwithdraw them."),(0,s.kt)("p",null,"Intended usage: This contract (and derived escrow contracts) should be a\nstandalone contract, that only interacts with the contract that instantiated\nit. That way, it is guaranteed that all Tokens will be handled according to\nthe ",(0,s.kt)("inlineCode",{parentName:"p"},"Escrow")," rules, and there is no need to check for payable functions or\ntransfers in the inheritance tree. The contract that uses the escrow as its\npayment method should be its owner, and provide public methods redirecting\nto the escrow's deposit and withdraw."),(0,s.kt)("h2",{id:"dependency"},"Dependency"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'metis_escrow  = { git = "https://github.com/patractlabs/metis", default-features = false }\n')),(0,s.kt)("h2",{id:"storage"},"Storage"),(0,s.kt)("p",null,"the deposits is the map of payee to balance:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'/// The Data of escrow component\n#[cfg_attr(feature = "std", derive(::ink_storage::traits::StorageLayout))]\n#[derive(Debug, SpreadLayout)]\npub struct Data<E>\nwhere\n    E: Env,\n{\n    /// The owner of contract\n    pub deposits: StorageHashMap<E::AccountId, E::Balance>,\n}\n')),(0,s.kt)("h2",{id:"mutable-messages"},"Mutable Messages"),(0,s.kt)("h3",{id:"deposit"},"deposit"),(0,s.kt)("p",null,"Stores the sent amount as credit to be withdrawn."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"    /// @param payee The destination address of the funds.\n    fn deposit(&mut self, payee: E::AccountId) {\n        self.ensure_caller_is_owner();\n\n        let amount = Self::transferred_balance();\n\n        Storage::<E, Data<E>>::get_mut(self).add(&payee, &amount);\n\n        self.emit_event_deposited(payee, amount);\n    }\n")),(0,s.kt)("h3",{id:"withdraw"},"withdraw"),(0,s.kt)("p",null,"Withdraw accumulated balance for a payee, forwarding all gas to the recipient."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\nMake sure you trust the recipient, or are either following the\nchecks-effects-interactions pattern or using {ReentrancyGuard}.")),(0,s.kt)("p",null,"param:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"payee")," : The address whose funds will be withdrawn and transferred to.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'    fn withdraw(&mut self, payee: E::AccountId) {\n        self.ensure_caller_is_owner();\n\n        let payment = Storage::<E, Data<E>>::get(self).get(&payee);\n\n        Storage::<E, Data<E>>::get_mut(self).clean(&payee);\n\n        let res = Self::transfer(payee.clone(), payment);\n        assert!(res.is_ok(), "Escrow: transfer to payee error");\n\n        self.emit_event_withdrawn(payee, payment);\n    }\n')),(0,s.kt)("h2",{id:"immutable-messages"},"Immutable Messages"),(0,s.kt)("h3",{id:"deposits_of"},"deposits_of"),(0,s.kt)("p",null,"Return the deposits of payee"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"    fn deposits_of(&self, payee: &E::AccountId) -> E::Balance {\n        Storage::<E, Data<E>>::get(self).get(payee)\n    }\n")),(0,s.kt)("h2",{id:"events"},"Events"),(0,s.kt)("h3",{id:"deposited"},"Deposited"),(0,s.kt)("p",null,"Event emitted when payee deposit amount"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(escrow)]\n    pub struct Deposited {\n        #[ink(topic)]\n        pub payee: AccountId,\n        pub amount: Balance,\n    }\n")),(0,s.kt)("h3",{id:"withdrawn"},"Withdrawn"),(0,s.kt)("p",null,"Event emitted when payee withdraw"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(escrow)]\n    pub struct Withdrawn {\n        #[ink(topic)]\n        pub payee: AccountId,\n        pub amount: Balance,\n    }\n")),(0,s.kt)("h2",{id:"usage-example"},"Usage Example"),(0,s.kt)("p",null,"To use ",(0,s.kt)("inlineCode",{parentName:"p"},"Escrow")," component, should import escrow, in most cases it also need a access control component, the example we use ownable:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"#[metis_lang::contract]\npub mod mock {\n    use metis_escrow as escrow;\n    use metis_lang::{\n        import,\n        metis,\n    };\n    use metis_ownable as ownable;\n\n    #[ink(storage)]\n    #[import(ownable, escrow)]\n    pub struct Escrow {\n        ownable: ownable::Data<Escrow>,\n        escrow: escrow::Data<Escrow>,\n    }\n\n    // others\n}\n")),(0,s.kt)("p",null,"then define the events:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Event emitted when payee deposit amount\n    #[ink(event)]\n    #[metis(escrow)]\n    pub struct Deposited {\n        #[ink(topic)]\n        pub payee: AccountId,\n        pub amount: Balance,\n    }\n\n    /// Event emitted when payee withdraw\n    #[ink(event)]\n    #[metis(escrow)]\n    pub struct Withdrawn {\n        #[ink(topic)]\n        pub payee: AccountId,\n        pub amount: Balance,\n    }\n\n    /// Event emitted when Owner AccountId Transferred\n    #[ink(event)]\n    #[metis(ownable)]\n    pub struct OwnershipTransferred {\n        /// previous owner account id\n        #[ink(topic)]\n        previous_owner: Option<AccountId>,\n        /// new owner account id\n        #[ink(topic)]\n        new_owner: Option<AccountId>,\n    }\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"OwnershipTransferred")," event is for ownable component."),(0,s.kt)("p",null,"Add the constructor:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"        #[ink(constructor)]\n        pub fn new() -> Self {\n            let mut instance = Self {\n                ownable: ownable::Data::new(),\n                escrow: escrow::Data::new(),\n            };\n\n            ownable::Impl::init(&mut instance);\n\n            // escrow not need init\n\n            instance\n        }\n\n")),(0,s.kt)("p",null,"The messages, not forget the ",(0,s.kt)("inlineCode",{parentName:"p"},"payable"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"        /// return the deposits of account\n        #[ink(message)]\n        pub fn deposits_of(&self, payee: AccountId) -> Balance {\n            escrow::Impl::deposits_of(self, &payee)\n        }\n\n        /// deposit by payee, the pay value is the amount to transfer\n        #[ink(message, payable)]\n        pub fn deposit(&mut self, payee: AccountId) {\n            ownable::Impl::ensure_caller_is_owner(self);\n            escrow::Impl::deposit(self, payee)\n        }\n\n        // withdraw all deposits from the payee\n        #[ink(message)]\n        pub fn withdraw(&mut self, payee: AccountId) {\n            ownable::Impl::ensure_caller_is_owner(self);\n            escrow::Impl::withdraw(self, payee)\n        }\n")),(0,s.kt)("p",null,"In most cases, the owner of escrow contract should be another contract, the contract call the ",(0,s.kt)("inlineCode",{parentName:"p"},"deposit")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"withdraw")," from its contract."),(0,s.kt)("p",null,"To call the escrow contract, developer can use the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/master/crates/components/utils/escrow/stub/src/lib.rs"},"stub")," of the escrow"))}d.isMDXComponent=!0}}]);