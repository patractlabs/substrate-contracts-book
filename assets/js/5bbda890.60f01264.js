"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[4464],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=s(n),u=r,h=m["".concat(c,".").concat(u)]||m[u]||d[u]||i;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9359:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return p},default:function(){return m}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={},c=void 0,s={unversionedId:"europa/reports/v0.2Report",id:"europa/reports/v0.2Report",isDocsHomePage:!1,title:"v0.2Report",description:"Report for Europa v0.2",source:"@site/docs/europa/reports/v0.2Report.md",sourceDirName:"europa/reports",slug:"/europa/reports/v0.2Report",permalink:"/substrate-contracts-book/europa/reports/v0.2Report",editUrl:"https://github.com/patractlabs/substrate-contracts-book/edit/master/docs/europa/reports/v0.2Report.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Report for Europa v0.1",permalink:"/substrate-contracts-book/europa/reports/v0.1Report"},next:{title:"v0.3Report",permalink:"/substrate-contracts-book/europa/reports/v0.3Report"}},p=[{value:"Report for Europa v0.2",id:"report-for-europa-v02",children:[{value:"Recap of Europa&#39;s future plan",id:"recap-of-europas-future-plan",children:[]},{value:"Recap of verification for Europa v0.2:",id:"recap-of-verification-for-europa-v02",children:[]}]},{value:"1.Design",id:"1design",children:[{value:"1.1 on <code>Pallet Contracts</code> layer",id:"11-on-pallet-contracts-layer",children:[]},{value:"1.2 on <code>wasmi</code> layer",id:"12-on-wasmi-layer",children:[]},{value:"1.3 Contract Log functions",id:"13-contract-log-functions",children:[]}]},{value:"2. What Europa can do in v0.2",id:"2-what-europa-can-do-in-v02",children:[{value:"2.1 Build",id:"21-build",children:[]},{value:"example",id:"example",children:[]}]}],d={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"report-for-europa-v02"},"Report for Europa v0.2"),(0,i.kt)("p",null,"Six weeks ago, Patract Hub (",(0,i.kt)("a",{parentName:"p",href:"https://patract.io"},"https://patract.io"),") applied a ",(0,i.kt)("a",{parentName:"p",href:"https://polkadot.polkassembly.io/treasury/27"},"Treasury Proposal #27")," for Europa v0.2 , and now we have finished all the development work in (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/Europa"},"https://github.com/patractlabs/Europa"),"). Europa is kind of another implementation for ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/tree/master/client"},"Substrate client"),' in our design. We know that the runtime of a blockchain is the business logic that defines its behavior, and the Substrate runtime need to run by an executor and environment. So that we design the executor and environment more like a "sandbox" to run a Substrate runtime.'),(0,i.kt)("p",null,"In v0.2, the primary target is to modify ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," in runtime to provide more detailed debugging information, including contract execution process information (in ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," layer) and Wasm execution information (in WASMI execution layer)."),(0,i.kt)("h3",{id:"recap-of-europas-future-plan"},"Recap of Europa's future plan"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("del",{parentName:"li"},"v0.1: Have an independent runtime environment to facilitate more subsequent expansion directions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("del",{parentName:"li"},"v0.2: Modify at FRAME Contracts pallet level to provide more information")),(0,i.kt)("li",{parentName:"ul"},"v0.3: Improve the development experience, strengthen collaboration with other tools, and extend the sandbox to be compatible with other runtime modules\u3002")),(0,i.kt)("h3",{id:"recap-of-verification-for-europa-v02"},"Recap of verification for Europa v0.2:"),(0,i.kt)("blockquote",null,(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Construct incorrect contracts and execute logs printing to determine whether it meets expectations"),(0,i.kt)("li",{parentName:"ul"},"Display the call statistics of the ",(0,i.kt)("inlineCode",{parentName:"li"},"define_env!")," interface during contract execution"),(0,i.kt)("li",{parentName:"ul"},"Execute the log printing function, provide formatted printing examples of different data, and judge whether it meets expectations"),(0,i.kt)("li",{parentName:"ul"},"Construct a contract that crashes under different conditions and record the log after execution. Then judge whether the backtrace information of the contract execution is completely printed, and check whether it matches the actual execution of the collapsed contract."))),(0,i.kt)("h2",{id:"1design"},"1.Design"),(0,i.kt)("p",null,"In 0.2, the debugging information function of the upgrade contract module is divided into three parts of modification:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Modification on the ",(0,i.kt)("inlineCode",{parentName:"li"},"Pallet Contracts")," layer: By adding trace during the execution of the contract by ",(0,i.kt)("inlineCode",{parentName:"li"},"Pallet Contracts"),", the information in the contract layer is recorded, and the calling level of the contract is recorded. On the other hand, the error message of calling Wasm execution is improved."),(0,i.kt)("li",{parentName:"ul"},"Modification on the ",(0,i.kt)("inlineCode",{parentName:"li"},"wasmi")," layer: We have provided the backtrace function of recording wasm execution for ",(0,i.kt)("inlineCode",{parentName:"li"},"wasmi"),", and provided support for ",(0,i.kt)("inlineCode",{parentName:"li"},"parity-wasm"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"pwasm-utils"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"cargo-contract")," during wasm processing of the contract contains the function of the name section."),(0,i.kt)("li",{parentName:"ul"},"Contract logging function: Use the function of ",(0,i.kt)("inlineCode",{parentName:"li"},"ChainExtensions")," to realize the library for printing the ",(0,i.kt)("inlineCode",{parentName:"li"},"log")," in the contract.")),(0,i.kt)("p",null,"In the current ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts"),", when an error occurs in the execution of ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmi"),", and in the ",(0,i.kt)("a",{parentName:"p",href:"https://webassembly.github.io/spec/core/exec/runtime.html#function-instances"},"host_function")," call of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," during the execution of wasmi, it will be displayed as a ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractTrap")," error externally. In this situation, it is difficult for developers to locate the cause of the error. Only from this information, it is impossible to tell whether the problem is the contract itself, ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts"),". Therefore, the rich information that Europa v0.2 can provide allows developers to directly locate the cause of the problem."),(0,i.kt)("h3",{id:"11-on-pallet-contracts-layer"},"1.1 on ",(0,i.kt)("inlineCode",{parentName:"h3"},"Pallet Contracts")," layer"),(0,i.kt)("p",null,"During the contract debugging process, Europa believes that developers need:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Rich error information: Wasm records the error information during the entire execution process, including Wasm executor errors and host_function errors. The backtrace information of wasmi will be unified with the error information here."),(0,i.kt)("li",{parentName:"ol"},"Execution in the debugging process: The main modification information of ",(0,i.kt)("inlineCode",{parentName:"li"},"Pallet Contracts"),', the "contract stack" is used to record the process of contract calling contract, and any information that can assist debugging during the execution of this layer of contract, such as the situation of calling the host_function, selector, and calling contract parameters, etc.')),(0,i.kt)("p",null,"Therefore, in response to such needs, Europa made the following designs and modifications:"),(0,i.kt)("h4",{id:"111-rich-error-information"},"1.1.1 rich error information"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"1.error on the wasm executor layer\uff1a")," "),(0,i.kt)("p",null,"Europa designed our own ",(0,i.kt)("inlineCode",{parentName:"p"},"ep-sandbox")," to replace the original ",(0,i.kt)("inlineCode",{parentName:"p"},"sp-sandbox")," used by ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts"),", and modified ",(0,i.kt)("inlineCode",{parentName:"p"},"ep_sandbox::Error")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"use patract_wasmi::Error as WasmiError;\npub enum Error {\nModule(WasmiError),\nOutOfBounds,\nExecution,\nWasmiExecution(WasmiError),\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Module(WasmiError)")," carries the original error information of the Wasm layer, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"to_execution_result")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"frame/contracts/src/wasm/runtime.rs")," is converted to ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," to throw an error message."),(0,i.kt)("p",null,"Europa's own ",(0,i.kt)("inlineCode",{parentName:"p"},"ep-sandbox")," only has the ",(0,i.kt)("inlineCode",{parentName:"p"},"std")," version (because Europa has removed all Wasm parts, there is no need for ",(0,i.kt)("inlineCode",{parentName:"p"},"ep-sandbox")," to support ",(0,i.kt)("inlineCode",{parentName:"p"},"no-std"),"), so in the future, ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"ep-sandbox")," can be replaced with different wasm executors to support running tests of different wasm executors, and replaced with wasm executors that support debugging and other features. ")),(0,i.kt)("p",null,"Currently ",(0,i.kt)("inlineCode",{parentName:"p"},"ep-sandbox")," uses a forked version of ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmi")," as the executor, so the error it throws is ",(0,i.kt)("inlineCode",{parentName:"p"},"WasmiError"),". See the next chapter for errors in",(0,i.kt)("inlineCode",{parentName:"p"},"wasmi"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"2.error of host_functions:")),(0,i.kt)("p",null,"The host function execution error will cause Trap, and will record ",(0,i.kt)("inlineCode",{parentName:"p"},"TrapReason"),". No modification to the data structure, just record."),(0,i.kt)("h4",{id:"112-execution-during-debugging"},"1.1.2 Execution during debugging"),(0,i.kt)("p",null,"The Europa forked version of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," has designed an object to record any information that can help debugging during contract execution:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"/// Record the contract execution context.\npub struct NestedRuntime {\n    /// Current depth\n    depth: usize,\n    /// The current contract execute result\n    ext_result: ExecResult,\n    /// The value in sandbox successful result\n    sandbox_result_ok: Option<ReturnValue>,\n    /// Who call the current contract\n    caller: AccountId32,\n    /// The account of the current contract\n    self_account: Option<AccountId32>,\n    /// The input selector\n    selector: Option<HexVec>,\n    /// The input arguments\n    args: Option<HexVec>,\n    /// The value in call or the endowment in instantiate\n    value: u128,\n    /// The gas limit when this contract is called\n    gas_limit: Gas,\n    /// The gas left when this contract return\n    gas_left: Gas,\n    /// The host function call stack\n    env_trace: EnvTraceList,\n    /// The error in wasm\n    wasm_error: Option<WasmErrorWrapper>,\n    /// The trap in host function execution\n    trap_reason: Option<TrapReason>,\n    /// Nested contract execution context\n    nest: Vec<NestedRuntime>,\n}\n")),(0,i.kt)("p",null,"In the model of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts"),', a contract calling another contract is in the "contract stack" model, so ',(0,i.kt)("inlineCode",{parentName:"p"},"NestedRuntime")," will track the execution process of the entire contract stack, and use the property of ",(0,i.kt)("inlineCode",{parentName:"p"},"nest")," to store a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"NestedRuntime")," to represent other contracts the the contract called."),(0,i.kt)("p",null,"In the process of executing a contract by ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts"),", Europa records the relevant information in the execution process in the structure of ",(0,i.kt)("inlineCode",{parentName:"p"},"NestedRuntime")," in the form of a bypass, and will print the ",(0,i.kt)("inlineCode",{parentName:"p"},"NestedRuntime")," to the log (show the case later) in a certain format after the contract call ends. Contract developers can analyze the information printed by ",(0,i.kt)("inlineCode",{parentName:"p"},"NestedRuntime")," to obtain various detailed information during the execution of the contract, which can be used in various situations:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"help to locate where the error occurs, including the following situations:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Pallet Contracts")," layer"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ink!")," layer"),(0,i.kt)("li",{parentName:"ol"},"The specific position in the contract layer"),(0,i.kt)("li",{parentName:"ol"},"Locate which level of the contract is when a contract calling another contract"))),(0,i.kt)("li",{parentName:"ol"},"Analyze the information during the execution of the contract at this timing:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Analyze the consumption of gas execution"),(0,i.kt)("li",{parentName:"ol"},"Analyze the call of ",(0,i.kt)("inlineCode",{parentName:"li"},"get_storage")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"set_storage"),", help reconstruct the contract code and analyze the demand of ",(0,i.kt)("inlineCode",{parentName:"li"},"rent")),(0,i.kt)("li",{parentName:"ol"},"According to ",(0,i.kt)("inlineCode",{parentName:"li"},"selector"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"args")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"value"),", analyze and locate whether the transaction parameters of the third-party SDK are legal."),(0,i.kt)("li",{parentName:"ol"},"Analyze the execution path of the contract and adjust the contract based on the ",(0,i.kt)("inlineCode",{parentName:"li"},"nest")," information and combined with the ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_call")," information."),(0,i.kt)("li",{parentName:"ol"},"etc.")))),(0,i.kt)("p",null,"The process of recording ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," executing contract to ",(0,i.kt)("inlineCode",{parentName:"p"},"NestEdRuntime")," is relatively fine-grained.\nThe process of logging the information of the execution contract of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"NestEdRuntime")," is relatively fine-grained. Take ",(0,i.kt)("inlineCode",{parentName:"p"},"seal_call")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"define_env!")," as an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct SealCall {\n    callee: Option<HexVec>,\n    gas: u64,\n    value: Option<u128>,\n    input: Option<HexVec>,\n    output: Option<HexVec>,\n}\n")),(0,i.kt)("p",null,"The attributes are basically ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<>"),". For example, before calling the contract, the ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," will be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"Some"),", and the return value will be set after the calling contract is normal. If there is an error in the calling contract, then ",(0,i.kt)("inlineCode",{parentName:"p"},"output")," will remain ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),". Therefore, if ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"output")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", it means that there is a problem with the called contract during the process of calling the contract."),(0,i.kt)("p",null,"The current information of ",(0,i.kt)("inlineCode",{parentName:"p"},"NestedRuntime")," is only printed in the log. ",(0,i.kt)("strong",{parentName:"p"},"In the future, ",(0,i.kt)("inlineCode",{parentName:"strong"},"NestedRuntime")," will be stored locally and provide corresponding RPC for external access"),". Therefore, in the future, third-party applications can obtain ",(0,i.kt)("inlineCode",{parentName:"p"},"NestedRuntime")," for further processing. For example, in our ",(0,i.kt)("inlineCode",{parentName:"p"},"Redspot"),", a plug-in can be designed to generate a contract call another contract topology based on the information of ",(0,i.kt)("inlineCode",{parentName:"p"},"NestedRuntime"),", and a visual contract call path can be generated on the web wallet interface, etc."),(0,i.kt)("h3",{id:"12-on-wasmi-layer"},"1.2 on ",(0,i.kt)("inlineCode",{parentName:"h3"},"wasmi")," layer"),(0,i.kt)("p",null,"We forked wasmi and integrated it into ",(0,i.kt)("inlineCode",{parentName:"p"},"ep-sandbox"),". Forked ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," can obtain the error information of forked ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmi")," through ",(0,i.kt)("inlineCode",{parentName:"p"},"ep-sandbox"),", including the backtrace information of ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmi"),"."),(0,i.kt)("p",null,"If you need to make ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmi")," can retain the backtrace information during execution, you need to have the following functions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},'The "name section" section is required in the Wasm source file (see ',(0,i.kt)("a",{parentName:"li",href:"https://webassembly.github.io/spec/core/appendix/custom.html#name-section"},"the specification of name section)"),")"),(0,i.kt)("li",{parentName:"ol"},'Keep the "name section" information in the process of checking the contract by ',(0,i.kt)("inlineCode",{parentName:"li"},"Pallet Contracts")," and still have a corresponding relationship with the wasm source file after the process."),(0,i.kt)("li",{parentName:"ol"},"During the execution of ",(0,i.kt)("inlineCode",{parentName:"li"},"wasmi"),', the execution stack needs to be preserved with the key information of the functions. At the same time, the "name section" needs to be parsed and correspond to the function information reserved by the ',(0,i.kt)("inlineCode",{parentName:"li"},"wasmi")," execution stack.")),(0,i.kt)("p",null,"The changes to 2 involve ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo-build")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"parity-wasm"),", while the changes to 1 and 3 are mainly in the forked ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmi"),", and a small part involves ",(0,i.kt)("inlineCode",{parentName:"p"},"pwasm-utils"),"."),(0,i.kt)("h4",{id:"121-submitted-wasm-files-contains-debug-info-from-name-section"},'1.2.1 Submitted Wasm files contains debug info from "name section"'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"PR: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/paritytech/cargo-contract/pull/131"},"paritytech/cargo-contract#131")),(0,i.kt)("li",{parentName:"ul"},"Source: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/patractlabs/cargo-contract"},"patractlabs/cargo-contract"))),(0,i.kt)("p",null,"Frist of all, we have to submit ",(0,i.kt)("strong",{parentName:"p"},"wasm files which contain the debug info")," that the on-chain side can parse and get the panic errors."),(0,i.kt)("p",null,"Currently, ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/cargo-contract"},"parity/cargo-contract")," trims debug info while building contracts, we can get them back with the following steps."),(0,i.kt)("h5",{id:"1-keep-name-section-from-striping"},"1. Keep name section from striping"),(0,i.kt)("p",null,"The name section has been striped at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/cargo-contract/blob/71525f9ec5f21e6113a614c2fb4d1eb5e62ebf8b/src/cmd/build.rs#L247"},"cargo-contract/cmd/build.rs#L247"),"."),(0,i.kt)("h5",{id:"2-keep-debug-info-from-wasm-opt"},"2. Keep debug info from ",(0,i.kt)("inlineCode",{parentName:"h5"},"wasm-opt")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract")," passes ",(0,i.kt)("inlineCode",{parentName:"p"},"debug_info: false")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"wasm-opt"),", so the debug-info will be always optimized when we run ",(0,i.kt)("inlineCode",{parentName:"p"},"wasm-opt"),", the code is here: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/cargo-contract/blob/71525f9ec5f21e6113a614c2fb4d1eb5e62ebf8b/src/cmd/build.rs#L267"},"cargo-contract/cmd/build.rs#L267"),"."),(0,i.kt)("h5",{id:"3-keep-debug-info-from-rustc"},"3. Keep debug info from ",(0,i.kt)("inlineCode",{parentName:"h5"},"rustc")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract")," executes realease build by default, here we can enable debug build or modify the opt-level flag of ",(0,i.kt)("inlineCode",{parentName:"p"},"rustc")," to keep debug infos at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/cargo-contract/blob/71525f9ec5f21e6113a614c2fb4d1eb5e62ebf8b/src/cmd/build.rs#L137"},"cargo-contract/cmd/build.rs#L137"),"."),(0,i.kt)("h4",{id:"122-save-debug-info-from-the-scraper-of-pallet-contracts"},"1.2.2 Save debug info from the scraper of ",(0,i.kt)("inlineCode",{parentName:"h4"},"Pallet Contracts")),(0,i.kt)("p",null,"What happends to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," while we calling a contract?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Get the Wasm binary from storage")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Inject gas meter to the contract")),(0,i.kt)("li",{parentName:"ul"},"Inject stack height to the contract"),(0,i.kt)("li",{parentName:"ul"},"Put the contract into ",(0,i.kt)("inlineCode",{parentName:"li"},"sp-sandbox")," and execute it"),(0,i.kt)("li",{parentName:"ul"},"Get the result from ",(0,i.kt)("inlineCode",{parentName:"li"},"sp-sandbox")," and return the result to us")),(0,i.kt)("h5",{id:"1-store-name-section-while-building-wasm-module"},"1. Store name section while building Wasm module"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"PR: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/paritytech/parity-wasm/pull/300"},"https://github.com/paritytech/parity-wasm/pull/300"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," builds Wasm modules from storage and drops custom sections by default, here we should get them back."),(0,i.kt)("h5",{id:"2-update-function-indices-in-name-section-while-injecting-gas-meter"},"2. Update function indices in name section while injecting gas meter"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"PR: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/paritytech/wasm-utils/pull/146"},"paritytech/wasm-utils#146")),(0,i.kt)("li",{parentName:"ul"},"Source: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/patractlabs/wasm-utils"},"patractlabs/wasm-utils#146"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," reorders the indcies of functions in our Wasm contracts after injecting gas memter to the Wasm contracts at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/wasm-utils/blob/d9432bafa9321f8e0e5b8a143f1ed858dbbbe272/src/gas/mod.rs#L467"},"paritytech/wasm-utils/gas/mod.rs#L467"),", this will mess up the function indecies in name section that we can not get the correct backtraces."),(0,i.kt)("h4",{id:"3-impelment-wasm-backtrace-to-wasmi"},"3. Impelment Wasm backtrace to WASMI"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Source: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/patractlabs/wasmi"},"patractlabs/wasmi"))),(0,i.kt)("p",null,"Remember the last two steps in chapter 2, the core part of enabling Wasm backtrace to ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contract")," is making ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmi")," support backtrace."),(0,i.kt)("p",null,"The process of executing a function in the interpreter of wasmi is like:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Invoke the target function"),(0,i.kt)("li",{parentName:"ul"},"call and call and call over again",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Panic if the process breaks.")))),(0,i.kt)("h5",{id:"add-function-info-field-to-funcref"},"Add function info field to ",(0,i.kt)("inlineCode",{parentName:"h5"},"FuncRef")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"FuncRef")," is the 'function' wasmi interpreter calling directly, so we need to embed the debug info into the ",(0,i.kt)("inlineCode",{parentName:"p"},"FuncRef")," as the first time, source at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/wasmi/blob/v0.6.2/src/func.rs#L26"},"wasmi/func.rs#L26"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"//! patractlabs/wasmi/src/func.rs#L26\n/// ...\npub struct FuncRef {\n    /// ...\n    /// Function name and index for debug\n    info: Option<(usize, String)>,\n}\n")),(0,i.kt)("h5",{id:"set-function-info-using-name-section-while-parsing-wasm-modules"},"Set function info using name section while parsing Wasm modules"),(0,i.kt)("p",null,"We alread have the ",(0,i.kt)("inlineCode",{parentName:"p"},"info")," field in ",(0,i.kt)("inlineCode",{parentName:"p"},"FuncRef"),", now we need to fill this field using name section while parsing Wasm modules, source at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/wasmi/blob/7a6feaea70f47aa6e62f097fb0d9a4ea0ce7d1fc/src/runner.rs#L1491"},"wasmi/module#L343"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'//! wasmi/src/module.rs#L343\n// ...\nif has_name_section {\n     if let Some(name) = function_names.get((index + import_count) as u32) {\n         func_instance = func_instance.set_info(index, name.to_string());\n     } else {\n         func_instance = func_instance.set_info(index, "<unknown>".to_string());\n     }\n}\n// ...\n')),(0,i.kt)("h5",{id:"make-the-interpreter-support-trace"},"Make the interpreter support ",(0,i.kt)("inlineCode",{parentName:"h5"},"trace")),(0,i.kt)("p",null,"However, we don't need to get infos of every functions but the panicked series in the stack of the interpreter, source at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/wasmi/blob/7a6feaea70f47aa6e62f097fb0d9a4ea0ce7d1fc/src/runner.rs#L1491"},"wasmi/runner.rs#L1491"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"//! wasmi/src/runner.rs#L1491\n/// Get the functions of current the stack\npub fn trace(&self) -> Vec<Option<&(usize, String)>> {\n    self.buf.iter().map(|f| f.info()).collect::<Vec<_>>()\n}\n")),(0,i.kt)("h5",{id:"gather-debug-infos-when-program-breaks"},"Gather debug infos when program breaks"),(0,i.kt)("p",null,"Just gather backtraces when we invoke function failed, source at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/wasmi/blob/7a6feaea70f47aa6e62f097fb0d9a4ea0ce7d1fc/src/func.rs#L170"},"wasmi/func.rs#L170"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'//! wasmi/src/func.rs#L170\n// ...\n\nlet res = interpreter.start_execution(externals);\nif let Err(trap) = res {\nlet mut stack = interpreter\n    .trace()\n    .iter()\n    .map(|n| {\n        if let Some(info) = n {\n            format!("{:#}[{}]", rustc_demangle::demangle(&info.1), info.0)\n        } else {\n            "<unknown>".to_string()\n        }\n    })\n    .collect::<Vec<_>>();\n\n// Append the panicing trap\nstack.append(&mut trap.wasm_trace().clone());\nstack.reverse();\n\n// Embed this info into the trap\nErr(trap.set_wasm_trace(stack))\n\n// ...\n')),(0,i.kt)("h3",{id:"13-contract-log-functions"},"1.3 Contract Log functions"),(0,i.kt)("p",null,"In the process of contract debugging, you need to know the internal execution of the contract and the intermediate data. In the current lack of debugging conditions (such as using gdb for debugging), log printing is the most convenient way. As mentioned in the Europa v0.2 proposal, the current ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," already support ",(0,i.kt)("inlineCode",{parentName:"p"},"format!"),"+",(0,i.kt)("inlineCode",{parentName:"p"},"seal_println")," to format and print strings, but this mode has two defects :"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"All the logs of ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_println")," printed on the node side are ",(0,i.kt)("inlineCode",{parentName:"li"},"target: runtime")," and level ",(0,i.kt)("inlineCode",{parentName:"li"},"DEBUG"),", but when developing complex contracts, a lot of logs will be printed. If you cannot filter by ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," and log level, then the development process will be full of interference from irrelevant information."),(0,i.kt)("li",{parentName:"ol"},"The contract developer wrote ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_println")," when needed during the development process, but all ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_println")," must be deleted when the contract is released. Although the contract developer can encapsulate a conditionally compiled function to control it, it is more convenient if a tool library already provides such a function.")),(0,i.kt)("p",null,"Therefore, Europa provides a log library ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/ink-log"},"patractlabs/ink-log")," that mimics Rust's ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," crete to solve the above problems. Its usage is the same as that of Rust. ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," is completely consistent, which reduces the learning cost of developers."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ink-log")," is generally implemented by the ",(0,i.kt)("inlineCode",{parentName:"p"},"ChainExtension")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts"),", the agreed ",(0,i.kt)("inlineCode",{parentName:"p"},"function_id")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"0xfeffff00"),", and the message is transmitted in the wasm memory through the structure ",(0,i.kt)("inlineCode",{parentName:"p"},"LoggerExt"),". Therefore this library is divided into the following two parts:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ink_log"),": In the ",(0,i.kt)("inlineCode",{parentName:"p"},"ink-log/contracts")," directory, provide ",(0,i.kt)("inlineCode",{parentName:"p"},"info!"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"debug!"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"warn!"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"error!"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"trace!"),", same as Rust's ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," library in the same macro, and the call method of the macro is also the same. These macros are packaged implementations of ",(0,i.kt)("inlineCode",{parentName:"p"},"seal_chain_extensions")," on the ink! side, and are ",(0,i.kt)("strong",{parentName:"p"},"tool library for contract developers"),". For example, after this library is introduced in the contract ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),", the log can be printed as follows:"),(0,i.kt)("p",{parentName:"li"},"In ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cargo"},'[dependencies]\nink_log = { version = "0.1", git = "https://github.com/patractlabs/ink-log", default-features = false, features = ["ink-log-chain-extensions"] }\n\n[features]\ndefault = ["std"]\nstd = [\n    # ...\n    "ink_log/std"\n]\n')),(0,i.kt)("p",{parentName:"li"},"In the contract, you can use the following methods to print logs in the node:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'ink_log::info!(target: "flipper-contract", "latest value is: {}", self.value);\n')))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"runtime_log"),": In the ",(0,i.kt)("inlineCode",{parentName:"p"},"ink-log/runtime")," directory, this library is based on the contents of the ",(0,i.kt)("inlineCode",{parentName:"p"},"function_id")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"LoggerExt")," structures passed from ",(0,i.kt)("inlineCode",{parentName:"p"},"ChainExtensions")," to call the corresponding logs under ",(0,i.kt)("inlineCode",{parentName:"p"},"debug")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"frame_support")," to print. It is an implementation library of ",(0,i.kt)("inlineCode",{parentName:"p"},"ink_log")," prepared for developers of the chain. **For example, chain developers can use it in their own ",(0,i.kt)("inlineCode",{parentName:"p"},"ChainExtensions"),":"),(0,i.kt)("p",null,"   In ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),"\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'[dependencies]\nruntime_log = { version = "0.1", git = "https://github.com/patractlabs/ink-log", default-features = false }\n\n[features]\ndefault = ["std"]\nstd = [\n    # ...\n    "runtime_log/std"\n]\n')),(0,i.kt)("p",null,"   In ",(0,i.kt)("inlineCode",{parentName:"p"},"ChainExtensions"),"'s implementation\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct CustomExt;\nimpl ChainExtension for CustomExt {\n    fn call<E: Ext>(func_id: u32, env: Environment<E, InitState>) -> Result<RetVal, DispatchError>\n    where\n        <E::T as SysConfig>::AccountId: UncheckedFrom<<E::T as SysConfig>::Hash> + AsRef<[u8]>,\n    {\n        match func_id {\n            ... => {/* other ChainExtension */ }\n            0xfeffff00 => {\n                // TODO add other libs\n                runtime_log::logger_ext!(func_id, env);\n                // or use\n                // LoggerExt::call::<E>(func_id, env)\n                Ok(RetVal::Converging(0))\n            }\n        }   \n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"ink_log")," corresponds to ",(0,i.kt)("inlineCode",{parentName:"strong"},"runtime_log"),", so if contract developers need to use ",(0,i.kt)("inlineCode",{parentName:"strong"},"ink_log"),", they need to pay attention to the chain corresponding to the debugging contract that needs to implement ",(0,i.kt)("inlineCode",{parentName:"strong"},"runtime_log"),". ")),(0,i.kt)("p",null,"On the other hand, after contract developers introduce ",(0,i.kt)("inlineCode",{parentName:"p"},"ink_log"),", they need to pay attention to ",(0,i.kt)("inlineCode",{parentName:"p"},'features = ["ink-log-chain-extensions"]'),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ink_log")," will call ",(0,i.kt)("inlineCode",{parentName:"p"},"seal_chain_extensions")," to interact with the chain only when this feature is enabled. Without this feature, ",(0,i.kt)("inlineCode",{parentName:"p"},"noop")," will be used to skip the process of contract printing."),(0,i.kt)("p",null,"Therefore, contract developers can control the contract to print logs in the debugging environment and the production environment through features. The contract compiled in the debugging environment opens the ",(0,i.kt)("inlineCode",{parentName:"p"},'"ink-log-chain-extensions"')," feature, and the contract compiled in the production environment removes this feature."),(0,i.kt)("h2",{id:"2-what-europa-can-do-in-v02"},"2. What Europa can do in v0.2"),(0,i.kt)("h3",{id:"21-build"},"2.1 Build"),(0,i.kt)("p",null,"For contract developers, it is necessary to prepare ",(0,i.kt)("inlineCode",{parentName:"p"},"Europa")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract")," tools."),(0,i.kt)("h4",{id:"211-europa"},"2.1.1 Europa"),(0,i.kt)("p",null,"The building process for this project is as same as ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/"},"Substrate"),"."),(0,i.kt)("p",null,"When building finished, current executable file in ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," directory is named ",(0,i.kt)("inlineCode",{parentName:"p"},"Europa"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"git clone --recurse-submodules https://github.com/patractlabs/Europa.git\n")),(0,i.kt)("h4",{id:"212-cargo-contract"},"2.1.2 cargo-contract"),(0,i.kt)("p",null,"If you want to see the backtrace executed by Wasm during the operation of Europa, you must use the ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract")," version we provide. Because the current paritytech repo ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/cargo-contract"},"cargo-contract"),' uses the highest optimization level when compiling the contract, and discards the "name section" part in Wasm. As mentioned above, if you need to print the call stack information in the wasmi execution contract, the contract file must have the "name section" part, so the use of the ',(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract"),' provided by paritytech cannot meet the requirements. We completed this function in our forked repo. On the other hand, we think that the function of "name section" in Wasm may not only be needed by Europa, so we submitted ',(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/cargo-contract/pull/131"},"pr#131[Enable debug info to the source warehouse with flag in command build]")," provides this feature."),(0,i.kt)("p",null,"Before this PR is merged, currently only the ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract")," version provided by us (Patract Labs) can be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo install --git https://github.com/patractlabs/cargo-contract --branch cmd/debug --force\n")),(0,i.kt)("p",null,"If you do not want this version of ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract")," to override the version released by paritytech, then it is recommended to compile locally and use the compiled ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract")," directly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/patractlabs/cargo-contract --branch cmd/debug\ncd cargo-contract\ncargo build --release\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: Executing the ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract build")," command requires the ",(0,i.kt)("inlineCode",{parentName:"p"},"default toolchain")," of the rust tool-chain to be ",(0,i.kt)("inlineCode",{parentName:"p"},"nightly"),", otherwise you can only use ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo +nightly contract build"),", but using ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo")," to call ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract")," needs to be executed ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo install")," installs or overwrites the compiled product in the ",(0,i.kt)("inlineCode",{parentName:"p"},"~/.cargo/bin")," directory, and cannot co-exist with paritytech's ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract"))),(0,i.kt)("p",null,"Execute:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo-contract build --help\n# or\ncargo +nightly contract build --help\n")),(0,i.kt)("p",null,"If you can see:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"FLAGS:\n    -d, --debug      \n            Emits debug info into wasm file\n")),(0,i.kt)("p",null,"It means that you are using the ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo-contract")," provided by Patract Labs. If you want to see the backtrace of the Wasm contract execution crash while using Europa, you need to add the ",(0,i.kt)("inlineCode",{parentName:"p"},"--debug")," command when compiling the contract."),(0,i.kt)("p",null,"Using the ",(0,i.kt)("inlineCode",{parentName:"p"},"--debug")," command will generate another file besides the normal file in the ",(0,i.kt)("inlineCode",{parentName:"p"},"target/ink")," directory of the originally compiled contract, ending with ",(0,i.kt)("inlineCode",{parentName:"p"},"*.src.wasm"),". This ",(0,i.kt)("inlineCode",{parentName:"p"},"*.src.wasm"),' file is the Wasm contract file containing the "name section" part.'),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"If you need to use Europa for testing, the contract deployed to Europa needs to use this ",(0,i.kt)("inlineCode",{parentName:"strong"},"*.src.wasm")," file instead of the originally generated ",(0,i.kt)("inlineCode",{parentName:"strong"},"*.wasm")," file. ")),(0,i.kt)("h3",{id:"example"},"example"),(0,i.kt)("p",null,"We can use one simple case and other cases we have encountered to verify the reliability of Europa's positioning problems."),(0,i.kt)("p",null,"In the following context, the methods of starting Europa are all used by:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ Europa --tmp -lruntime=debug\n")),(0,i.kt)("p",null,"Every time Europa is started in this way, new data is created. If you want to keep Europa's execution data, please refer to Europa's ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/europa"},"README")," or Europa v0.1's ","[Report]","(",(0,i.kt)("a",{parentName:"p",href:"https://polkadot.polkassembly.io/post/"},"https://polkadot.polkassembly.io/post/")," 166), you can get more command introduction."),(0,i.kt)("h4",{id:"case-1\uff1asimple-case"},"Case 1\uff1aSimple case"),(0,i.kt)("p",null,"For example, we modify the example contract ",(0,i.kt)("inlineCode",{parentName:"p"},"ink/example/erc20")," in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink"},"ink!")," project as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[ink(message)]\npub fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()> {\n    let from = self.env().caller();\n    self.transfer_from_to(from, to, value)?;\n    panic!("123");\n    Ok(())\n}\n')),(0,i.kt)("p",null,"Wasm, it corresponds to the code after the macro expansion of the original file, so if you want to compare the errors of the call stack, you need to expand the macro of the original contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo install expand\ncd ink/example/erc20\ncargo expand > tmp.rs\n")),(0,i.kt)("p",null,"After reading the ",(0,i.kt)("inlineCode",{parentName:"p"},"tmp.rs")," file, we can know that Wasm needs to go through when it executes the ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"fn call() -> u32 \n-> <Erc20 as ::ink_lang::DispatchUsingMode>::dispatch_using_mode(...)\n-> <<Erc20 as ::ink_lang::ConstructorDispatcher>::Type as ::ink_lang::Execute>::execute(..)  # compile selector at here\n-> ::ink_lang::execute_message_mut\n-> move |state: &mut Erc20| { ... } # a closure\n-> <__ink_Msg<[(); 2644567034usize]> as ::ink_lang::MessageMut>::CALLABLE\n-> transfer\n")),(0,i.kt)("p",null,"Therefore, if the ",(0,i.kt)("inlineCode",{parentName:"p"},"panic")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," is encountered during the contract call, the backtrace of Wasm should be similar to this."),(0,i.kt)("p",null,"First we start Europa:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ Europa --tmp -lruntime=debug\n")),(0,i.kt)("p",null,"Then we deploy this erc20 and call transfer to execute."),(0,i.kt)("p",null,"We can use ",(0,i.kt)("a",{parentName:"p",href:"https://polkadot.js.org/apps"},(0,i.kt)("inlineCode",{parentName:"a"},"Polkadot/Substrate Portal"))," or use ",(0,i.kt)("a",{parentName:"p",href:"https://redspot.patract.io/en/tutorial/"},"RedSpot")," to verify this process. Suppose we use ",(0,i.kt)("inlineCode",{parentName:"p"},"RedSpot")," to execute a ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," call of this wrong ERC20 contract. Please note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"--debug")," subcommand must be added in the process of compiling the contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ npx redspot-new erc20\n$ cd erc20/contracts\n# add panic in `transfer` function as abrove\n$ vim lib.rs \n# notice must add --debug when compile contract\n# due current cargo-contract is not paritytech, we need to copy compile product into `artifacts` directory. RedSpot would support Europa and PatractLabs's cargo-contract in next version.\n$ cargo +nightly contract build --debug \n$ mkdir ../artifacts\n# notice must cp erc20.src.wasm, not erc20.wasm\n$ cp ./target/ink/erc20.src.wasm ../artifacts  \n# notice must rename metadata.json to erc20.json\n$ cp ./target/ink/metadata.json ../artifacts/erc20.json \n$ cd ../\n# enter redspot console, use `--no-compile` to deny recompile contract\n$ npx redspot console --no-compile  \n# in redspot console\nWelcome to Node.js v12.16.1.Type \".help\" for more information.\n> \n> var factory = await patract.getContractFactory('erc20')\n# do following command could deploy the erc20 contract\n> var contract = await factory.deployed('new', '1000000', {value: 20000000000, salt:1})\n# do a transfer call directly\n> await contract.transfer(\"5GcTYx4dPTQfi4udKPvE4VKmbooV7zY6hNYVF9JXHJL4knNF\", 100)\n")),(0,i.kt)("p",null,"Then in Europa's log, you can see:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'1: NestedRuntime {\n    ext_result: [failed] ExecError { error: DispatchError::Module {index:5, error:17, message: Some("ContractTrapped"), orign: ErrorOrigin::Caller }}\n    caller: d43593c715fdd31c61141abd04a99fd6822...(5GrwvaEF...),\n    self_account: b6484f58b7b939e93fff7dc10a654af7e.... (5GBi41bY...),\n    selector: 0xfae3a09d,\n    args: 0x1cbd2d43530a44705ad088af313e18f80b5....,\n    value: 0,\n    gas_limit: 409568000000,\n    gas_left: 369902872067,\n    env_trace: [\n        seal_value_transferred(Some(0x00000000000000000000000000000000)),\n        seal_input(Some(0xfae3a09d1cbd.....)),\n        seal_get_storage((Some(0x0100000000000....), Some(0x010000000100000001000000))),\n        # ...\n        seal_caller(Some(0xd43593c715fdd31c61141abd...)),\n        seal_hash_blake256((Some(0x696e6b20686173....), Some(0x0873b31b7a3cf....))),\n        # ...  \n        seal_deposit_event((Some([0x45726332303a....00000000000]), Some(0x000..))),\n    ],\n    trap_reason: TrapReason::SupervisorError(DispatchError::Module { index: 5, error: 17, message: Some("ContractTrapped") }),\n    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Unreachable }))\n        wasm backtrace: \n        |  core::panicking::panic[28]\n        |  erc20::erc20::_::<impl erc20::erc20::Erc20>::transfer[1697]\n        |  <erc20::erc20::_::__ink_Msg<[(); 2644567034]> as ink_lang::traits::MessageMut>::CALLABLE::{{closure}}[611]\n        |  core::ops::function::FnOnce::call_once[610]\n        |  <erc20::erc20::_::_::__ink_MessageDispatchEnum as ink_lang::dispatcher::Execute>::execute::{{closure}}[1675]\n        |  ink_lang::dispatcher::execute_message_mut[1674]\n        |  <erc20::erc20::_::_::__ink_MessageDispatchEnum as ink_lang::dispatcher::Execute>::execute[1692]\n        |  erc20::erc20::_::<impl ink_lang::contract::DispatchUsingMode for erc20::erc20::Erc20>::dispatch_using_mode[1690]\n        |  call[1691]\n        \u2570\u2500><unknown>[2387]\n    ,\n    nest: [],\n}\n')),(0,i.kt)("p",null,"Let us explain the information printed above:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ext_result"),": indicates that this contract call is displayed as successful or failed:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"[success]"),": indicates the successful execution of this contract (Note: the successful execution of the contract does not mean the successful execution of the business logic of the contract itself. There may be an error return in ",(0,i.kt)("inlineCode",{parentName:"li"},"ink!")," or the business logic of the contract itself, as in case 3 in the following text.) And the ",(0,i.kt)("inlineCode",{parentName:"li"},"ExecResultValue {flag:0, data: 0x...}")," followed by ",(0,i.kt)("inlineCode",{parentName:"li"},"[success]")," indicates the return value after this contract is executed."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"[failed]"),": indicates that the execution of this contract failed, and the ",(0,i.kt)("inlineCode",{parentName:"li"},"ExecError {.. }")," followed by ",(0,i.kt)("inlineCode",{parentName:"li"},"[failed]")," indicates the cause of this error. The reason for this is the value recorded in ",(0,i.kt)("inlineCode",{parentName:"li"},"event")," on the chain, which is the value defined in ",(0,i.kt)("inlineCode",{parentName:"li"},"decl_error!")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"Pallet Contracts"),"."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"1: NestedRuntime "),"&",(0,i.kt)("inlineCode",{parentName:"p"},"nest"),": The contract information that represents the current print information is located in the first layer of the contract call stack. If the current contract calls another contract, it will appear in the array of the ",(0,i.kt)("inlineCode",{parentName:"p"},"nest")," field. ",(0,i.kt)("inlineCode",{parentName:"p"},"2: NestedRuntime")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"1: NestedRuntime")," has the same structure. Among them, ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," indicates that the called contract is in the second layer of the contract call stack. If several contracts are called across contracts in the current contract, there will be several ",(0,i.kt)("inlineCode",{parentName:"p"},"NestedRuntime")," in the array of ",(0,i.kt)("inlineCode",{parentName:"p"},"nest"),". If there are other contract calls in the second-level contract, the same goes for."),(0,i.kt)("p",{parentName:"li"},"For example, if there are contracts A, B, C, if it is the following situation:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"After A calls B, it returns to A to continue execution, and then calls contract C"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-text"},"|A|\n| |->|B|\n| |<-\n| |->|C|\n| |<-\n")),(0,i.kt)("p",{parentName:"li"},"Then it will produce a log print similar to the following:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-text"},"1: NestedRuntime {\n self_account: A,\n nest:[\n     2: NestedRuntime {\n         self_account: B,\n         nest:[],\n     },\n     2: NestedRuntime {\n         self_account: C,\n         nest:[],\n     }\n ]\n}\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"After A calls B, B calls contract C again, and finally returns to A"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-text"},"|A|\n| |->|B|\n| |  | |->|C|\n| |  | |<-\n| |<-\n")),(0,i.kt)("p",{parentName:"li"},"Then it will produce a log print similar to the following:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-text"},"1: NestedRuntime {\n self_account: A,\n nest:[\n     2: NestedRuntime {\n         self_account: B,\n         nest:[\n            3: NestedRuntime {\n                self_account: C,\n                nest:[],\n            }\n         ],\n     }  \n ]\n}\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"caller"),": who is the caller of the current contract. If the contract calls the contract, the value of the called contract is the address of the upper-level contract.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"self_account"),": represents the address of the current contract itself.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"selector")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"args"),"&",(0,i.kt)("inlineCode",{parentName:"p"},"value"),": Represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"selector")," and parameters passed in when calling the current contract. ",(0,i.kt)("strong",{parentName:"p"},"These information can quickly locate whether the calling contract method is correct"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_left"),": Represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit")," passed in when the contract is currently called and the remaining gas after ",(0,i.kt)("strong",{parentName:"p"},"executing this layer"),". Note here that ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_left")," refers to the remaining gas after the execution of this layer of contract, so In the contract call contract, the gas consumed by each layer of contract can be determined through ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_left"),", not only get the consumption after the execution of the entire contract.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"env_trace"),": Indicates that during the execution of the current layer of the contract, each time host_function is called in the contract Wasm execution, a record will be added to the list here. Because all host_functions and the definitions in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/blob/master/frame/contracts/src/wasm/runtime.rs#L610"},(0,i.kt)("inlineCode",{parentName:"a"},"define_env!")," in the ",(0,i.kt)("inlineCode",{parentName:"a"},"Pallet Contracts")," module")," are related, so tracing ",(0,i.kt)("inlineCode",{parentName:"p"},"env_trace")," can trace the process of interacting with ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," during the execution of the current Wasm contract. "),(0,i.kt)("p",{parentName:"li"},"For example, if following thing appears in ",(0,i.kt)("inlineCode",{parentName:"p"},"env_trace"),":"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"seal_call"),": It means that there is a contract call contract situation in the current contract. According to the order in which ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_call")," appears in ",(0,i.kt)("inlineCode",{parentName:"li"},"env_trace"),", it can correspond to ",(0,i.kt)("inlineCode",{parentName:"li"},"nest")," to calculate the state before and after the contract calls the contract."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"seal_get_storage"),"&",(0,i.kt)("inlineCode",{parentName:"li"},"seal_set_storage"),": It means that data read and write occurred in the contract. Through these two interfaces, it is possible to intercept and count the data read and write during the execution of the current contract, and the data size calculated by ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"seal_set_storage")," can also be used to infer the storage size required by ",(0,i.kt)("inlineCode",{parentName:"strong"},"rent"),". ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"seal_deposit_event"),": indicates that the event is printed in the contract. Here you can intercept the content of each event separately, instead of getting a unified event at the end. And the following text will use an example to surface that Europa can quickly locate the bug in the ",(0,i.kt)("inlineCode",{parentName:"li"},"host_function"),".")),(0,i.kt)("p",{parentName:"li"},"On the other hand, the statistics of ",(0,i.kt)("inlineCode",{parentName:"p"},"env_trace")," are relatively ",(0,i.kt)("strong",{parentName:"p"},"fine-grained"),". For example, if there are multiple possible errors in ",(0,i.kt)("inlineCode",{parentName:"p"},"host_function"),", when an error occurs, all the information before the error will be retained, so it can be located to the place where the problem occurred during the execution of ",(0,i.kt)("inlineCode",{parentName:"p"},"host_function"),"."),(0,i.kt)("p",{parentName:"li"},"And if there is an error in ",(0,i.kt)("inlineCode",{parentName:"p"},"host_function")," that causes the contract to end execution, ",(0,i.kt)("inlineCode",{parentName:"p"},"env_trace")," records the last error ",(0,i.kt)("inlineCode",{parentName:"p"},"host_function")," call, so you can directly locate which ",(0,i.kt)("inlineCode",{parentName:"p"},"host_function")," caused the contract execution exception.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"trap_reason"),": According to the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"TrapReason")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"trap_reason")," can be divided into 2 categories:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Return")," & ",(0,i.kt)("inlineCode",{parentName:"li"},"Termination")," & ",(0,i.kt)("inlineCode",{parentName:"li"},"Restoration"),": indicates that the contract exit is the design of ",(0,i.kt)("inlineCode",{parentName:"li"},"Pallet Contracts"),", not an internal error. This type of trap indicates that the contract is executed normally and is not an error."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"SupervisorError"),": Indicates that an error occurred during the execution of the contract calling host_function.")),(0,i.kt)("p",{parentName:"li"},"Therefore, the current Europa log printing design is designed to record whenever ",(0,i.kt)("inlineCode",{parentName:"p"},"trap_reason")," appears. On the other hand, ",(0,i.kt)("inlineCode",{parentName:"p"},"trap_reason")," may not always appear during the execution of the contract. Combining the design of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!"),", there is a case where the successful execution of the contract or the execution failure in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," layer does not generate ",(0,i.kt)("inlineCode",{parentName:"p"},"trap_reason"),". Therefore, in addition to recording ",(0,i.kt)("inlineCode",{parentName:"p"},"trap_reason"),", Europa also ",(0,i.kt)("strong",{parentName:"p"},"records the results returned by the Wasm executor after execution, which is recorded with ",(0,i.kt)("inlineCode",{parentName:"strong"},"sandbox_result_ok"),". ")))),(0,i.kt)("ol",{start:9},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"sandbox_result_ok"),": The value of ",(0,i.kt)("inlineCode",{parentName:"p"},"sandbox_result_ok")," represents the result of the contract after the Wasm executor is executed. This value could have been recorded as ",(0,i.kt)("inlineCode",{parentName:"p"},"sandbox_result"),", including correct and incorrect conditions. However, due to the limitations of Rust and combined with the business logic of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts"),", only the result of ",(0,i.kt)("inlineCode",{parentName:"p"},"sandbox_result")," is kept as ",(0,i.kt)("inlineCode",{parentName:"p"},"Ok")," here. ",(0,i.kt)("strong",{parentName:"p"},"For log printing, Europa is designed to print ",(0,i.kt)("inlineCode",{parentName:"strong"},"sandbox_result_ok")," only when trap_reason is the first case, as information to assist in judging contract execution. ")),(0,i.kt)("p",{parentName:"li"}," ",(0,i.kt)("inlineCode",{parentName:"p"},"sandbox_result_ok")," is the Wasm executor ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/blob/712085115cdef4a79a66747338c920d6ba4e479f/frame/contracts/src/wasm/mod.rs#L155-L156"},"result after calling ",(0,i.kt)("inlineCode",{parentName:"a"},"invoke"))," After the processing of ",(0,i.kt)("inlineCode",{parentName:"p"},"to_execution_result"),", if there is no ",(0,i.kt)("inlineCode",{parentName:"p"},"trap_reason"),", the result of ",(0,i.kt)("inlineCode",{parentName:"p"},"Ok(..)")," is ","[discarded]","(",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/blob/712085115cdef4a79a66747338c920d6ba4e479f"},"https://github.com/paritytech/substrate/blob/712085115cdef4a79a66747338c920d6ba4e479f")," /frame/contracts/src/wasm/runtime.rs#L366-L368). But in fact there are two situations here:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"An error occurred in ",(0,i.kt)("inlineCode",{parentName:"li"},"ink!"),": According to the implementation of ",(0,i.kt)("inlineCode",{parentName:"li"},"ink!"),", before calling the functions wrapped by the contract ",(0,i.kt)("inlineCode",{parentName:"li"},"#[ink(message)]")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"#[ink(constructor)]"),", the input The process of decoding and matching ",(0,i.kt)("inlineCode",{parentName:"li"},"selector"),". If an error occurs during this process, the contract will return ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/paritytech/ink/blob/abd5cf14c0883cb2d5acf81f2277aeec330aa843/crates/lang/src/error.rs#L22"},"error code ",(0,i.kt)("inlineCode",{parentName:"a"},"DispatchError")),". But for the Wasm executor, the Wasm code is executed normally, so the result will be returned, including this error code. ",(0,i.kt)("strong",{parentName:"li"},"This contract execution process is an error situation. ")),(0,i.kt)("li",{parentName:"ol"},"The return value of ",(0,i.kt)("inlineCode",{parentName:"li"},"#[ink(message)]")," is defined as ",(0,i.kt)("inlineCode",{parentName:"li"},"()"),": According to the implementation of ",(0,i.kt)("inlineCode",{parentName:"li"},"ink!"),", if the return value type is ",(0,i.kt)("inlineCode",{parentName:"li"},"()"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_reason")," will not be called, so it will not Contains ",(0,i.kt)("inlineCode",{parentName:"li"},"trap_reason"),". ",(0,i.kt)("strong",{parentName:"li"},"This contract execution process is an correct situation. "))),(0,i.kt)("p",{parentName:"li"},"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," is only a contract implementation that runs on ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts"),", other implementations may have different rules, so currently ",(0,i.kt)("inlineCode",{parentName:"p"},"sandbox_result_ok")," is only used to assist in determining the execution of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," contract, the value is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/blob/712085115cdef4a79a66747338c920d6ba4e479f/primitives/wasm-interface/src/lib.rs#L462-L467"},(0,i.kt)("inlineCode",{parentName:"a"}," ReturnValue")),". Among them, if the ",(0,i.kt)("inlineCode",{parentName:"p"},"<num>")," part of ",(0,i.kt)("inlineCode",{parentName:"p"},"ReturnValue::Value(<num>)")," of the log is not 0, it means that there may be an error in the execution of ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!"),". You can use ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," for ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/blob/abd5cf14c0883cb2d5acf81f2277aeec330aa843/crates/lang/src/error.rs#L66-L80"},(0,i.kt)("inlineCode",{parentName:"a"},"DispatchError")," The error code")," determines the error.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"wasm_error"),": indicates the backtrace when Wasm executes an error. This part will be printed only when ",(0,i.kt)("inlineCode",{parentName:"p"},"ext_result")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"failed"),"."),(0,i.kt)("p",{parentName:"li"}," In the above example, because the execution of ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," will trigger ",(0,i.kt)("inlineCode",{parentName:"p"},"panic"),", you can see that the cause of the error here is ",(0,i.kt)("inlineCode",{parentName:"p"},"WasmiExecution(Trap(Trap {kind: Unreachable }))"),", indicating that this time the failure is due to execution The situation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Unreacble")," in the contract process is caused, and the backtrace information below also ",(0,i.kt)("strong",{parentName:"p"},"very accurately describes")," the function execution call stack when an error is encountered after the expansion of the contract macro discussed above. The following calling process can be clearly found from the backtrace."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-text"},"call -> dispatch_using_mode -> ... -> transfer -> panic \n")),(0,i.kt)("p",{parentName:"li"},"This process is consistent with the original information of the contract."))),(0,i.kt)("h4",{id:"case-2\uff1acontracttrap-caused-by-locating-duplicate-topics"},"Case 2\uff1a",(0,i.kt)("inlineCode",{parentName:"h4"},"ContractTrap")," caused by locating duplicate topics"),(0,i.kt)("p",null,"Some time ago, we (Patract Labs) reported a bug to ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!"),", see issue:",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/589"},"\"When set '0' value in contracts event, may cause ",(0,i.kt)("inlineCode",{parentName:"a"},"Error::ContractTrapped"),' and panic in contract #589" '),". It is very difficult to locate this error before Europa has developed the relevant function. Thank you @athei ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/589#issuecomment-731571918"},"located the error"),". Here we reproduce this error and use Europa's log to quickly analyze and locate the place where the bug appears:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"checkout ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," to commit ",(0,i.kt)("inlineCode",{parentName:"p"},"8e8fe09565ca6d2fad7701d68ff13f12deda7eed")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cd ink\ngit checkout 8e8fe09565ca6d2fad7701d68ff13f12deda7eed -b tmp\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Go in ",(0,i.kt)("inlineCode",{parentName:"p"},"ink/examples/erc20/lib.rs:L90")," to change ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"0_u128")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(constructor)]\npub fn new(initial_supply: Balance) -> Self {\n    //...\n    Self::env().emit_event(Transfer {\n        from: None,\n        to: Some(caller),\n        // change this from `initial_supply` to `0_u128`\n        value: 0_u128.into() // initial_supply,\n    });\n    instance\n}\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Execute ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo +nightly contract build --debug")," to compile the contract")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Use ",(0,i.kt)("a",{parentName:"p",href:"https://redspot.patract.io/en/tutorial/"},"RedSpot")," or ",(0,i.kt)("a",{parentName:"p",href:"https://polkadot.js.org/apps"},(0,i.kt)("inlineCode",{parentName:"a"},"Polkadot/Substrate Portal"))," to deploy this contract ( Note that you must use the erc20.src.wasm file)"))),(0,i.kt)("p",null,"You should encounter ",(0,i.kt)("inlineCode",{parentName:"p"},"DuplicateTopics")," in the deployment phase (before this ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/pull/7762"},"bug")," is corrected, the reported error is ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractTrap"),"), and in the Europa log Will show:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'1: NestedRuntime {\n    #...\n    env_trace: [\n        seal_input(Some(0xd183512b0)),\n        #...    \n        seal_deposit_event((Some([0x45726332303a3a5472616e736....]), None)),\n    ],\n    trap_reason: TrapReason::SupervisorError(DispatchError::Module { index: 5, error: 23, message: Some("DuplicateTopics") }),\n    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Host(DummyHostError) }))\n        wasm backtrace: \n        |  ink_env::engine::on_chain::ext::deposit_event[1623]\n        |  ink_env::engine::on_chain::impls::<impl ink_env::backend::TypedEnvBackend for ink_env::engine::on_chain::EnvInstance>::emit_event[1564]\n        |  ink_env::api::emit_event::{{closure}}[1563]\n        |  <ink_env::engine::on_chain::EnvInstance as ink_env::engine::OnInstance>::on_instance[1562]\n        |  ink_env::api::emit_event[1561]\n        |  erc20::erc20::_::<impl ink_lang::events::EmitEvent<erc20::erc20::Erc20> for ink_lang::env_access::EnvAccess<<erc20::erc20::Erc20 as ink_lang::env_access::ContractEnv>::Env>>::emit_event[1685]\n# ...\n# ...\n        |  deploy[1691]\n        \u2570\u2500><unknown>[2385]\n    ,\n    nest: [],\n}\n')),(0,i.kt)("p",null,"You can see from the above log:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The last record of ",(0,i.kt)("inlineCode",{parentName:"li"},"env_trace")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_deposit_event")," instead of ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_return")," (when the contract is executed correctly, the last record must be ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_return"),")"),(0,i.kt)("li",{parentName:"ol"},"The second parameter of ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_deposit_event")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," instead of an existing value, which indicates that the host_function of ",(0,i.kt)("inlineCode",{parentName:"li"},"seal_deposit_event")," has not been executed, but an error occurred during the execution (see the forked dependency of Europa) See the ","[corresponding implementation]"," (",(0,i.kt)("a",{parentName:"li",href:"https://github.com/patractlabs/substrate/blob/3624deb47cabe6f6cd44ec2c49c6ae5a29fd2198/frame/contracts/src/wasm/runtime.rs#L1399"},"https://github.com/patractlabs/substrate/blob/3624deb47cabe6f6cd44ec2c49c6ae5a29fd2198/frame/contracts/src/wasm/runtime.rs#L1399"),") for the source code of the version of ",(0,i.kt)("inlineCode",{parentName:"li"},"Pallet Contracts"),"."),(0,i.kt)("li",{parentName:"ol"},"Combined with the error stack of wasm backtrace, we can intuitively see that the top call stack of backtrace is ",(0,i.kt)("inlineCode",{parentName:"li"},"deposit_event"),".")),(0,i.kt)("p",null,"Therefore, combining the above information, we can directly infer that the host_function of ",(0,i.kt)("inlineCode",{parentName:"p"},"seal_deposit_event")," has an exception during the execution. (Before the submission of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts"),(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/pull/7762"},"pull#7762"),", we recorded the error message in host_function. After the merge, we used ",(0,i.kt)("inlineCode",{parentName:"p"},"trap_reason")," unified error message.)"),(0,i.kt)("h4",{id:"case-3-when-error-is-caused-by-the-chain-using-type-balanceu64-instead-of-type-balanceu128"},"Case 3: When error is caused by the chain using ",(0,i.kt)("inlineCode",{parentName:"h4"},"type Balance=u64")," instead of ",(0,i.kt)("inlineCode",{parentName:"h4"},"type Balance=u128")),(0,i.kt)("p",null,"If the chain uses the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"Balance=u64"),", and the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"Balance")," in the chain is unknown to ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," (the default definition of Balance is ",(0,i.kt)("inlineCode",{parentName:"p"},"u128"),"). Therefore, when using ",(0,i.kt)("inlineCode",{parentName:"p"},"u128")," to define ",(0,i.kt)("inlineCode",{parentName:"p"},"Balance"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," as a dependency compiled contract, when running on a chain where ",(0,i.kt)("inlineCode",{parentName:"p"},"Balance")," is defined as ",(0,i.kt)("inlineCode",{parentName:"p"},"u64"),", it will cause the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pallet Contracts")," module to transfer values to the contract , The contract internally regards the ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"u64")," as a decoding error of ",(0,i.kt)("inlineCode",{parentName:"p"},"u128"),"."),(0,i.kt)("p",null,"Take the example contract of erc20 as an example, after expanding the macro of the contract, you can see:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When there is an error in the ",(0,i.kt)("inlineCode",{parentName:"li"},"dispatch_using_mode")," stage of decoding ",(0,i.kt)("inlineCode",{parentName:"li"},"input"),", the contract returns with ",(0,i.kt)("inlineCode",{parentName:"li"},"::ink_lang::DispatchError::CouldNotReadInput"),", but the model design of ",(0,i.kt)("inlineCode",{parentName:"li"},"Pallet Contracts")," believes that the Wasm contract execution is not abnormal."),(0,i.kt)("li",{parentName:"ul"},"In the call of ",(0,i.kt)("inlineCode",{parentName:"li"},"call"),", since ",(0,i.kt)("inlineCode",{parentName:"li"},"deny_payment")," is checked before calling ",(0,i.kt)("inlineCode",{parentName:"li"},"dispatch_using_mode"),", and if an Error is returned when checking ",(0,i.kt)("inlineCode",{parentName:"li"},"deny_payment"),", it will be directly ",(0,i.kt)("inlineCode",{parentName:"li"},"panic"),".")),(0,i.kt)("p",null,"Therefore, in this case, the contract for deploying (",(0,i.kt)("inlineCode",{parentName:"p"},"Instantiate"),") ERC20 will execute normally, and any method of ERC20 such as ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," will be called with ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractTrap"),"."),(0,i.kt)("p",null,"Let's look at these two situations separately:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"instantiate")," stage\uff1a"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'1: NestedRuntime {\n    ext_result: [success] ExecError { error: DispatchError::Module {index:5, error:17, message: Some("ContractTrapped"), orign: ErrorOrigin::Caller }}\n#...\n    env_trace: [\n        seal_input(Some(0xd183512b008cb6611e0100000000000000000000)),\n        seal_caller(Some(0xd43593c715fdd31c61141abd04a99fd682)),\n        //...\n        seal_set_storage((Some(0x030000000100000...), Some(0x000000000000000...))),\n    ],\n    sandbox_result_ok: RuntimeValue::Value(7),\n    nest: [],\n}\n')),(0,i.kt)("p",{parentName:"li"},"From the above log, we can see:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The end of ",(0,i.kt)("inlineCode",{parentName:"p"},"env_trace")," does not end with ",(0,i.kt)("inlineCode",{parentName:"p"},"seal_return"),", it means that the contract has not been executed normally. Because it can be seen from the design of ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," that if you enter ",(0,i.kt)("inlineCode",{parentName:"p"},"#[ink(constructor)]")," normally or enter ",(0,i.kt)("inlineCode",{parentName:"p"},"#[ink(message)]"),", then must be executed to ",(0,i.kt)("inlineCode",{parentName:"p"},"::ink_lang::execute_message ")," (",(0,i.kt)("inlineCode",{parentName:"p"},"::ink_lang::execute_message")," will call ",(0,i.kt)("inlineCode",{parentName:"p"},"seal_return"),"), and the absence of ",(0,i.kt)("inlineCode",{parentName:"p"},"seal_return")," means that the execution has not reached the stage of ",(0,i.kt)("inlineCode",{parentName:"p"},"execute"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"sandbox_result_ok")," indicates that the return value of the execution is ",(0,i.kt)("inlineCode",{parentName:"p"},"7"),". By querying ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," for the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"DispatchError"),", you can see that this error code represents ",(0,i.kt)("inlineCode",{parentName:"p"},"CouldNotReadInput")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"DispatchError::CouldNotReadInput => Self(0x07),\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"According to the expanded code of the contract macro, you can see that in the ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch_using_mode")," function, ",(0,i.kt)("inlineCode",{parentName:"p"},"::ink_env::decode_input")," is called before calling ",(0,i.kt)("inlineCode",{parentName:"p"},"execute"),", and this function has a ",(0,i.kt)("inlineCode",{parentName:"p"},"return Error")," situation. Therefore, it is reasonable to guess that an exception occurred when parsing ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),". The input parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"args:0x008cb6611e0100000000000000000000")," is recorded in the log. Observing this parameter, it can be found that its length is significantly smaller than the ",(0,i.kt)("inlineCode",{parentName:"p"},"u128")," code. Therefore, it can be inferred from ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"env_trace")," that an error occurred when decoding ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),"."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// this part code is expanded by erc20 example.\n::ink_env::decode_input::<<Erc20 as ::ink_lang::ConstructorDispatcher>::Type>().map_err(|_| ::ink_lang::DispatchError::CouldNotReadInput)?\n")))))),(0,i.kt)("p",null,"At this point, the contract instantiation is successful, but the constructor to execute the instantiation exists. Therefore, the contract exists on the chain but the process of ",(0,i.kt)("inlineCode",{parentName:"p"},"#[ink(constructor)]")," is not executed normally."),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"call")," stage, such as calling ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer"),":"),(0,i.kt)("p",{parentName:"li"}," Calling ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," to the above successfully instantiated function, ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractTrap")," will appear, Europa's log shows as follows:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'1: NestedRuntime {\n    ext_result: [failed] ExecError { error: DispatchError::Module {index:5, error:17, message: Some("ContractTrapped"), orign: ErrorOrigin::Caller }}\n# ...\n    env_trace: [\n        seal_value_transferred(Some(0x0000000000000000)),\n    ],\n    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Unreachable }))\n        wasm backtrace: \n        |  core::panicking::panic_fmt.60[1743]\n        |  core::result::unwrap_failed[914]\n        |  core::result::Result<T,E>::expect[915]\n        |  ink_lang::dispatcher::deny_payment[1664]\n        |  call[1691]\n        \u2570\u2500><unknown>[2387]\n    ,\n    nest: [],\n}\n')),(0,i.kt)("p",{parentName:"li"},"First notice that the last record of ",(0,i.kt)("inlineCode",{parentName:"p"},"env_trace")," is still not ",(0,i.kt)("inlineCode",{parentName:"p"},"seal_return"),", and the error cause of ",(0,i.kt)("inlineCode",{parentName:"p"},"wasm_error")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"WasmiExecution::Unreachable"),". Therefore, it can be determined that ",(0,i.kt)("inlineCode",{parentName:"p"},"panic")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"expect")," was encountered during the execution of the contract."),(0,i.kt)("p",{parentName:"li"}," From the wasm backtrace, it is very obvious that the execution process is"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"   call -> deny_payment -> expect\n")),(0,i.kt)("p",null,"According to the code expanded macro (",(0,i.kt)("inlineCode",{parentName:"p"},"cd ink/examples/erc20; cargo expand> tmp.rs"),"), we can see:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'#[no_mangle]\nfn call() -> u32 {\n    if true {\n     ::ink_lang::deny_payment::<<Erc20 as ::ink_lang::ContractEnv>::Env>()\n            .expect("caller transferred value even though all ink! message deny payments")\n    }\n    ::ink_lang::DispatchRetCode::from(\n        <Erc20 as ::ink_lang::DispatchUsingMode>::dispatch_using_mode(\n            ::ink_lang::DispatchMode::Call,\n        ),\n    )\n    .to_u32()\n}\n')),(0,i.kt)("p",null,"   Therefore, it can be judged that an error was returned in ",(0,i.kt)("inlineCode",{parentName:"p"},"deny_payment")," during the execution of the contract in the process of ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer"),", and the direct processing of the error as ",(0,i.kt)("inlineCode",{parentName:"p"},"expect")," resulted in the execution result of ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmi")," being ",(0,i.kt)("inlineCode",{parentName:"p"},"Unreachable")," Tracking the code of ",(0,i.kt)("inlineCode",{parentName:"p"},"deny_payment")," can find that the function returns ",(0,i.kt)("inlineCode",{parentName:"p"},"expect")," caused by ",(0,i.kt)("inlineCode",{parentName:"p"},"Error")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note\uff0cThe relevant code is as follows:"),(0,i.kt)("p",{parentName:"blockquote"},"In ",(0,i.kt)("inlineCode",{parentName:"p"},"ink_lang")," ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/blob/master/crates/lang/src/dispatcher.rs#L140-L150"},"https://github.com/paritytech/ink/blob/master/crates/lang/src/dispatcher.rs#L140-L150")),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn deny_payment<E>() -> Result<()>\nwhere\n    E: Environment,\n{\n    let transferred = ink_env::transferred_balance::<E>()\n        .expect("encountered error while querying transferred balance");\n    if transferred != <E as Environment>::Balance::from(0u32) {\n        return Err(DispatchError::PaidUnpayableMessage)\n    }\n    Ok(())\n}\n')),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"There will be a difference between the ",(0,i.kt)("inlineCode",{parentName:"strong"},"off_chain")," part and the ",(0,i.kt)("inlineCode",{parentName:"strong"},"on_chain")," part in the ink"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"off_chain")," will think that an error is returned at the stage of ",(0,i.kt)("inlineCode",{parentName:"p"},"ink_env::transferred_balance::<E>()"),", so it is executing",(0,i.kt)("inlineCode",{parentName:"p"}," After transferred_balance"),", you will encounter ",(0,i.kt)("inlineCode",{parentName:"p"},"expect")," which leads to ",(0,i.kt)("inlineCode",{parentName:"p"},"panic"),", and part of ",(0,i.kt)("inlineCode",{parentName:"p"},"on_chain")," is taken from the memory of wasm, it will normally get the characters corresponding to u128 length and decode to get ",(0,i.kt)("inlineCode",{parentName:"p"},"transferred"),", which is just decoded The result will not meet expectations, causing ",(0,i.kt)("inlineCode",{parentName:"p"},"transferred!=0")," to make ",(0,i.kt)("inlineCode",{parentName:"p"},"deny_payment")," return an Error, and the part where ",(0,i.kt)("inlineCode",{parentName:"p"},"deny_payment")," is called in the macro expansion of the contract triggers ",(0,i.kt)("inlineCode",{parentName:"p"},"expect")),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'if true {\n    ::ink_lang::deny_payment::<<Erc20 as ::ink_lang::ContractEnv>::Env>()\n        .expect("caller transferred value even though all ink! message deny payments")\n}\n')),(0,i.kt)("p",{parentName:"blockquote"},"Therefore, for wasm backtrace, ",(0,i.kt)("inlineCode",{parentName:"p"},"expect")," appears when ",(0,i.kt)("inlineCode",{parentName:"p"},"deny_payment")," is called in ",(0,i.kt)("inlineCode",{parentName:"p"},"call"),", not when ",(0,i.kt)("inlineCode",{parentName:"p"},"transferred_balance")," is called in ",(0,i.kt)("inlineCode",{parentName:"p"},"deny_payment"),"."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"This example side shows that ",(0,i.kt)("inlineCode",{parentName:"strong"},"ink!")," currently does not completely correspond to the processing of ",(0,i.kt)("inlineCode",{parentName:"strong"},"off_chain")," and ",(0,i.kt)("inlineCode",{parentName:"strong"},"on_chain"),", and may cause difficult-to-check errors for contract users in some cases")),(0,i.kt)("h2",{parentName:"blockquote",id:"verify-v02"},"Verify v0.2")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("del",{parentName:"p"},"Construct incorrect contracts and execute logs printing to determine whether it meets expectations"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("del",{parentName:"p"},"Display the call statistics of the ",(0,i.kt)("inlineCode",{parentName:"del"},"define_env!")," interface during contract execution")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"run test case ",(0,i.kt)("inlineCode",{parentName:"p"},"instantiate_return_code")," in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/substrate/blob/europa-contracts/frame/contracts/src/tests.rs"},"patractlabs/substrate branch:europa-contracts")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ cd europa/vendor/substrate/frame/contracts\n$ cargo test --package pallet-contracts --lib tests::instantiate_return_code -- --exact\n# then you could see\n1: NestedRuntime {\n    caller: 0101010101010101010101010101010101010101010101010101010101010101 (5C62Ck4U...),\n# ...\n}\n\n1: NestedRuntime {\n# ...\n}\n\n1: NestedRuntime {\n# ...\n}\n# ...\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"run test case ",(0,i.kt)("inlineCode",{parentName:"p"},"run_out_of_gas")," in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/substrate/blob/europa-contracts/frame/contracts/src/tests.rs"},"patractlabs/substrate branch:europa-contracts")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'$ cd europa/vendor/substrate/frame/contracts\n$ cargo test --package pallet-contracts --lib tests::run_out_of_gas -- --exact\n1: NestedRuntime {\n# ...\n}\n\n1: NestedRuntime {\n#...\n        gas(None),\n    ],\n    trap_reason: TrapReason::SupervisorError(DispatchError::Module { index: 0, error: 6, message: Some("OutOfGas") }),\n    nest: [],\n}\n')))),(0,i.kt)("p",{parentName:"li"},"Anyone can check whether the printed log matching with the test case.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("del",{parentName:"p"},"Execute the log printing function, provide formatted printing examples of different data, and judge whether it meets expectations")),(0,i.kt)("p",{parentName:"li"},"Using ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/ink-log"},(0,i.kt)("inlineCode",{parentName:"a"},"ink-log"))," in ",(0,i.kt)("inlineCode",{parentName:"p"},"ink!")," example could test this part.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("del",{parentName:"p"},"Construct a contract that crashes under different conditions and record the log after execution. Then judge whether the backtrace information of the contract execution is completely printed, and check whether it matches the actual execution of the collapsed contract.")),(0,i.kt)("p",{parentName:"li"},"We provide a test case repo ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/europa_contracts_test_templates"},"europa_contracts_test_templates"),". Any one could using Polkadot/Substrate Portal or RedSpot to deploy and call this test contract to verify this."))))}m.isMDXComponent=!0}}]);