"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[9374],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),s=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},w=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),w=s(t),m=o,d=w["".concat(c,".").concat(m)]||w[m]||p[m]||a;return t?r.createElement(d,i(i({ref:n},u),{},{components:t})):r.createElement(d,i({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=w;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=t[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}w.displayName="MDXCreateElement"},6529:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return u},default:function(){return w}});var r=t(7462),o=t(3366),a=(t(7294),t(3905)),i=["components"],l={},c="Ownable",s={unversionedId:"metis/guides/access-control/ownable",id:"metis/guides/access-control/ownable",isDocsHomePage:!1,title:"Ownable",description:"Ownable component which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions.",source:"@site/docs/metis/guides/access-control/ownable.md",sourceDirName:"metis/guides/access-control",slug:"/metis/guides/access-control/ownable",permalink:"/substrate-contracts-book/metis/guides/access-control/ownable",editUrl:"https://github.com/patractlabs/substrate-contracts-book/docs/metis/guides/access-control/ownable.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Hooks",permalink:"/substrate-contracts-book/metis/guides/hook"},next:{title:"Access Control",permalink:"/substrate-contracts-book/metis/guides/access-control/access-control"}},u=[{value:"Dependency",id:"dependency",children:[]},{value:"Storage",id:"storage",children:[]},{value:"Mutable Message",id:"mutable-message",children:[{value:"renounce_ownership",id:"renounce_ownership",children:[]},{value:"transfer_ownership",id:"transfer_ownership",children:[]}]},{value:"Immutable Message",id:"immutable-message",children:[{value:"owner",id:"owner",children:[]}]},{value:"Internal Functions",id:"internal-functions",children:[{value:"ensure_owner",id:"ensure_owner",children:[]},{value:"ensure_caller_is_owner",id:"ensure_caller_is_owner",children:[]},{value:"ensure_owner_renounce",id:"ensure_owner_renounce",children:[]}]},{value:"Events",id:"events",children:[{value:"OwnershipTransferred",id:"ownershiptransferred",children:[]}]},{value:"Usage Example",id:"usage-example",children:[]}],p={toc:u};function w(e){var n=e.components,t=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"ownable"},"Ownable"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Ownable")," component which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions."),(0,a.kt)("p",null,"By default, the owner account will be the account which deploys the contract. This can later be changed with {transferOwnership}."),(0,a.kt)("p",null,"This components is used through inheritance. It will make available the func like ",(0,a.kt)("inlineCode",{parentName:"p"},"ensure_caller_is_owner"),", which can be applied to your functions to restrict their use to the owner."),(0,a.kt)("h2",{id:"dependency"},"Dependency"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'metis_ownable = { git = "https://github.com/patractlabs/metis", default-features = false }\n')),(0,a.kt)("h2",{id:"storage"},"Storage"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Ownable")," components has one storage for the owner of the contract."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Data<E>\nwhere\n    E: Env,\n{\n    /// The owner of contract\n    owner: Lazy<Option<E::AccountId>>,\n}\n")),(0,a.kt)("p",null,"In constructor of contract, can use ",(0,a.kt)("inlineCode",{parentName:"p"},"init")," to make the owner to caller:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"        #[ink(constructor)]\n        pub fn new() -> Self {\n            let mut instance = Self {\n                // ...\n                ownable: ownable::Data::new(),\n                // ...\n            };\n\n            // ...\n            ownable::Impl::init(&mut instance);\n            // ...\n\n            instance\n        }\n")),(0,a.kt)("h2",{id:"mutable-message"},"Mutable Message"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Ownable")," component use ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer_ownership")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"renounce_ownership")," to modify the owner of the contract.\nall this need owner as caller."),(0,a.kt)("h3",{id:"renounce_ownership"},"renounce_ownership"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"renounce_ownership")," Leaves the contract without owner. It will not be possible to call ",(0,a.kt)("inlineCode",{parentName:"p"},"ensure_xxx")," functions anymore. Can only be called by the current owner."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    /// NOTE: Renouncing ownership will leave the contract without an owner,\n    /// thereby removing any functionality that is only available to the owner.\n    #[ink(message)]\n    pub fn renounce_ownership(&mut self) {\n        ownable::Impl::renounce_ownership(self)\n    }\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"NOTE"),": Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"renounce_ownership")," will emit ",(0,a.kt)("inlineCode",{parentName:"p"},"OwnershipTransferred")," event by ",(0,a.kt)("inlineCode",{parentName:"p"},"new_owner")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,a.kt)("h3",{id:"transfer_ownership"},"transfer_ownership"),(0,a.kt)("p",null,"Transfers ownership of the contract to a new account (",(0,a.kt)("inlineCode",{parentName:"p"},"new_owner"),"). Can only be called by the current owner."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(message)]\n    pub fn transfer_ownership(&mut self, new_owner: AccountId) {\n        ownable::Impl::transfer_ownership(self, &new_owner)\n    }\n")),(0,a.kt)("h2",{id:"immutable-message"},"Immutable Message"),(0,a.kt)("h3",{id:"owner"},"owner"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"owner")," Return the owner AccountId."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(message)]\n    pub fn owner(&self) -> Option<AccountId> {\n        *ownable::Impl::owner(self)\n    }\n")),(0,a.kt)("h2",{id:"internal-functions"},"Internal Functions"),(0,a.kt)("p",null,"A contract with ",(0,a.kt)("inlineCode",{parentName:"p"},"Ownable")," component can allow ",(0,a.kt)("inlineCode",{parentName:"p"},"owner")," to be granted exclusive access to specific functions, this check need impl by ",(0,a.kt)("inlineCode",{parentName:"p"},"ensure_xxx")," functions."),(0,a.kt)("h3",{id:"ensure_owner"},"ensure_owner"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ensure_owner")," check if ",(0,a.kt)("inlineCode",{parentName:"p"},"owner")," is the owner of the contract, panic if the ",(0,a.kt)("inlineCode",{parentName:"p"},"owner")," not the owner of the contract."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    fn ensure_owner(&self, owner: &E::AccountId) {\n        assert!(&self.get().get_ownership().clone().unwrap() == owner);\n    }\n")),(0,a.kt)("h3",{id:"ensure_caller_is_owner"},"ensure_caller_is_owner"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ensure_caller_is_owner")," check if caller is the owner of the contract, panic if the caller not the owner of the contract."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    fn ensure_caller_is_owner(&self) {\n        self.ensure_owner(&Self::caller());\n    }\n")),(0,a.kt)("h3",{id:"ensure_owner_renounce"},"ensure_owner_renounce"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ensure_owner_renounce")," check the current owner is renounced."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Panic the contract owner is not renounced,\n    fn ensure_owner_renounce(&self) {\n        assert!(self.get().get_ownership().is_none());\n    }\n")),(0,a.kt)("h2",{id:"events"},"Events"),(0,a.kt)("h3",{id:"ownershiptransferred"},"OwnershipTransferred"),(0,a.kt)("p",null,"The Event will emit when the ownership of the contract is transferred:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"in constructor, will emit ",(0,a.kt)("inlineCode",{parentName:"li"},"None")," -> caller."),(0,a.kt)("li",{parentName:"ul"},"in ",(0,a.kt)("inlineCode",{parentName:"li"},"transfer_ownership"),", will emit caller -> new_owner."),(0,a.kt)("li",{parentName:"ul"},"in ",(0,a.kt)("inlineCode",{parentName:"li"},"renounce_ownership"),", will emit caller -> ",(0,a.kt)("inlineCode",{parentName:"li"},"None"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Event emitted when Owner AccountId Transferred\n    #[ink(event)]\n    #[metis(ownable)]\n    pub struct OwnershipTransferred {\n        /// previous owner account id\n        #[ink(topic)]\n        previous_owner: Option<AccountId>,\n        /// new owner account id\n        #[ink(topic)]\n        new_owner: Option<AccountId>,\n    }\n")),(0,a.kt)("h2",{id:"usage-example"},"Usage Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[metis_lang::contract]\npub mod contract {\n    use metis_lang::{\n        import,\n        metis,\n    };\n    use metis_ownable as ownable;\n\n    #[ink(storage)]\n    #[import(ownable)]\n    pub struct Contract {\n        // ...\n        ownable: ownable::Data<Contract>,\n        // ...\n    }\n\n    // ...\n\n    /// Event emitted when Owner AccountId Transferred\n    #[ink(event)]\n    #[metis(ownable)]\n    pub struct OwnershipTransferred {\n        /// previous owner account id\n        #[ink(topic)]\n        previous_owner: Option<AccountId>,\n        /// new owner account id\n        #[ink(topic)]\n        new_owner: Option<AccountId>,\n    }\n\n    impl Contract {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            let mut instance = Self {\n                // ...\n                ownable: ownable::Data::new(),\n                // ...\n            };\n\n            // ...\n\n            ownable::Impl::init(&mut instance);\n\n            instance\n        }\n\n        /// Return the owner AccountId\n        #[ink(message)]\n        pub fn owner(&self) -> Option<AccountId> {\n            *ownable::Impl::owner(self)\n        }\n\n        /// Leaves the contract without owner. It will not be possible to call\n        /// `ensure_xxx` functions anymore. Can only be called by the current owner.\n        /// NOTE: Renouncing ownership will leave the contract without an owner,\n        /// thereby removing any functionality that is only available to the owner.\n        #[ink(message)]\n        pub fn renounce_ownership(&mut self) {\n            ownable::Impl::renounce_ownership(self)\n        }\n\n        /// Transfers ownership of the contract to a new account (`new_owner`).\n        /// Can only be called by the current owner.\n        #[ink(message)]\n        pub fn transfer_ownership(&mut self, new_owner: AccountId) {\n            ownable::Impl::transfer_ownership(self, &new_owner)\n        }\n\n        /// Example for owner\n        #[ink(message)]\n        pub fn msg_use_owner(&mut self) {\n            ownable::Impl::ensure_caller_is_owner(self);\n\n            // other logics\n        }\n    }\n}\n")))}w.isMDXComponent=!0}}]);