"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[2724],{3905:function(e,n,t){t.d(n,{Zo:function(){return i},kt:function(){return m}});var a=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function u(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?u(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):u(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},u=Object.keys(e);for(a=0;a<u.length;a++)t=u[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var u=Object.getOwnPropertySymbols(e);for(a=0;a<u.length;a++)t=u[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var o=a.createContext({}),p=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},i=function(e){var n=p(e.components);return a.createElement(o.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,u=e.originalType,o=e.parentName,i=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=s,b=d["".concat(o,".").concat(m)]||d[m]||c[m]||u;return t?a.createElement(b,r(r({ref:n},i),{},{components:t})):a.createElement(b,r({ref:n},i))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var u=t.length,r=new Array(u);r[0]=d;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l.mdxType="string"==typeof e?e:s,r[1]=l;for(var p=2;p<u;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6964:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return o},metadata:function(){return p},toc:function(){return i},default:function(){return d}});var a=t(7462),s=t(3366),u=(t(7294),t(3905)),r=["components"],l={},o="Pausable",p={unversionedId:"metis/guides/security/pausable",id:"metis/guides/security/pausable",isDocsHomePage:!1,title:"Pausable",description:"Metis component which allows the contract to implement an emergency stop",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/metis/guides/security/pausable.md",sourceDirName:"metis/guides/security",slug:"/metis/guides/security/pausable",permalink:"/substrate-contracts-book/en/metis/guides/security/pausable",editUrl:"https://github.com/patractlabs/substrate-contracts-book/edit/master/docs/metis/guides/security/pausable.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Timelock Controller",permalink:"/substrate-contracts-book/en/metis/guides/governance/timelock-controller"},next:{title:"Reentrancy Guard",permalink:"/substrate-contracts-book/en/metis/guides/security/reentrancy-guard"}},i=[{value:"Dependency",id:"dependency",children:[]},{value:"Storage",id:"storage",children:[]},{value:"Mutable Messages",id:"mutable-messages",children:[{value:"_pause",id:"_pause",children:[]},{value:"_unpause",id:"_unpause",children:[]}]},{value:"Immutable Messages",id:"immutable-messages",children:[{value:"paused",id:"paused",children:[]}]},{value:"Internal Functions",id:"internal-functions",children:[{value:"ensure_paused",id:"ensure_paused",children:[]},{value:"ensure_not_paused",id:"ensure_not_paused",children:[]}]},{value:"Events",id:"events",children:[{value:"Paused",id:"paused-1",children:[]},{value:"Unpaused",id:"unpaused",children:[]}]},{value:"Usage Example",id:"usage-example",children:[]}],c={toc:i};function d(e){var n=e.components,t=(0,s.Z)(e,r);return(0,u.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,u.kt)("h1",{id:"pausable"},"Pausable"),(0,u.kt)("p",null,"Metis component which allows the contract to implement an emergency stop\nmechanism that can be triggered by an authorized account."),(0,u.kt)("p",null,"This component is used through inheritance. It will make available through the\ninternal functions ",(0,u.kt)("inlineCode",{parentName:"p"},"ensure_not_paused")," and ",(0,u.kt)("inlineCode",{parentName:"p"},"ensure_paused"),", which can be applied to\nthe functions of your contract. Note that they will not be pausable by\nsimply including this component, only once the modifiers(hooks) are put in place."),(0,u.kt)("h2",{id:"dependency"},"Dependency"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},'metis_pausable = { git = "https://github.com/patractlabs/metis", default-features = false }\n')),(0,u.kt)("h2",{id:"storage"},"Storage"),(0,u.kt)("p",null,(0,u.kt)("inlineCode",{parentName:"p"},"Pausable")," has only one state for pause or unpause:"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"/// The Data of pausable component\npub struct Data {\n    /// is contract current paused\n    paused: Lazy<bool>,\n}\n")),(0,u.kt)("h2",{id:"mutable-messages"},"Mutable Messages"),(0,u.kt)("p",null,"To control a contract is paused or unpause, we need impl some access limit for it, so the ",(0,u.kt)("inlineCode",{parentName:"p"},"_pause")," and ",(0,u.kt)("inlineCode",{parentName:"p"},"_unpause")," should be called by develop."),(0,u.kt)("blockquote",null,(0,u.kt)("p",{parentName:"blockquote"},(0,u.kt)("strong",{parentName:"p"},"WARNNING")," NOT use ",(0,u.kt)("inlineCode",{parentName:"p"},"_pause")," and ",(0,u.kt)("inlineCode",{parentName:"p"},"_unpause")," directly.")),(0,u.kt)("h3",{id:"_pause"},"_pause"),(0,u.kt)("p",null,"Pause the contract, will emit the Paused Event."),(0,u.kt)("p",null,"Requirements:"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"The contract must be not paused.")),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _pause(&mut self) {\n        self.ensure_not_paused();\n        self.get_mut().pause();\n        self.emit_event_paused(Self::caller());\n    }\n")),(0,u.kt)("h3",{id:"_unpause"},"_unpause"),(0,u.kt)("p",null,"Unpause the contract, will emit the ",(0,u.kt)("inlineCode",{parentName:"p"},"Unpaused")," Event"),(0,u.kt)("p",null,"Requirements:"),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"The contract must be paused.")),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _unpause(&mut self) {\n        self.ensure_paused();\n        self.get_mut().unpause();\n        self.emit_event_unpaused(Self::caller());\n    }\n")),(0,u.kt)("h2",{id:"immutable-messages"},"Immutable Messages"),(0,u.kt)("h3",{id:"paused"},"paused"),(0,u.kt)("p",null,"Returns true if the contract is paused, and false otherwise"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"    fn paused(&self) -> bool {\n        self.get().is_paused()\n    }\n")),(0,u.kt)("h2",{id:"internal-functions"},"Internal Functions"),(0,u.kt)("p",null,"A contract with ",(0,u.kt)("inlineCode",{parentName:"p"},"Pausable")," component can use ",(0,u.kt)("inlineCode",{parentName:"p"},"ensure_paused")," and ",(0,u.kt)("inlineCode",{parentName:"p"},"ensure_not_paused")," to make sure the messages cannot used when paused."),(0,u.kt)("h3",{id:"ensure_paused"},"ensure_paused"),(0,u.kt)("p",null,"Panic if current is not paused."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},'    fn ensure_paused(&self) {\n        assert!(self.get().is_paused(), "Pausable: ensure paused");\n    }\n')),(0,u.kt)("h3",{id:"ensure_not_paused"},"ensure_not_paused"),(0,u.kt)("p",null,"Panic if current is paused."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},'    fn ensure_not_paused(&self) {\n        assert!(!self.get().is_paused(), "Pausable: ensure not paused");\n    }\n')),(0,u.kt)("h2",{id:"events"},"Events"),(0,u.kt)("h3",{id:"paused-1"},"Paused"),(0,u.kt)("p",null,"The Event will emit when the contract is into paused state."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(pausable)]\n    pub struct Paused {\n        /// paused caller\n        #[ink(topic)]\n        account: AccountId,\n    }\n")),(0,u.kt)("h3",{id:"unpaused"},"Unpaused"),(0,u.kt)("p",null,"The Event will emit when the contract is unpaused."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(pausable)]\n    pub struct Unpaused {\n        /// unpaused caller\n        #[ink(topic)]\n        account: AccountId,\n    }\n")),(0,u.kt)("h2",{id:"usage-example"},"Usage Example"),(0,u.kt)("p",null,"To use ",(0,u.kt)("inlineCode",{parentName:"p"},"Pausable")," component, should import pausable, at the same time, if use pausable component,\nwe need some access control to control pause or unpause, so we will also import ownerable component."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"#[metis_lang::contract]\nmod contract {\n    use metis_lang::{\n        import,\n        metis,\n    };\n    \n    use metis_ownable as ownable;\n    use metis_pausable as pausable;\n\n    #[ink(storage)]\n    #[import(pausable, ownable)]\n    pub struct PausableContract {\n        pausable: pausable::Data,\n        ownable: ownable::Data<Flipper>,\n\n        // other datas\n    }\n}\n")),(0,u.kt)("p",null,"Note pausable component not need use Env for types in environment, just use ",(0,u.kt)("inlineCode",{parentName:"p"},"pausable::Data"),"."),(0,u.kt)("p",null,"Add Events which pausable need:"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Event emitted when Pause\n    #[ink(event)]\n    #[metis(pausable)]\n    pub struct Paused {\n        /// paused caller\n        #[ink(topic)]\n        account: AccountId,\n    }\n\n    /// Event emitted when unPause\n    #[ink(event)]\n    #[metis(pausable)]\n    pub struct Unpaused {\n        /// unpaused caller\n        #[ink(topic)]\n        account: AccountId,\n    }\n\n    /// Need OwnershipTransferred for ownerable.\n")),(0,u.kt)("p",null,"in constructor, call the init from pausable:"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(constructor)]\n    pub fn new() -> Self {\n        let mut instance = Self {\n            pausable: pausable::Data::default(),\n            ownable: ownable::Data::default(),\n\n            // other datas default data\n        };\n\n        pausable::Impl::init(&mut instance);\n        ownable::Impl::init(&mut instance);\n\n        // other initializes\n\n        instance\n    }\n")),(0,u.kt)("p",null,"then add the message to control if is paused:"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Returns true if the contract is paused, and false otherwise\n    #[ink(message)]\n    pub fn paused(&self) -> bool {\n        pausable::Impl::paused(self)\n    }\n\n    /// Pause the contract, will emit the `Paused` Event\n    ///\n    /// Requirements:\n    ///\n    /// - The contract must be not paused.\n    /// - The caller should be the owner of contract\n    #[ink(message)]\n    pub fn pause(&mut self) {\n        ownable::Impl::ensure_caller_is_owner(self);\n        pausable::Impl::_pause(self)\n    }\n\n    /// Unpause the contract, will emit the `Unpaused` Event\n    ///\n    /// Requirements:\n    ///\n    /// - The contract must be paused.\n    /// - The caller should be the owner of contract\n    #[ink(message)]\n    pub fn unpause(&mut self) {\n        ownable::Impl::ensure_caller_is_owner(self);\n        pausable::Impl::_unpause(self)\n    }\n")),(0,u.kt)("p",null,"In this example, only owner can pause or unpause the contract. In different contracts, this also can impl by access-control component."),(0,u.kt)("p",null,"In other contract messages, we can use ",(0,u.kt)("inlineCode",{parentName:"p"},"ensure_paused")," and ",(0,u.kt)("inlineCode",{parentName:"p"},"ensure_not_paused")," to control contract logic by paused:"),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(message)]\n    pub fn do_sth(&mut self) {\n        // if contract is paused, the do_sth cannot called\n        pausable::Impl::ensure_not_paused(self);\n        \n        // logic for do_sth\n    }\n")))}d.isMDXComponent=!0}}]);