"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[313],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},l=Object.keys(e);for(o=0;o<l.length;o++)t=l[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(o=0;o<l.length;o++)t=l[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=o.createContext({}),i=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=i(e.components);return o.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},p=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=i(t),m=r,k=p["".concat(s,".").concat(m)]||p[m]||d[m]||l;return t?o.createElement(k,a(a({ref:n},u),{},{components:t})):o.createElement(k,a({ref:n},u))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,a=new Array(l);a[0]=p;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,a[1]=c;for(var i=2;i<l;i++)a[i]=t[i];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}p.displayName="MDXCreateElement"},8001:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return i},toc:function(){return u},default:function(){return p}});var o=t(7462),r=t(3366),l=(t(7294),t(3905)),a=["components"],c={},s="Access Control",i={unversionedId:"metis/guides/access-control/access-control",id:"metis/guides/access-control/access-control",isDocsHomePage:!1,title:"Access Control",description:"Access Control is the component that allows a contract to implement role-based access control mechanisms. This is a lightweight version that doesn't allow enumerating role members except through off-chain means by accessing the contract event logs. Some applications may benefit from on-chain enumerability, for those cases see access-control-eunmerable[./access-control-enumerable.md].",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/metis/guides/access-control/access-control.md",sourceDirName:"metis/guides/access-control",slug:"/metis/guides/access-control/access-control",permalink:"/substrate-contracts-book/en/metis/guides/access-control/access-control",editUrl:"https://github.com/patractlabs/substrate-contracts-book/docs/metis/guides/access-control/access-control.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Ownable",permalink:"/substrate-contracts-book/en/metis/guides/access-control/ownable"},next:{title:"Access Control Enumerable",permalink:"/substrate-contracts-book/en/metis/guides/access-control/access-control-enumerable"}},u=[{value:"Dependency",id:"dependency",children:[]},{value:"Storage",id:"storage",children:[]},{value:"Mutable Messages",id:"mutable-messages",children:[{value:"grant_role",id:"grant_role",children:[]},{value:"revoke_role",id:"revoke_role",children:[]},{value:"renounce_role",id:"renounce_role",children:[]}]},{value:"Immutable Message",id:"immutable-message",children:[{value:"has_role",id:"has_role",children:[]},{value:"get_role_admin",id:"get_role_admin",children:[]}]},{value:"Internal Functions",id:"internal-functions",children:[{value:"ensure_role",id:"ensure_role",children:[]},{value:"ensure_caller_role",id:"ensure_caller_role",children:[]},{value:"ensure_admin_role",id:"ensure_admin_role",children:[]},{value:"check_role",id:"check_role",children:[]},{value:"check_admin_role",id:"check_admin_role",children:[]}]},{value:"Events",id:"events",children:[{value:"RoleAdminChanged",id:"roleadminchanged",children:[]},{value:"RoleGranted",id:"rolegranted",children:[]},{value:"RoleRevoked",id:"rolerevoked",children:[]}]},{value:"Usage Example",id:"usage-example",children:[]}],d={toc:u};function p(e){var n=e.components,t=(0,r.Z)(e,a);return(0,l.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"access-control"},"Access Control"),(0,l.kt)("p",null,"Access Control is the component that allows a contract to implement role-based access control mechanisms. This is a lightweight version that doesn't allow enumerating role members except through off-chain means by accessing the contract event logs. Some applications may benefit from on-chain enumerability, for those cases see ",(0,l.kt)("inlineCode",{parentName:"p"},"access-control-eunmerable"),"[./access-control-enumerable.md]","."),(0,l.kt)("p",null,"Roles are referred to by their ",(0,l.kt)("inlineCode",{parentName:"p"},"RoleId")," which is a 32-bytes. These should be exposed in the external API and be unique. The best way to achieve this is by using hash digests."),(0,l.kt)("p",null,"Roles can be used to represent a set of permissions. To restrict access to a function call, use ",(0,l.kt)("inlineCode",{parentName:"p"},"ensure_caller_role"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    // need role\n    #[ink(message)]\n    pub fn func(&mut self) {\n        access_control::Impl::ensure_caller_role(self, ROLE_ID_XXX);\n\n        // other logics\n    }\n")),(0,l.kt)("p",null,"Roles can be granted and revoked dynamically via the ",(0,l.kt)("inlineCode",{parentName:"p"},"grant_role")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"revoke_role")," functions. Each role has an associated admin role, and only accounts that have a role's admin role can call ",(0,l.kt)("inlineCode",{parentName:"p"},"grant_role")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"revoke_role"),"."),(0,l.kt)("h2",{id:"dependency"},"Dependency"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'metis_access_control = { git = "https://github.com/patractlabs/metis", default-features = false }\n')),(0,l.kt)("h2",{id:"storage"},"Storage"),(0,l.kt)("p",null,"The storage contains the ",(0,l.kt)("inlineCode",{parentName:"p"},"roles")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"admin_roles"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'/// The Data of access control component\n#[cfg_attr(feature = "std", derive(::ink_storage::traits::StorageLayout))]\n#[derive(Debug, SpreadLayout)]\npub struct Data<E>\nwhere\n    E: Env,\n{\n    /// the account - role relationship map\n    pub roles: StorageHashMap<(RoleId, E::AccountId), ()>,\n\n    /// the admin role of a role\n    pub admin_roles: StorageHashMap<RoleId, RoleId>,\n}\n')),(0,l.kt)("p",null,"To declare the storage:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(storage)]\n    #[import(access_control)]\n    pub struct Contract {\n        access_control: access_control::Data<Contract>,\n\n        // other modules\n    }\n")),(0,l.kt)("h2",{id:"mutable-messages"},"Mutable Messages"),(0,l.kt)("h3",{id:"grant_role"},"grant_role"),(0,l.kt)("p",null,"Grants ",(0,l.kt)("inlineCode",{parentName:"p"},"role")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"account"),". If ",(0,l.kt)("inlineCode",{parentName:"p"},"account")," had not been already granted ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),", emits a ",(0,l.kt)("inlineCode",{parentName:"p"},"RoleGranted")," event."),(0,l.kt)("p",null,"Requirements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the caller must have ",(0,l.kt)("inlineCode",{parentName:"li"},"role"),"'s admin role.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    fn grant_role(&mut self, role: RoleId, account: E::AccountId) {\n        // check the admin role\n        self.ensure_admin_role(role, Self::caller());\n\n        self._setup_role(role, account);\n    }\n")),(0,l.kt)("h3",{id:"revoke_role"},"revoke_role"),(0,l.kt)("p",null,"Revokes ",(0,l.kt)("inlineCode",{parentName:"p"},"role")," from ",(0,l.kt)("inlineCode",{parentName:"p"},"account"),". If ",(0,l.kt)("inlineCode",{parentName:"p"},"account")," had been granted ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),", emits a ",(0,l.kt)("inlineCode",{parentName:"p"},"RoleRevoked")," event."),(0,l.kt)("p",null,"Requirements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the caller must have ",(0,l.kt)("inlineCode",{parentName:"li"},"role"),"'s admin role.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'    fn revoke_role(&mut self, role: RoleId, account: E::AccountId) {\n        let caller = Self::caller();\n\n        // check the admin role\n        self.ensure_admin_role(role, caller.clone());\n\n        // if has not role\n        self.get_mut()\n            .revoke_role(role, account.clone())\n            .expect("no has role");\n\n        // emit if revoke role success\n        self.emit_event_role_revoked(role, account, caller);\n    }\n')),(0,l.kt)("h3",{id:"renounce_role"},"renounce_role"),(0,l.kt)("p",null,"Revokes ",(0,l.kt)("inlineCode",{parentName:"p"},"role")," from the calling account."),(0,l.kt)("p",null,"Roles are often managed via ",(0,l.kt)("inlineCode",{parentName:"p"},"grant_role")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"revoke_role"),": this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced)."),(0,l.kt)("p",null,"If the calling account had been granted ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),", emits a ",(0,l.kt)("inlineCode",{parentName:"p"},"RoleRevoked")," event."),(0,l.kt)("p",null,"Requirements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the caller must be ",(0,l.kt)("inlineCode",{parentName:"li"},"account"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'    fn renounce_role(&mut self, role: RoleId, account: E::AccountId) {\n        let caller = Self::caller();\n\n        // check the caller is account\n        assert!(caller == account, "account not caller");\n\n        // if has not role\n        self.get_mut()\n            .revoke_role(role, account.clone())\n            .expect("no has role");\n\n        // emit if revoke role success\n        self.emit_event_role_revoked(role, account, caller);\n    }\n')),(0,l.kt)("h2",{id:"immutable-message"},"Immutable Message"),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"has_role")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"get_role_admin")," can to get the role releations of accounts."),(0,l.kt)("h3",{id:"has_role"},"has_role"),(0,l.kt)("p",null,"Returns ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"account")," has been granted ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    fn has_role(&self, role: RoleId, account: E::AccountId) -> bool {\n        self.get().has_role(role, account)\n    }\n")),(0,l.kt)("h3",{id:"get_role_admin"},"get_role_admin"),(0,l.kt)("p",null,"Returns the admin role that controls ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),". See {grant_role} and {revoke_role}."),(0,l.kt)("p",null,"To change a role's admin, use ",(0,l.kt)("inlineCode",{parentName:"p"},"_set_role_admin"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    fn get_role_admin(&self, role: RoleId) -> Option<RoleId> {\n        self.get().admin_roles.get(&role).copied()\n    }\n")),(0,l.kt)("h2",{id:"internal-functions"},"Internal Functions"),(0,l.kt)("p",null,"Use Apis to check and ensure account has role."),(0,l.kt)("h3",{id:"ensure_role"},"ensure_role"),(0,l.kt)("p",null,"Panic if ",(0,l.kt)("inlineCode",{parentName:"p"},"owner")," is not an owner."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'    fn ensure_role(&self, role: RoleId, account: E::AccountId) {\n        assert!(self.has_role(role, account), "role missing");\n    }\n')),(0,l.kt)("h3",{id:"ensure_caller_role"},"ensure_caller_role"),(0,l.kt)("p",null,"Panic if caller is not granted role."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    fn ensure_caller_role(&self, role: RoleId) {\n        self.ensure_role(role, Self::caller());\n    }\n")),(0,l.kt)("h3",{id:"ensure_admin_role"},"ensure_admin_role"),(0,l.kt)("p",null,"Panic error if ",(0,l.kt)("inlineCode",{parentName:"p"},"account")," is missing the admin role of the ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'    fn ensure_admin_role(&self, role: RoleId, account: E::AccountId) {\n        match self.get_role_admin(role) {\n            Some(admin_role) => self.ensure_role(admin_role, account),\n            None => panic!("admin role missing"),\n        }\n    }\n')),(0,l.kt)("h3",{id:"check_role"},"check_role"),(0,l.kt)("p",null,"Return error if ",(0,l.kt)("inlineCode",{parentName:"p"},"account")," is missing ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    fn check_role(&self, role: RoleId, account: E::AccountId) -> Result<()> {\n        if self.has_role(role, account) {\n            Ok(())\n        } else {\n            Err(Error::RoleNotFound)\n        }\n    }\n")),(0,l.kt)("h3",{id:"check_admin_role"},"check_admin_role"),(0,l.kt)("p",null,"Return error if ",(0,l.kt)("inlineCode",{parentName:"p"},"account")," is missing the admin role of the ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    fn check_admin_role(&self, role: RoleId, account: E::AccountId) -> Result<()> {\n        match self.get_role_admin(role) {\n            Some(admin_role) => self.check_role(admin_role, account),\n            None => Err(Error::AdminRoleNotFound),\n        }\n    }\n")),(0,l.kt)("h2",{id:"events"},"Events"),(0,l.kt)("h3",{id:"roleadminchanged"},"RoleAdminChanged"),(0,l.kt)("p",null,"Emitted when ",(0,l.kt)("inlineCode",{parentName:"p"},"new_admin_role")," is set as ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),"'s admin role, replacing ",(0,l.kt)("inlineCode",{parentName:"p"},"previous_admin_role")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"will emit by call ",(0,l.kt)("inlineCode",{parentName:"li"},"_set_role_admin"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(access_control)]\n    pub struct RoleAdminChanged {\n        #[ink(topic)]\n        pub role: RoleId,\n        #[ink(topic)]\n        pub previous_admin_role: Option<RoleId>,\n        #[ink(topic)]\n        pub new_admin_role: RoleId,\n    }\n")),(0,l.kt)("h3",{id:"rolegranted"},"RoleGranted"),(0,l.kt)("p",null,"Emitted when ",(0,l.kt)("inlineCode",{parentName:"p"},"account")," is granted ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"will emit by call ",(0,l.kt)("inlineCode",{parentName:"li"},"_setup_role"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(access_control)]\n    pub struct RoleGranted {\n        #[ink(topic)]\n        pub role: RoleId,\n        #[ink(topic)]\n        pub account: AccountId,\n        #[ink(topic)]\n        pub sender: AccountId,\n    }\n")),(0,l.kt)("h3",{id:"rolerevoked"},"RoleRevoked"),(0,l.kt)("p",null,"Emitted when ",(0,l.kt)("inlineCode",{parentName:"p"},"account")," is revoked ",(0,l.kt)("inlineCode",{parentName:"p"},"role"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"sender")," is the account that originated the contract call:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"if using ",(0,l.kt)("inlineCode",{parentName:"li"},"revoke_role"),", it is the admin role bearer"),(0,l.kt)("li",{parentName:"ul"},"if using ",(0,l.kt)("inlineCode",{parentName:"li"},"renounce_role"),", it is the role bearer (i.e. ",(0,l.kt)("inlineCode",{parentName:"li"},"account"),")")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(access_control)]\n    pub struct RoleRevoked {\n        #[ink(topic)]\n        pub role: RoleId,\n        #[ink(topic)]\n        pub account: AccountId,\n        #[ink(topic)]\n        pub sender: AccountId,\n    }\n")),(0,l.kt)("h2",{id:"usage-example"},"Usage Example"),(0,l.kt)("p",null,"To use the Access Control Component, First is import the ",(0,l.kt)("inlineCode",{parentName:"p"},"access_control"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\n#[metis_lang::contract]\npub mod example {\n    pub use access_control::{\n        Error,\n        Result,\n        RoleId,\n    };\n    use metis_access_control as access_control;\n    use metis_lang::{\n        import,\n        metis,\n    };\n\n    #[ink(storage)]\n    #[import(access_control)]\n    pub struct Contract {\n        access_control: access_control::Data<Contract>,\n\n        // other modules\n    }\n')),(0,l.kt)("p",null,"Define the Event for access control:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Emitted when `new_admin_role` is set as ``role``'s\n    /// admin role, replacing `previous_admin_role`\n    #[ink(event)]\n    #[metis(access_control)]\n    pub struct RoleAdminChanged {\n        #[ink(topic)]\n        pub role: RoleId,\n        #[ink(topic)]\n        pub previous_admin_role: Option<RoleId>,\n        #[ink(topic)]\n        pub new_admin_role: RoleId,\n    }\n\n    /// Emitted when `account` is granted `role`.\n    ///\n    /// `sender` is the account that originated the contract call,\n    /// an admin role bearer except when using {_setupRole}.\n    #[ink(event)]\n    #[metis(access_control)]\n    pub struct RoleGranted {\n        #[ink(topic)]\n        pub role: RoleId,\n        #[ink(topic)]\n        pub account: AccountId,\n        #[ink(topic)]\n        pub sender: AccountId,\n    }\n\n    /// Emitted when `account` is revoked `role`.\n    ///\n    /// `sender` is the account that originated the contract call:\n    ///   - if using `revoke_role`, it is the admin role bearer\n    ///   - if using `renounce_role`, it is the role bearer (i.e. `account`)\n    #[ink(event)]\n    #[metis(access_control)]\n    pub struct RoleRevoked {\n        #[ink(topic)]\n        pub role: RoleId,\n        #[ink(topic)]\n        pub account: AccountId,\n        #[ink(topic)]\n        pub sender: AccountId,\n    }\n")),(0,l.kt)("p",null,"Impl the ",(0,l.kt)("inlineCode",{parentName:"p"},"constructor")," of the contract:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(constructor)]\n    pub fn new(\n        fliper: AccountId,\n        setter: AccountId,\n        admin: AccountId,\n    ) -> Self {\n        let mut instance = Self {\n            // Need add access_control module\n            access_control: access_control::Data::new(),\n        };\n\n        // Use the `_setup_role` set the ROLEs\n        access_control::Impl::_setup_role(&mut instance, ROLE_ID_FLIPER, fliper);\n        access_control::Impl::_setup_role(&mut instance, ROLE_ID_SETTER, setter);\n        access_control::Impl::_setup_role(&mut instance, ROLE_ID_ADMIN, admin);\n\n        // Use `_set_role_admin` set the role admin\n        access_control::Impl::_set_role_admin(\n            &mut instance,\n            ROLE_ID_FLIPER,\n            ROLE_ID_ADMIN,\n        );\n\n        // create the default role\n        instance\n    }\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"WARNNING: In metis, access control not have a ",(0,l.kt)("inlineCode",{parentName:"p"},"default admin role")," which be admin role of all roles, so we need defined the role releations in constructor.")),(0,l.kt)("p",null,"In constructor, we can use ",(0,l.kt)("inlineCode",{parentName:"p"},"_setup_role")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"_set_role_admin")," to set the role releations for contract."),(0,l.kt)("p",null,"Next, Add the message to control the role releations."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Returns `true` if `account` has been granted `role`.\n    #[ink(message)]\n    pub fn has_role(&self, role: RoleId, account: AccountId) -> bool {\n        access_control::Impl::has_role(self, role, account)\n    }\n\n    /// @dev Returns the admin role that controls `role`. See {grant_role} and\n    /// {revoke_role}.\n    ///\n    /// To change a role's admin, use {_setRoleAdmin}.\n    #[ink(message)]\n    pub fn get_role_admin(&self, role: RoleId) -> Option<RoleId> {\n        access_control::Impl::get_role_admin(self, role)\n    }\n\n    /// @dev Grants `role` to `account`.\n    ///\n    /// If `account` had not been already granted `role`, emits a {RoleGranted}\n    /// event.\n    ///\n    /// Requirements:\n    ///\n    /// - the caller must have ``role``'s admin role.\n    #[ink(message)]\n    pub fn grant_role(&mut self, role: RoleId, account: AccountId) {\n        access_control::Impl::grant_role(self, role, account)\n    }\n\n    /// @dev Revokes `role` from `account`.\n    ///\n    /// If `account` had been granted `role`, emits a {RoleRevoked} event.\n    ///\n    /// Requirements:\n    ///\n    /// - the caller must have ``role``'s admin role.\n    #[ink(message)]\n    pub fn revoke_role(&mut self, role: RoleId, account: AccountId) {\n        access_control::Impl::revoke_role(self, role, account)\n    }\n\n    /// @dev Revokes `role` from the calling account.\n    ///\n    /// Roles are often managed via {grant_role} and {revoke_role}: this function's\n    /// purpose is to provide a mechanism for accounts to lose their privileges\n    /// if they are compromised (such as when a trusted device is misplaced).\n    ///\n    /// If the calling account had been granted `role`, emits a {RoleRevoked}\n    /// event.\n    ///\n    /// Requirements:\n    ///\n    /// - the caller must be `account`.\n    #[ink(message)]\n    pub fn renounce_role(&mut self, role: RoleId, account: AccountId) {\n        access_control::Impl::renounce_role(self, role, account)\n    }\n")))}p.isMDXComponent=!0}}]);