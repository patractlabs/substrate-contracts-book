"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[940],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),l=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=l(e.components);return o.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,m=c(e,["components","mdxType","originalType","parentName"]),u=l(n),d=r,h=u["".concat(s,".").concat(d)]||u[d]||p[d]||a;return n?o.createElement(h,i(i({ref:t},m),{},{components:n})):o.createElement(h,i({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2222:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return m},default:function(){return u}});var o=n(7462),r=n(3366),a=(n(7294),n(3905)),i=["components"],c={},s="Architectures",l={unversionedId:"metis/intro/architecture",id:"metis/intro/architecture",isDocsHomePage:!1,title:"Architectures",description:"Metis-MCCI architecture",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/metis/intro/architecture.md",sourceDirName:"metis/intro",slug:"/metis/intro/architecture",permalink:"/substrate-contracts-book/en/metis/intro/architecture",editUrl:"https://github.com/patractlabs/substrate-contracts-book/edit/master/docs/metis/intro/architecture.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Motivation",permalink:"/substrate-contracts-book/en/metis/intro/motivation"},next:{title:"Metis vs OpenZeppelin",permalink:"/substrate-contracts-book/en/metis/intro/differences"}},m=[{value:"Metis-MCCI architecture",id:"metis-mcci-architecture",children:[]},{value:"Inheritance Vs Composition",id:"inheritance-vs-composition",children:[]}],p={toc:m};function u(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"architectures"},"Architectures"),(0,a.kt)("h2",{id:"metis-mcci-architecture"},"Metis-MCCI architecture"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"M")," : Data model. Most contracts read and write contract world states. These states map to data models, each associated with only one component."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"C")," : component. A component is a reusable, independent implementation unit that encapsulates data and methods and maintains orthogonality with other components."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"C")," : controller. The controller coordinates the components and implements the contract interface."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"I")," : interface. The interface is the user interface of the contract. The interface defines the behavior of the contract and, to some extent, defines metadata.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-txt"},"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       \u2502          \u2502 Interface     \u2502 Control                        \u2502\n\u2502       \u2502          \u2502               \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502       \u2502          \u2502  Constructor  \u2502  \u2502 Component           \u2502       \u2502\n\u2502 User  \u2502  Call    \u2502               \u2502  \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2510    \u2502\n\u2502       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  Messages     \u2502  \u2502 \u2502 Component            \u2502    \u2502\n\u2502       \u2502          \u2502               \u2502  \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2510  \u2502\n\u2502       \u2502          \u2502  Events       \u2502  \u2502 \u2502 \u2502 Component            \u2502  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524          \u2502               \u2502  \u2502 \u2502 \u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502  \u2502\n\u2502       \u2502  Call    \u2502               \u2502  \u2502 \u2502 \u2502 Msgs   \u2502           \u2502 \u2502  \u2502\n\u2502       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502               \u2502  \u2502 \u2502 \u2502        \u2502 Module    \u2502 \u2502  \u2502\n\u2502       \u2502          \u2502               \u2502  \u2502 \u2502 \u2502 Apis   \u2502           \u2502 \u2502  \u2502\n\u2502 Apps  \u2502          \u2502               \u2502  \u2502 \u2502 \u2502        \u2502           \u2502 \u2502  \u2502\n\u2502       \u2502  Event   \u2502               \u2502  \u2514\u2500\u2524 \u2502 Events \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502  \u2502\n\u2502       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524               \u2502    \u2514\u2500\u2524                      \u2502  \u2502\n\u2502       \u2502          \u2502               \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502       \u2502          \u2502               \u2502                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,a.kt)("p",null,"As shown in the figure above, under the MCCI architecture, the contract is divided into a series of reusable components. The contract behavior is implent through the collaboration of components, and the contract behavior is clearly defined by interface and controller."),(0,a.kt)("p",null,"The contract's interface defines the contract's behavior, including:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"constructor"),(0,a.kt)("li",{parentName:"ul"},"message"),(0,a.kt)("li",{parentName:"ul"},"event")),(0,a.kt)("p",null,"The user of the contract interacts with the contract based on these three elements. In fact, these three elements also constitute ink! The main part of the contract metadata."),(0,a.kt)("p",null,"For a contract, these three things are guaranteed to be deterministic, unambiguous, and easy to understand. Therefore, the interface code of the contract code should be as cohesive as possible."),(0,a.kt)("p",null,"The contract controller is responsible for integrating the components. We break the main logic of the contract down into a series of reusable components, which can ",(0,a.kt)("strong",{parentName:"p"},"extend")," and ",(0,a.kt)("strong",{parentName:"p"},"compose")," based on other components."),(0,a.kt)("p",null,"A data model is the encapsulation of the state of a contract. A component of a contract needs a contract to meet the requirements of its data model. For a contract, its state will be represented as a combination of a series of data models."),(0,a.kt)("p",null,"In generally, the data model can also be considered as part of the contract behavior, and thus as part of the contract interface, but in most scenarios, external applications and users can not directly use the state of the chain, so the external encapsulation of the data model is not emphasized here."),(0,a.kt)("h2",{id:"inheritance-vs-composition"},"Inheritance Vs Composition"),(0,a.kt)("p",null,"In contract development, we focus more on auditability of contracts, and the use of inheritance in solidity contract development will increase the difficulty of contract audit: The behavior logic of the contract is spread out in multiple files, even in different projects. Therefore, in Metis, we do not inherit the interface and implementation of the contract. The components and data model are introduced into the contract in a combined way."),(0,a.kt)("p",null,"Each component impl a series of functions, include the impl of messages and apis. Components can ",(0,a.kt)("strong",{parentName:"p"},"extend")," and ",(0,a.kt)("strong",{parentName:"p"},"compose")," based on other components."),(0,a.kt)("p",null,"For most of components, will like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"/// The `EventEmit` impl the event emit api for ownable component.\npub trait EventEmit<E: Env>: EnvAccess<E> {\n    /// Emit OwnershipTransferred event\n    fn emit_event_ownership_transferred(\n        &mut self,\n        previous_owner: Option<E::AccountId>,\n        new_owner: Option<E::AccountId>,\n    );\n}\n\n/// The `Impl` define ownable component impl funcs\npub trait Impl<E: Env>: Storage<E, Data<E>> + EventEmit<E> {\n    /// init Initializes the contract setting the deployer as the initial owner.\n    fn init(&mut self) {\n        // logic\n    }\n\n    /// Message impl \n    fn one_message_impl(&mut self) -> Result<()> {\n        // msg impl which will call by ```xxx::Impl::one_message_impl(self)```\n\n        // use the hook\n        self.hook(xxx)?\n\n        Ok(())\n    }\n\n    /// Message for Query impl\n    fn one_query_impl(& self, param_acc: &E::AccountId) -> Data {\n        Data::default()\n    }\n\n    /// API for other message\n    fn check_xxx(&self, owner: &E::AccountId) {\n    }\n\n    // Hook which need impl by contract\n    fn hook(&mut self, params: &E::Balance) -> Result<()>;\n}\n\n")),(0,a.kt)("p",null,"Some component contains a default implementation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// a default impl, each contract which impl storage and event emitter can be component\nimpl<E: Env, T: Storage<E, Data<E>> + EventEmit<E>> Impl<E> for T {}\n")),(0,a.kt)("p",null,"To use this component, we can import this to contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\n#[metis_lang::contract] // use `metis_lang::contract`\npub mod contract {\n    // use the component: xxx1 and xxx2\n    use metis_component_xxx1 as xxx1;\n    use metis_component_xxx2 as xxx2;\n\n    // use `import` and `metis` marco\n    use metis_lang::{\n        import,\n        metis,\n    };\n\n    #[ink(storage)]\n    #[import(xxx1, xxx2)] // import the component\n    pub struct Contract {\n        // add data to storage, which use Contract as Env to Data\n        xxx1: xxx1::Data<Contract>,\n        xxx2: xxx2::Data<Contract>,\n    }\n\n    /// add event for component\n    /// in emit it will be emit_event_ownership_transferred\n    #[ink(event)]\n    #[metis(xxx1)] // event for xxx1\n    pub struct OwnershipTransferred {\n        /// previous owner account id\n        #[ink(topic)]\n        previous_owner: Option<AccountId>,\n        /// new owner account id\n        #[ink(topic)]\n        new_owner: Option<AccountId>,\n    }\n\n    /// Event emitted when payee withdraw\n    #[ink(event)]\n    #[metis(xxx2)] // event for xxx1\n    pub struct OtherEvent {\n        #[ink(topic)]\n        pub payee: AccountId,\n        pub amount: Balance,\n    }\n\n    impl xxx1::Impl<Contract> for Contract {\n        fn hook(\n            &mut self,\n            params: &E::Balance\n        ) -> Result<()> {\n            // some logic\n\n            Ok(())\n        }\n    }\n\n    // impl\n    impl Contract {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            // impl for default\n            let mut instance = Self {\n                xxx1: xxx1::Data::new(),\n                xxx2: xxx2::Data::new(),\n            };\n\n            // init call\n            xxx1::Impl::init(&mut instance);\n            xxx2::Impl::init(&mut instance);\n\n            // return instance\n            instance\n        }\n\n        /// commits for one_message_impl\n        #[ink(message)]\n        pub fn one_message_impl(&mut self) -> Result<()> {\n            // some other check\n            xxx2::Impl::do_some_check(self);\n            xxx1::Impl::one_message_impl(self)\n        }\n\n        /// commits for one_query_impl\n        #[ink(message, payable)]\n        pub fn one_query_impl(&self, payee: AccountId) {\n            xxx1::Impl::one_query_impl(self, payee)\n        }\n\n        /// commits for other_message_impl\n        #[ink(message)]\n        pub fn other_message_impl(&mut self, payee: AccountId) {\n            xxx1::Impl::check_xxx(self)\n            // other logic\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        // test for contract\n    }\n}\n')))}u.isMDXComponent=!0}}]);