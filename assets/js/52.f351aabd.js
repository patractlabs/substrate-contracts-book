(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{591:function(e,t,a){"use strict";a.r(t);var o=a(6),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design"}},[e._v("#")]),e._v(" Design")]),e._v(" "),a("h2",{attrs:{id:"ask-design-overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ask-design-overview"}},[e._v("#")]),e._v(" Ask! design overview")]),e._v(" "),a("p",[e._v("AssemblyScript uses the asc compiler to compile AssemblyScript files into WebAssembly bytecode, but it cannot directly generate Wasm bytecode and "),a("code",[e._v("metadata.json")]),e._v(" meta-information files that conform to the "),a("code",[e._v("pallet-contract")]),e._v(" ABI, so you need to write AS transform to intervene in the compiler. Compile the process, generate and export ABI-related code at a suitable location, and generate "),a("code",[e._v("metadata.json")]),e._v(" after the type information is determined.")]),e._v(" "),a("h2",{attrs:{id:"design-ideas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design-ideas"}},[e._v("#")]),e._v(" Design ideas")]),e._v(" "),a("p",[e._v("Ask! provides two libraries, "),a("code",[e._v("ask-transform")]),e._v(" (referred to as "),a("code",[e._v("transform")]),e._v(" in the following description) and "),a("code",[e._v("ask-lang")]),e._v(".\nIn addition, we will provide a build tool called "),a("code",[e._v("ask-cli")]),e._v(" in the follow-up. This tool is similar to ink!'s "),a("code",[e._v("cargo-contract")]),e._v(" to help build and manage Wasm smart contracts written with Ask!.")]),e._v(" "),a("p",[e._v("The functions of Ask! are implemented as follows:")]),e._v(" "),a("ul",[a("li",[e._v("The main function of "),a("code",[e._v("ask-lang")]),e._v(" is to provide high-level APIs for writing smart contracts, including high-level encapsulation of "),a("code",[e._v("pallet-contract")]),e._v(" primitives, scale coding, K/V storage abstraction, common basic types and common interfaces. You can automatically derive a combination of these basic classes by decorators.")]),e._v(" "),a("li",[e._v("The main function of "),a("code",[e._v("ask-transform")]),e._v(" is based on the decorator used in the Ask! code to generate code that conforms to the "),a("code",[e._v("pallet-contract")]),e._v(" specification and the "),a("code",[e._v("metadata.json")]),e._v(" meta-information file. This part implements the following functions:\n"),a("ul",[a("li",[e._v("Analyze contract interfaces and parameters, and generate metadata files.")]),e._v(" "),a("li",[e._v("Analyze custom contract decorators and generate corresponding logic codes.")]),e._v(" "),a("li",[e._v("According to the definition of storage, read/write contract storage according to a certain process.")])])])])])}),[],!1,null,null,null);t.default=n.exports}}]);