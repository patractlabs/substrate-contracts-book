"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[171],{3905:function(e,a,t){t.d(a,{Zo:function(){return d},kt:function(){return m}});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=n.createContext({}),p=function(e){var a=n.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},d=function(e){var a=p(e.components);return n.createElement(l.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=p(t),m=r,k=u["".concat(l,".").concat(m)]||u[m]||c[m]||o;return t?n.createElement(k,s(s({ref:a},d),{},{components:t})):n.createElement(k,s({ref:a},d))}));function m(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=u;var i={};for(var l in a)hasOwnProperty.call(a,l)&&(i[l]=a[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=t[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},584:function(e,a,t){t.r(a),t.d(a,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return d},default:function(){return u}});var n=t(7462),r=t(3366),o=(t(7294),t(3905)),s=["components"],i={},l="Composite Types and Storage",p={unversionedId:"ask/guides/types-storage/storage",id:"ask/guides/types-storage/storage",isDocsHomePage:!1,title:"Composite Types and Storage",description:"Overview",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/ask/guides/types-storage/storage.md",sourceDirName:"ask/guides/types-storage",slug:"/ask/guides/types-storage/storage",permalink:"/substrate-contracts-book/en/ask/guides/types-storage/storage",editUrl:"https://github.com/patractlabs/substrate-contracts-book/edit/master/docs/ask/guides/types-storage/storage.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Storage and data strucutures",permalink:"/substrate-contracts-book/en/ask/guides/types-storage/basic_types"},next:{title:"Cross Contract Calling",permalink:"/substrate-contracts-book/en/ask/guides/cross-contract"}},d=[{value:"Overview",id:"overview",children:[]},{value:"Spread VS. Packed",id:"spread-vs-packed",children:[{value:"Spread",id:"spread",children:[]},{value:"Packed",id:"packed",children:[]}]},{value:"StorableMap",id:"storablemap",children:[{value:"APIs",id:"apis",children:[]},{value:"SpreadStorableMap",id:"spreadstorablemap",children:[]},{value:"PackedStorableMap",id:"packedstorablemap",children:[]}]},{value:"StorableArray",id:"storablearray",children:[{value:"APIs",id:"apis-1",children:[]},{value:"SpreadStorableArray",id:"spreadstorablearray",children:[]},{value:"PackedStorableArray",id:"packedstorablearray",children:[]}]}],c={toc:d};function u(e){var a=e.components,i=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,n.Z)({},c,i,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"composite-types-and-storage"},"Composite Types and Storage"),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"Besides from basic types in last section, oftentimes we need to use more complex data structures for storage to implement complex logics in smart contract. "),(0,o.kt)("p",null,"The following schema depicts the storage which is exposed to ink! by the contracts pallet:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"substrate kv",src:t(3714).Z})),(0,o.kt)("p",null,"Storing or loading complex data structures to and from contract storage can be done in many different ways. You could store all information into a single storage cell or you could try to store all information into as many different cells as possible. Both strategies have pros and cons under different conditions."),(0,o.kt)("h2",{id:"spread-vs-packed"},"Spread VS. Packed"),(0,o.kt)("p",null,"Ask! provides two composite data types for storage: ",(0,o.kt)("inlineCode",{parentName:"p"},"StorableMap"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"StorableArray"),". The composite data type supports two storage modes, ",(0,o.kt)("strong",{parentName:"p"},"spread")," and ",(0,o.kt)("strong",{parentName:"p"},"packed"),". "),(0,o.kt)("h3",{id:"spread"},"Spread"),(0,o.kt)("p",null,"For the ",(0,o.kt)("strong",{parentName:"p"},"spread")," storage mode, each storage unit has its own storage address, and will only be loaded when needed."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"packed",src:t(3047).Z})),(0,o.kt)("h3",{id:"packed"},"Packed"),(0,o.kt)("p",null,"For the ",(0,o.kt)("strong",{parentName:"p"},"packed")," storage mode, all storage units need to be serialized into a set of data streams and stored in a shared address. When getting data from ",(0,o.kt)("strong",{parentName:"p"},"packed")," storage, the data will fetched once. Therefore, ",(0,o.kt)("strong",{parentName:"p"},"packed")," storage isn't desirable for accessing data in large volume."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"packed",src:t(7760).Z})),(0,o.kt)("h2",{id:"storablemap"},"StorableMap"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"StorableMap"),":  ",(0,o.kt)("inlineCode",{parentName:"p"},"SpreadStorableMap")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"PackedStorableMap")," are encapsulated classes of Map, and add data persistence function. Two storage modes of ",(0,o.kt)("strong",{parentName:"p"},"spread")," and ",(0,o.kt)("strong",{parentName:"p"},"packed")," are implemented respectively. "),(0,o.kt)("h3",{id:"apis"},"APIs"),(0,o.kt)("p",null,"Here are some common functions you might use for StorableMap:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"/// check if the map has sepcific key\nhas(key: K): bool \n\n/// insert k,v into the map\nset(key: K, value: V)\n\n/// get corresponding value by key\nget(key: K): V \n\n/// delete k,v by key\ndelete(key: K): bool\n\n/// truncate the map\nclear(): void \n\n/// get all keys of the map\nkeys(): K[] \n\n/// get all values of the map\nvalues(): V[] \n")),(0,o.kt)("h3",{id:"spreadstorablemap"},"SpreadStorableMap"),(0,o.kt)("h4",{id:"usage"},"Usage"),(0,o.kt)("p",null,"To initialize a SpreadStorableMap, as long as key and value implments scale-codec, initialize it as a normal map in AssemblyscriptFor detailed apis, please check ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/ask/blob/master/as-packages/lang/assembly/storage/PackedStorableMap.ts"},(0,o.kt)("inlineCode",{parentName:"a"},"PackedStorableMap.ts"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"export class ERC20 {\n  @state balances: SpreadStorableMap<AccountId, UInt128> = new SpreadStorableMap<AccountId, UInt128>();\n}\n")),(0,o.kt)("p",null,"For detailed apis, please check ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/ask/blob/master/as-packages/lang/assembly/storage/SpreadStorableMap.ts"},(0,o.kt)("inlineCode",{parentName:"a"},"SpreadStorableMap.ts"))),(0,o.kt)("h4",{id:"implementation"},"Implementation"),(0,o.kt)("p",null,"The storage structure of ",(0,o.kt)("inlineCode",{parentName:"p"},"SpreadStorableMap")," follows:\n",(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/2844215/120952420-9172ee80-c77d-11eb-90b8-501fe679fdee.png",alt:"SpreadStorableMap"})),(0,o.kt)("p",null,"The number of data stored in this Map and the Hash of the first storage location are saved in ",(0,o.kt)("inlineCode",{parentName:"p"},"MapEntry"),". Its storage location is in ",(0,o.kt)("inlineCode",{parentName:"p"},"Hash(prefix)"),", and this storage location will be exported to metadata.json for access of external apps."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"KVStore")," is a specific stored K/V value. In addition to storing Key/Value, each KVStore also stores the hash of the next/prev node. If it is a tail node, then the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"next")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"NullHash "),", that is (",(0,o.kt)("inlineCode",{parentName:"p"},"0x0000000000000000000000000000000000"),"); if it is a head node, then the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"prev")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"NullHash"),". Through a doubly linked list, external Apps can iteratively access all data. The storage location of each ",(0,o.kt)("inlineCode",{parentName:"p"},"KVStore")," is determined by the following rules: ",(0,o.kt)("inlineCode",{parentName:"p"},"Hash(prefix + key)"),". "),(0,o.kt)("h3",{id:"packedstorablemap"},"PackedStorableMap"),(0,o.kt)("p",null,"The storage model of Packed is different from Spread, all its data is loaded/stored all at once. The usage of ",(0,o.kt)("inlineCode",{parentName:"p"},"MapEntry")," is the same as the Spread model. All its data is stored in a fixed location under ",(0,o.kt)("inlineCode",{parentName:"p"},'Hash(prefix + ".value")')," through the method of ",(0,o.kt)("inlineCode",{parentName:"p"},"u8[]"),"."),(0,o.kt)("h4",{id:"usage-1"},"Usage"),(0,o.kt)("p",null,"To initialize a PackedStorableMap, as long as key and value implments scale-codec, initialize it as a normal map in Assemblyscript"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"export class TwoSum {\n  @state hashmap: PackedStorableMap<AccountId, UInt128> = new PackedStorableMap<AccountId, UInt128>();\n}\n")),(0,o.kt)("p",null,"For detailed apis, please check ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/ask/blob/master/as-packages/lang/assembly/storage/PackedStorableMap.ts"},(0,o.kt)("inlineCode",{parentName:"a"},"PackedStorableMap.ts"))),(0,o.kt)("h4",{id:"implementation-1"},"Implementation"),(0,o.kt)("p",null,"The storage structure of ",(0,o.kt)("inlineCode",{parentName:"p"},"PackedStorableMap")," follows:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/2844215/120952350-6be5e500-c77d-11eb-8d97-975961538303.png",alt:"PackedStorableMap"})),(0,o.kt)("h2",{id:"storablearray"},"StorableArray"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"SpreadStorableArray")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"PackedStorableArray")," are the encapsulation of the Array class, and added data persistence function, respectively implementing the two storage modes of ",(0,o.kt)("strong",{parentName:"p"},"spread")," and ",(0,o.kt)("strong",{parentName:"p"},"packed"),"."),(0,o.kt)("h3",{id:"apis-1"},"APIs"),(0,o.kt)("p",null,"Some common APIs you might use."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"push(value: T): i32\n\npop(): T\n\ndelete(index: i32): bool \n\nat(index: i32): T \n\nfill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE)\n\nevery(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool \n\nfindIndex(predicate: (element: T, index: i32, array?: Array<T>) => bool): i32 \n\nincludes(searchElement: T, fromIndex: i32 = 0): bool \n\nindexOf(searchElement: T, fromIndex: i32 = 0): i32 \n\nlastIndexOf(searchElement: T, fromIndex: i32 = 0): i32 \n\nconcat(items: T[]): T[] \n\nforEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void \n\nmap<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> \n\nfilter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> \n\nreduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U \n\nreduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U \n\nsome(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool \n\nslice(from: i32, to: i32 = i32.MAX_VALUE): Array<T> \n\nsplice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> \n\nsort(comparator: (a: T, b: T) => i32)\n\nreverse(): T[] \n")),(0,o.kt)("h3",{id:"spreadstorablearray"},"SpreadStorableArray"),(0,o.kt)("h4",{id:"usage-2"},"Usage"),(0,o.kt)("p",null,"To initialize an SpreadStorableArray"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@contract\nclass Flipper {\n    @state flag: bool;\n    @state\n    aArr: SpreadStorableArray<UInt128> = new SpreadStorableArray<UInt128>(); \n")),(0,o.kt)("h4",{id:"implementation-2"},"Implementation"),(0,o.kt)("p",null,"The storage structure of ",(0,o.kt)("inlineCode",{parentName:"p"},"SpreadStorableArray")," is as follows:\n",(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/2844215/120952366-730cf300-c77d-11eb-82ce-2c2b23e5ce50.png",alt:"SpreadStorableArray"})),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ArrayEntry")," saves the number of elements of this Array ",(0,o.kt)("inlineCode",{parentName:"p"},"size")," and the number of bytes after serialization ",(0,o.kt)("inlineCode",{parentName:"p"},"rawBytesCount")," (this value is ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," in Spread model). Its storage location is in ",(0,o.kt)("inlineCode",{parentName:"p"},"Hash(prefix)"),", And this storage location will be exported to metadata.json for external apps to access. The storage location of each element is determined by the method of ",(0,o.kt)("inlineCode",{parentName:"p"},"Hash(prefix + index)"),", and the serialized data of the element is stored in this location."),(0,o.kt)("h3",{id:"packedstorablearray"},"PackedStorableArray"),(0,o.kt)("h4",{id:"usage-3"},"Usage"),(0,o.kt)("p",null,"To initialize an PackedStorableArray"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@contract\nclass Flipper {\n    @state flag: bool;\n    @state\n    aArr: PackedStorableArray<UInt128> = new PackedStorableArray<UInt128>(); \n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Fixed length array")," "),(0,o.kt)("p",null,"By default, the array is mutable length array. The default strucutre definition is SequenceDef that defines array as sequence and sepcify the object type in array. It also defines storage modes as pack/spread. In addition, for type array, it can pre-allocate some space by default. The type is Arraydef whith specification of capacity for pre-allocated space. len is set to 0 by default meaning no fixed length is specified.\nTo initialize a fixed length array, adding ",(0,o.kt)("inlineCode",{parentName:"p"},'@packed({ "capacity": 128 })')," decorator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'@contract\nclass Flipper {\n    @state flag: bool;\n\n    @state\n    @packed({ "capacity": 128 })\n    packeArr: PackedStorableArray<UInt128> = new PackedStorableArray<UInt128>();\n}\n')),(0,o.kt)("h4",{id:"implementation-3"},"Implementation"),(0,o.kt)("p",null,"The storage structure of ",(0,o.kt)("inlineCode",{parentName:"p"},"PackedStorableArray")," is as follows:\n",(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/2844215/120952315-5cff3280-c77d-11eb-9b64-6bab108a7249.png",alt:"PackedStorableArray"})),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ArrayEntry")," stores the number of elements in this Array ",(0,o.kt)("inlineCode",{parentName:"p"},"size")," and the number of bytes after serialization ",(0,o.kt)("inlineCode",{parentName:"p"},"rawBytesCount"),". In this storage mode, all elements are stored under the same address ",(0,o.kt)("inlineCode",{parentName:"p"},'Hash(prefix + ".values ")'),"."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Composite object"),(0,o.kt)("inlineCode",{parentName:"li"},"Composite object")," is a serializable class, that is, a class that implements the ",(0,o.kt)("inlineCode",{parentName:"li"},"Codec")," interface, which can be stored on the chain. For example, the following class:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'class EmbedObj implements Codec {\n\n   a: i8;\n   b: string;\n   c: u128;\n\n   constructor(a: i8 = 0, b: string = "", c: u128 = u128.Zero) {\n     this.a = a;\n     this.b = b;\n     this.c = c;\n   }\n\n   toU8a(): u8[] {\n     let bytes = new Array<u8>();\n     let aWrap = new Int8(this.a);\n     let bWrap = new ScaleString(this.b);\n     let cWrap = new UInt128(this.c);\n\n     bytes = bytes.concat(aWrap.toU8a())\n                 .concat(bWrap.toU8a())\n                 .concat(cWrap.toU8a());\n     return bytes;\n   }\n\n   encodedLength(): i32 {\n     let aWrap = new Int8(this.a);\n     let bWrap = new ScaleString(this.b);\n     let cWrap = new UInt128(this.c);\n\n     return aWrap.encodedLength() + bWrap.encodedLength() + cWrap.encodedLength();\n   }\n\n   populateFromBytes(bytes: u8[], index: i32 = 0): void {\n     let aWrap = new Int8();\n     aWrap.populateFromBytes(bytes, index);\n     index += aWrap.encodedLength();\n\n     let bWrap = new ScaleString();\n     bWrap.populateFromBytes(bytes, index);\n     index += bWrap.encodedLength();\n\n     let cWrap = new UInt128();\n     cWrap.populateFromBytes(bytes, index);\n\n     this.a = aWrap.unwrap();\n     this.b = bWrap.toString();\n     this.c = cWrap.unwrap();\n   }\n\n   eq(other: EmbedObj): bool {\n     return this.a == other.a && this.b == other.b && this.c == other.c;\n   }\n\n   notEq(other: EmbedObj): bool {\n     return !this.eq(other);\n   }\n }\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"EmbedObj")," can be used in the storage class annotated by ",(0,o.kt)("inlineCode",{parentName:"p"},"@storage")," to save a set of related information."))}u.isMDXComponent=!0},3714:function(e,a,t){a.Z=t.p+"assets/images/kv-5a3ca69d2a60f48ceb8437203a207ed6.svg"},7760:function(e,a,t){a.Z=t.p+"assets/images/packed-8ed31ead5287bfb05bbbeba4ac760941.svg"},3047:function(e,a,t){a.Z=t.p+"assets/images/spread-9135fbec75ec071a800a5c4687511f22.svg"}}]);