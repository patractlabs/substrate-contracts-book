(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{614:function(e,t,a){"use strict";a.r(t);var o=a(6),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"ink-edsl-basic-elements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ink-edsl-basic-elements"}},[e._v("#")]),e._v(" ink! eDSL basic elements")]),e._v(" "),a("p",[e._v("The elements of ink! eDSL design are actually relatively similar to those of Solidity, because the contract model structure of Contracts Pallet and the contract model of EVM are relatively similar.")]),e._v(" "),a("p",[e._v("Therefore, the design of ink! can find a lot of shadows similar to Solidity (the same applies to the Runtime design of Substrate). When describing the ink characteristics later, I will try to compare with the characteristics of Solidity, which is convenient for readers to understand.")]),e._v(" "),a("h2",{attrs:{id:"elements-of-edsl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#elements-of-edsl"}},[e._v("#")]),e._v(" Elements of eDSL")]),e._v(" "),a("p",[e._v("From the example provided by ink! documentation or ink!, the code shows that ink! also proposes the following three basic elements on the Contracts Pallet model:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("constructor")]),e._v("/"),a("code",[e._v("message")])]),e._v(" "),a("li",[a("code",[e._v("storage")])]),e._v(" "),a("li",[a("code",[e._v("event")])])]),e._v(" "),a("p",[e._v("However, due to the design relationship of the Rust process macro, you can see that ink! First requires a contract to be under a "),a("code",[e._v("mod")]),e._v(", and add the "),a("code",[e._v("#[ink::contract]")]),e._v(" macro to this "),a("code",[e._v("mod")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#[ink::contract]\nmod erc20 {\n    // ...\n}\n")])])]),a("p",[e._v("In this way, it is equivalent to telling ink! What is in this mod is to be processed according to the eDSL of ink.")]),e._v(" "),a("h3",{attrs:{id:"ink-contract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ink-contract"}},[e._v("#")]),e._v(" "),a("code",[e._v("#[ink::contract]")])]),e._v(" "),a("p",[e._v("Therefore, when you encounter the macro "),a("code",[e._v("#[ink::contract]")]),e._v(', it appears that this is the "contract part" identified by ink!. Therefore, we can see that many imports of '),a("code",[e._v("use xxx")]),e._v(" will be placed under the scope of "),a("code",[e._v("mod")]),e._v(" in "),a("code",[e._v("#[ink::contract]")]),e._v(".")]),e._v(" "),a("p",[e._v("And the current ink! design is that, under a "),a("code",[e._v("crate")]),e._v(" package, only one "),a("code",[e._v("#[ink::contract]")]),e._v(" can appear, so it means that ink! thinks that the dimension of a contract is based on rust's "),a("code",[e._v("crate")]),e._v(", that is If in the same "),a("code",[e._v("crate")]),e._v(", whether in the same file (for example, under "),a("code",[e._v("lib.rs")]),e._v(") or in different files, more than two are defined by "),a("code",[e._v("#[ink::contract]")]),e._v(" The "),a("code",[e._v("mod")]),e._v(", for example:")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#[ink::contract]\nmod erc20 {\n    // ...\n}\n\n#[ink::contract]\nmod another_define {\n    // ...\n}\n")])])]),a("p",[e._v("Analogous to solidity:")]),e._v(" "),a("div",{staticClass:"language-solidity,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// a.sol defines multiple `contract` in the same file\ncontract A {\n\n}\ncontract B {\n\n}\n")])])]),a("p",[e._v("Then in the compilation of ink!, this situation will be considered illegal.")]),e._v(" "),a("p",[e._v("Of course, as opposed to this, as long as there is only one "),a("code",[e._v("mod")]),e._v(" modified by "),a("code",[e._v("#[ink::contract]")]),e._v(" in the current "),a("code",[e._v("crate")]),e._v(", other "),a("code",[e._v("mod")]),e._v("s should be used normally, so the contract modified by ink! "),a("code",[e._v("crate")]),e._v(" can still do a good job of code isolation, enhance readability and maintainability**. This ability is important for "),a("strong",[e._v("maintaining large and complex contracts")]),e._v(", such as:")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#[ink::contract]\nmod erc20 {\n    use crete::another_define::*;\n}\n\nmod another_define {\n    // ...\n}\n")])])]),a("p",[e._v("For example, the following example:")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("mod fxck {\n    use crate::erc20::Erc20;\n    use ::ink_lang::Env; // Note that `ink_lang::Env` needs to be introduced here\n    impl Erc20 {\n        pub fn tmp(&self) {\n            self.env().caller(); // \n        }\n    }\n}\n\n#[ink::contract]\nmod erc20 {\n    #[ink(storage)]\n    pub struct Erc20 {...}\n\n    impl Erc20 {\n        #[ink(constructor)]\n        pub fn new(initial_supply: Balance) -> Self {...}\n        #[ink(message)]\n        pub fn transfer(&mut self, initial_supply: Balance) -> Self {\n            self.tmp(); // call methods defined in other `mod`\n        }\n    }\n}\n")])])]),a("p",[e._v("This model can achieve some code isolation that cannot be done under Solidity, and enhance maintainability. (Because Solidity's library can only be used for pure function calculations)")]),e._v(" "),a("p",[e._v("In summary, under the ink! system:")]),e._v(" "),a("ul",[a("li",[e._v("A contract is in a "),a("code",[e._v("crate")]),e._v(" unit, and only one "),a("code",[e._v("#[ink::contract]")]),e._v(" definition can appear in a "),a("code",[e._v("crate")]),e._v(";")]),e._v(" "),a("li",[a("code",[e._v("#[ink::contract]")]),e._v(" modified "),a("code",[e._v("mod")]),e._v(" represents the content of the contract, and also represents "),a("strong",[e._v("the basic elements of the contract must be defined under this "),a("code",[e._v("mod")])]),e._v(";")]),e._v(" "),a("li",[e._v("All parts other than "),a("code",[e._v("mod")]),e._v(" modified by "),a("code",[e._v("#[ink::contract]")]),e._v(" (other "),a("code",[e._v("mod")]),e._v(", functions, types) follow the rules of rust, and good code isolation can be done to improve maintainability;")]),e._v(" "),a("li",[e._v("In practice, the "),a("code",[e._v("mod")]),e._v(" modified by "),a("code",[e._v("#[ink::contract]")]),e._v(" can be used as the entry point of the contract, and the implemented logic can be distributed to other "),a("code",[e._v("mod")]),e._v("s.")])]),e._v(" "),a("p",[e._v('The following uses "contract mod" to indicate a '),a("code",[e._v("mod")]),e._v(" modified by "),a("code",[e._v("#[ink::contract]")])]),e._v(" "),a("h3",{attrs:{id:"storage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#storage"}},[e._v("#")]),e._v(" "),a("code",[e._v("storage")])]),e._v(" "),a("p",[e._v("In the contract mod, a structure must be defined, and this structure is modified by "),a("code",[e._v("#[ink(storage)]")]),e._v(", indicating that the storage of the contract is defined.")]),e._v(" "),a("p",[e._v("At the same time, this structure definition modified by "),a("code",[e._v("#[ink(storage)]")]),e._v(" is also regarded as an operable contract entity**, so all contract-related resources, types, and operations will be ** and this structure The body is bound together**. When the contract calls the contract, the type of the called contract is also represented by this structure.")]),e._v(" "),a("p",[e._v("Therefore, this structure can be understood as a contract entity.")]),e._v(" "),a("blockquote",[a("p",[e._v("Although the part that modifies "),a("code",[e._v("mod")]),e._v(" is the contract, because "),a("code",[e._v("mod")]),e._v(" can only represent the scope in rust, so for practical use, use the structure modified by "),a("code",[e._v("#[ink(storage)]")]),e._v(" to indicate that it can be operated Contract entity.")]),e._v(" "),a("p",[e._v("In this context, the "),a("code",[e._v("mod")]),e._v(" modified by "),a("code",[e._v("#[ink::contract]")]),e._v(' can be understood as the concept of "opening the contract domain", while the '),a("code",[e._v("stuct")]),e._v(" modified by "),a("code",[e._v("#[ink(storage)]")]),e._v(" It is a contract under this contract domain.")])]),e._v(" "),a("p",[e._v("Here, the concept of storage defined by ink! is consistent with the concept of “storage” defined in Solidity, which means that the attributes defined here are the final state written to the "),a("strong",[e._v("chain")]),e._v(". The purpose of writing all contract logic is to modify the state defined here.")]),e._v(" "),a("p",[e._v("However, because the current ink! uses a structure to carry the contract state, all the states of the current contract can only be defined in this structure. When the contract is designed to be relatively large and complicated, the maintainability here will decrease.")]),e._v(" "),a("p",[e._v("An example of defining storage is as follows:")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#[ink(storage)]\npub struct Erc20 {\n    /// Total token supply.\n    total_supply: Lazy<Balance>,\n    /// Mapping from owner to number of owned token.\n    balances: StorageHashMap<AccountId, Balance>,\n    /// Mapping of the token amount which an account is allowed to withdraw\n    /// from another account.\n    allowances: StorageHashMap<(AccountId, AccountId), Balance>,\n}\n")])])]),a("p",[e._v("Structures modified by "),a("code",[e._v("#[ink(storage)]")]),e._v(" are collectively referred to as contract structures in the following text.")]),e._v(" "),a("p",[e._v("Here are a few features that need to be paid special attention to:")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("The type of the attribute defined in the contract structure must be a type that has implemented "),a("code",[e._v("SpreadLayout")]),e._v(" (or more accurately, a type that implements "),a("code",[e._v("PackedLayout")]),e._v(", because "),a("code",[e._v("PackedLayout")]),e._v(" is inherited from the definition of "),a("code",[e._v("SpreadLayout")]),e._v("):")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/// Types that can be stored to and loaded from the contract storage.\npub trait SpreadLayout {\n}\n")])])]),a("blockquote",[a("p",[e._v('The reason why only the type that implements this trait can be used here is very simple, because storage is different from the general type, it must contain the information of the "chain" in it, so the contract implementation of different chains must have a part for processing The storage (that is, state) allocation problem in the contract.')]),e._v(" "),a("p",[e._v("For example, during the compilation process of Solidity, the key of the state is actually assigned according to the upper and lower order defined by the storage in the contract. If the "),a("code",[e._v("SpredLayout")]),e._v(" or "),a("code",[e._v("PackedLayout")]),e._v(" type has been implemented here, there will be an approximate process for state allocation.")])]),e._v(" "),a("p",[e._v("Ink! has done basic implementations for general types, but "),a("strong",[e._v("for collection types ("),a("code",[e._v("Vec")]),e._v(", "),a("code",[e._v("HashMap")]),e._v(", etc.), because the state of the contract needs to hook the process of reading and writing")]),e._v(", it cannot be implemented for collection types This "),a("code",[e._v("trait")]),e._v(". Therefore, in ink!, all the commonly used collection types in the standard library have been re-implemented, and the attribute types of the structure modified by "),a("code",[e._v("#[ink(storage)]")]),e._v(" must be used if the collection type is used. The collection type provided by ink!**.")]),e._v(" "),a("blockquote",[a("p",[e._v("Since Solidity is relatively rudimentary, the storage map defined by Solidity cannot be traversed. (Caused by a defect in the Solidity design)")]),e._v(" "),a("p",[e._v("ink! has done a lot of things when designing this piece, so the collection types "),a("code",[e._v("Vec")]),e._v(", "),a("code",[e._v("BTreeMap")]),e._v(", "),a("code",[e._v("HashMap")]),e._v(" and so on provided by ink! are all "),a("strong",[e._v("traversable")]),e._v(". Compared with the functions that Solidity can achieve, it is a considerable improvement.")])])]),e._v(" "),a("li",[a("p",[e._v("Even based on the above design, the nested collection type is still difficult to implement (because the state structure of Substrate uses the k/v model). Therefore, in the design, we can only try to avoid nested collection types. If you must nest the collection type, you need to flatten the nesting level, merge the second-level key and the first-level key together, and use tuples instead (equivalent to "),a("code",[e._v("double_map")]),e._v(" in Substrate Runtime)")]),e._v(" "),a("div",{staticClass:"language-Solidity,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// solidity\ncontract A {\n    mapping (uint => mapping (uint => uint))\n}\n")])])]),a("p",[e._v("The similar code in ink! should be:")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#[ink(storage)]\npub struct Erc20 {\n    // Note that the key here uses the tuple `(AccountId, AccountId)`\n    allowances: StorageHashMap<(AccountId, AccountId), Balance>,\n}\n")])])])]),e._v(" "),a("li",[a("p",[e._v("A model of "),a("code",[e._v("Lazy")]),e._v(" is provided in storage, which allows developers to use "),a("code",[e._v("Lazy")]),e._v(" to wrap a type so that the state data can be loaded when it is used:")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/// A lazy storage entity.\n///\n/// This loads its value from storage upon first use.\n///\n/// # Note\n///\n/// Use this if the storage field doesn't need to be loaded in some or most cases.\n#[derive(Debug)]\npub struct Lazy<T>\nwhere\n    T: SpreadLayout,\n{\n    cell: LazyCell<T>,\n}\n")])])]),a("p",[e._v("How to use:")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#[ink(storage)]\npub struct Erc20 {\n    /// Total token supply.\n    total_supply: Lazy<Balance>,\n}\n")])])])])]),e._v(" "),a("h3",{attrs:{id:"constructor-message"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constructor-message"}},[e._v("#")]),e._v(" "),a("code",[e._v("constructor")]),e._v("/"),a("code",[e._v("message")])]),e._v(" "),a("p",[a("code",[e._v("constructor")]),e._v("/"),a("code",[e._v("message")]),e._v(" is the entry function that triggers the contract state change. In other words, "),a("code",[e._v("constructor")]),e._v("/"),a("code",[e._v("message")]),e._v(" is the state transition function of the contract state.")]),e._v(" "),a("p",[a("code",[e._v("constructor")]),e._v("/"),a("code",[e._v("message")]),e._v(" can only modify the methods of the contract structure**, and cannot be used to modify the methods of other structures or other pure functions.")]),e._v(" "),a("p",[e._v("In the contract mod, there is at least one method for the contract structure modified by "),a("code",[e._v("constructor")]),e._v(" and "),a("code",[e._v("message")]),e._v(". If there are less than one respectively, it will cause compilation error.")]),e._v(" "),a("p",[e._v("among them:")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("constructor")]),e._v(" corresponds to the constructor in the Solidity contract. When the contract is deployed (in Contracts Pallet currently represents the process of doing "),a("code",[e._v("instantiate")]),e._v(" from the uploaded contract code), a call to the corresponding constructor will be triggered.")]),e._v(" "),a("blockquote",[a("p",[e._v("It needs to be emphasized here that the call of the constructor and the instantiation of the contract are two conceptual things. This process is "),a("strong",[e._v("not atomic")]),e._v(" in the coordination process of ink! and Contracts Pallet. Therefore, the constructor may not be called, but the contract address will be generated, and the contract instance for which the constructor has not been called can be called normally.")]),e._v(" "),a("p",[e._v("A typical example is the wrong code parameter passed in when calling "),a("code",[e._v("instantiate")]),e._v(".")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("message")]),e._v(" corresponds to the call methods such as "),a("code",[e._v("public")]),e._v("/"),a("code",[e._v("external")]),e._v(" in the Solidity contract. Due to the characteristics of Rust's mutable/immutable methods, "),a("code",[e._v("message")]),e._v(" uses the ** feature to indicate whether this method will modify the state of the contract**.")]),e._v(" "),a("p",[e._v("So if the method of "),a("code",[e._v("message")]),e._v(" modification is")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Note that the first parameter of the method is `&self`\n#[ink(message)]\npub fn total_supply(&self) -> Balance {\n    *self.total_supply\n}\n")])])]),a("p",[e._v("It means that the call of this method will not modify the state (controlled by the rust syntax), which is consistent with Ethereum. This type of method is mostly used for rpc calls to return the storage of a contract or return some storage-based calculation results.")]),e._v(" "),a("p",[e._v("If the modification is")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Note that the first parameter of the method is `&mut self`\npub fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()> {\n    let from = self.env().caller();\n    self.transfer_from_to(from, to, value)\n}\n")])])]),a("p",[e._v("It means that the call of this method will modify the state, so if this method is called and executed in the form of a packaged transaction call, it will trigger a state change. If it is called by rpc, it means that the simulation has been executed once.")]),e._v(" "),a("p",[e._v("At the same time, metadata.json (corresponding to the ABI of Solidity) will be generated after the contract is compiled. In this metadata, there will be a "),a("code",[e._v("mutates")]),e._v(" field for the message part to indicate whether the method is variable.")])])]),e._v(" "),a("h4",{attrs:{id:"message-s-selector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#message-s-selector"}},[e._v("#")]),e._v(" message's "),a("code",[e._v("selector")])]),e._v(" "),a("p",[e._v("For the generation of the ABI of the contract method, Solidity uses the method name plus the parameter type as a function signature to piece together into a string and then make a hash to take the first 4 bytes.")]),e._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('call = "func_name(param1_type,param2_type,...)"\nbytes4(keccak256(call), a, b)\n')])])]),a("p",[e._v("In ink!, this concept that allows contracts to distinguish call trigger points is called "),a("code",[e._v("selector")]),e._v(".")]),e._v(" "),a("p",[e._v("Since rust does not support function overloading, a relatively simple design is adopted in ink!, which directly hashes the string of the function name and takes the first 4 bytes:")]),e._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('call = "func_name"\nblake2_512(call)[0..4]\n')])])]),a("blockquote",[a("p",[e._v("The author believes that this design has caused problems with other contract language designs. Because rust does not support overloading, it does not mean that other languages ​​do not support overloading. After Solang compiles Solidity to Wasm, if it wants to be compatible with ink!'s metadata, problems will arise when calling each other.")])]),e._v(" "),a("p",[e._v("On the other hand, "),a("code",[e._v("selector")]),e._v(" can also run the contract developer's own definition")]),e._v(" "),a("div",{staticClass:"language-rust,json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('#[ink(message, selector = "0xCAFEBABE")]\npub fn was_it_ten(&self) -> bool {...}\n')])])]),a("h4",{attrs:{id:"message-of-payable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#message-of-payable"}},[e._v("#")]),e._v(" message of "),a("code",[e._v("payable")])]),e._v(" "),a("p",[e._v("There is a "),a("code",[e._v("payable")]),e._v(" modifier for the method in Solidity, which is used to indicate that the method can accept a certain amount of money.")]),e._v(" "),a("p",[e._v("Therefore, "),a("code",[e._v("payable")]),e._v(" is also provided in ink! to indicate whether it is possible to transfer a certain amount of "),a("strong",[e._v("local currency")]),e._v(" while calling this method. In the current design of ink!, if a non-payable message is called with an amount at the same time, the calling process will be regarded as an error.")]),e._v(" "),a("p",[e._v("By default, "),a("code",[e._v("paybale")]),e._v(" is considered to be "),a("code",[e._v("false")]),e._v(", and it is "),a("code",[e._v("true")]),e._v(" only when the contract developer specifies "),a("code",[e._v("payable")]),e._v(".")]),e._v(" "),a("p",[e._v("The case for specifying a message to be callable is:")]),e._v(" "),a("div",{staticClass:"language-rust,json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#[ink(message, playable)]\npub fn was_it_ten(&self) -> bool {...}\n")])])]),a("p",[e._v("On the other hand, in metadata, there will be a "),a("code",[e._v("payable")]),e._v(" field for the message part to indicate whether this method requires payment.")]),e._v(" "),a("h3",{attrs:{id:"event"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event"}},[e._v("#")]),e._v(" "),a("code",[e._v("event")])]),e._v(" "),a("p",[e._v("The concept of event is not necessary in the state machine model. However, because "),a("strong",[e._v("blockchain is an asynchronous system")]),e._v(", after sending a transaction to trigger a state change, the result of the change cannot be immediately known, and it can only rely on monitoring an element to determine the execution result. "),a("code",[e._v("event")]),e._v(" is an element designed at the stage of Solidity, and this design is also inherited from Substrate Runtime and ink!.")]),e._v(" "),a("blockquote",[a("p",[e._v("I don't think event is a good design. In theory, there are other better ways, or variants of event. Event will cause abuse by developers to a certain extent.")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("event")]),e._v(" of ink! in Contracts Pallet finally prints the event defined by the contract to the event of the chain through the "),a("code",[e._v("host function")]),e._v(".")]),e._v(" "),a("p",[e._v("The event design of ink! is nothing special compared to Solidity, but because it is a contract running in Wasm, the event of the printing contract needs to interact with the chain through the host function, so the calling method needs to be passed through. env()` to call.")]),e._v(" "),a("div",{staticClass:"language-rust,ignore extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Self::env().emit_event(...);\n// or use\nself.env().emit_event(...);\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);