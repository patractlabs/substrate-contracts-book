"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[944],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1946:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return m}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={},s="Report for Ask! v0.1",p={unversionedId:"ask/reports/v0.1Report",id:"ask/reports/v0.1Report",isDocsHomePage:!1,title:"Report for Ask! v0.1",description:"Ten weeks ago, Patract Hub submitted the Treasury Proposal #66 for Ask! v0.1. The goal of this proposal is to provide a contract programming framework based on AssemblyScript (aka AS). In this proposal, we promise to complete the following functions in the v0.1:",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/ask/reports/v0.1Report.md",sourceDirName:"ask/reports",slug:"/ask/reports/v0.1Report",permalink:"/en/ask/reports/v0.1Report",editUrl:"https://github.com/patractlabs/substrate-contracts-book/docs/ask/reports/v0.1Report.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Report for Ask\uff01proposals",permalink:"/en/ask/reports"},next:{title:"v0.2Report",permalink:"/en/ask/reports/v0.2Report"}},c=[{value:"Design and Implementation of v0.1",id:"design-and-implementation-of-v01",children:[]},{value:"How to use Ask! v0.1",id:"how-to-use-ask-v01",children:[]},{value:"About Ask! v0.2",id:"about-ask-v02",children:[]}],d={toc:c};function m(e){var t=e.components,l=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"report-for-ask-v01"},"Report for Ask! v0.1"),(0,o.kt)("p",null,"Ten weeks ago, ",(0,o.kt)("a",{parentName:"p",href:"https://patract.io"},"Patract Hub")," submitted the ",(0,o.kt)("a",{parentName:"p",href:"https://kusama.polkassembly.io/treasury/66"},"Treasury Proposal #66")," for Ask! v0.1. The goal of this proposal is to provide a contract programming framework based on AssemblyScript (aka AS). In this proposal, we promise to complete the following functions in the v0.1:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"v0.1 Target: being able to use AS to write contracts that can run on FRAME Contract Pallet")),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"Define the meaning of ",(0,o.kt)("inlineCode",{parentName:"li"},"@contract"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"@storage"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"@constructor"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"@message")," annotations and code generation logic used in the contract."),(0,o.kt)("li",{parentName:"ul"},"Encapsulate the runtime API and provide components for writing contracts: ",(0,o.kt)("inlineCode",{parentName:"li"},"AccountId"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Block"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Crypto"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Gas"),", etc."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PreProcessor")," can parse the four annotations ",(0,o.kt)("inlineCode",{parentName:"li"},"@contract"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"@storage"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"@message"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"@constructor"),", and generate the corresponding code."),(0,o.kt)("li",{parentName:"ul"},"PreProcessor can generate the content of ",(0,o.kt)("inlineCode",{parentName:"li"},"metadata.json")," with the above four annotations."),(0,o.kt)("li",{parentName:"ul"},"The Ask! contract can run on FRAME Contract Pallet."))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"v0.1 Verification: GitHub source code & contract example")),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"The basic data types can be stored and called in the contract: ",(0,o.kt)("inlineCode",{parentName:"li"},"u8"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"i8"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"u16"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"i16"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"u32"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"i32"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"u64"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"i64"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"u128"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"i128 "),", ",(0,o.kt)("inlineCode",{parentName:"li"},"string"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"bool"),", without collection types."),(0,o.kt)("li",{parentName:"ul"},"Ability to define callable ",(0,o.kt)("inlineCode",{parentName:"li"},"messages"),"."),(0,o.kt)("li",{parentName:"ul"},"Able to generate a full format ",(0,o.kt)("inlineCode",{parentName:"li"},"metadata.json")," file."),(0,o.kt)("li",{parentName:"ul"},"Able to generate correct Wasm code."))),(0,o.kt)("p",null,"So far, we have implemented all the content of the proposal except the array&map data type access function. Because array&map involves the rules for generating metadata.json in the scale-info project, but this generation has no public specification documents for reference in ink!, so the support for array&map needs to be implemented later. We had contacted Robin from ink!, and this issue is on his agenda."),(0,o.kt)("p",null,"The source code we have implemented is in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/ask"},"Ask!")," repo, and the example contract is in ","[examples]","(",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/ask/tree/master/"},"https://github.com/patractlabs/ask/tree/master/")," examples) directory."),(0,o.kt)("h2",{id:"design-and-implementation-of-v01"},"Design and Implementation of v0.1"),(0,o.kt)("p",null,"Ask!'s design starting point is to use annotations to simplify the contract writing process and separate the business logic of the contract from the contract runtime; at the same time, annotations and their sub-annotations are also used to generate the metadata.json file of the contract."),(0,o.kt)("p",null,"At the contract runtime layer, Ask! provides objects such as ",(0,o.kt)("inlineCode",{parentName:"p"},"AccountId"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Block"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Crypto"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Gas"),". These objects encapsulate the underlying logic and API calls, and provide upper-level semantics and methods for writing contracts and preprocessors. "),(0,o.kt)("p",null,"At the Preprocessor level, it needs to compile the written contract into the target contract WebAssembly bytecode."),(0,o.kt)("p",null,"From the perspective of the compiler, the work of Preprocessor is divided into the following steps (the code used in the example is selected from the following ",(0,o.kt)("inlineCode",{parentName:"p"},"How to use Ask! v0.1"),"):"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Use ",(0,o.kt)("inlineCode",{parentName:"li"},"asc")," to compile the contract into a Program object to obtain code syntax information.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The code is a program written in accordance with the contract structure, so the syntax information of the program can be obtained through compilation.")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"After the Program is compiled, the semantic information of the program can be obtained. By analyzing the annotations in the semantic information, the points in the contract that require code injection and the structural information of the contract can be obtained.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@contract")," annotation indicates that the class is a contract entry."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@storage")," annotation indicates that the class object is a contract storage object."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@message")," annotation indicates that this method is a contract method that can be called externally."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@constructor")," annotation indicates that this is a contract construction method, which can instantiate the contract by setting different parameters.")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"For different annotations, obtain the relevant structural information that needs to generate the target contract code.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"When a class contains the annotation ",(0,o.kt)("inlineCode",{parentName:"p"},"@contract"),", such as:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  @contract\n  class SolarSystem {\n  }\n")))),(0,o.kt)("p",null,"Then the method of getting annotation as ",(0,o.kt)("inlineCode",{parentName:"p"},"@constructor"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'  @constructor\n  default(name: string = "Earth", radius: u32 = 6300, isdwarf: boolean = false): void {\n      this.stored.name = name;\n      this.stored.radius = radius;\n      this.stored.isdwarf = isdwarf;\n  }\n')),(0,o.kt)("p",null,"Through semantic information, the ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionPrototype")," information of the default function can be obtained, and the description information ",(0,o.kt)("inlineCode",{parentName:"p"},"declaration")," of the Function can be obtained by parsing the ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionPrototype")," object. Then get the function information of ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionDef")," such as methodName, method parameter list and return value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'  export class FunctionDef {  \n      private funcProto: FunctionPrototype;\n      methodName: string = "";\n           parameters: ParameterNodeDef[] = new Array();\n       isReturnable: boolean = false;\n       returnType: NamedTypeNodeDef | undefined;\n  }\n')),(0,o.kt)("p",null,"According to the exported ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionDef")," information, the main.tpl (see below) is rendered through ",(0,o.kt)("inlineCode",{parentName:"p"},"Handlebar")," to generate the deploy function. In the way of templates, you can easily adjust, deploy function structure and implementation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  export function deploy(): i32 {\n    let {{contract.instanceName}} = new {{contract.className}}();\n     {{#each contract.cntrFuncDefs}}\n      const {{methodName}}Selector: u8[] = {{#selector methodName}}{{u8Arr}}{{/selector}};\n            if (msg.isSelector({{methodName}}Selector)) {\n        {{#neq parameters.length 0}}\n        const fnParameters = new FnParameters(msg.data);\n         {{/neq}}\n      {{#each parameters}}\n      let p{{_index}} = fnParameters.get<{{type.codecType}}>();\n      {{/each}}\n      {{../contract.instanceName}}.{{methodName}}({{#joinParams parameters}}{{/joinParams}}{{ctrDefaultVals}});\n      }\n    {{/each}}\n    return 0;\n  }\n")),(0,o.kt)("p",null,"The deploy method obtained after rendering:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  export function deploy(): i32 {\n    let solarSystem = new SolarSystem();\n\n   const defaultSelector: u8[] = [0xed,0x4b,0x9d,0x1b];\n    if (msg.isSelector(defaultSelector)) {\n      const fnParameters = new FnParameters(msg.data);\n      let p0 = fnParameters.get<ScaleString>();\n      let p1 = fnParameters.get<UInt32>();\n      let p2 = fnParameters.get<Bool>();\n      solarSystem.default(p0.toString(),p1.unwrap(),p2.unwrap());\n    }\n    return 0;\n  }\n")),(0,o.kt)("p",null,"In the same way, to obtain the method annotated as ",(0,o.kt)("inlineCode",{parentName:"p"},"@message"),", obtain the method name, method parameter list and return value and other information by analyzing the ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionPrototype"),", and generate the call distribution logic of the ",(0,o.kt)("inlineCode",{parentName:"p"},"call")," entry function."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"When a class is marked with ",(0,o.kt)("inlineCode",{parentName:"p"},"@storage"),". Need to get the field information in the class. By analyzing the ",(0,o.kt)("inlineCode",{parentName:"p"},"FieldPrototype")," to obtain the field parameter name, field type and other information ",(0,o.kt)("inlineCode",{parentName:"p"},"FieldDef"),", where storeKey is used to store the object key. The key will be generated by the blake2 hash."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'  export class FieldDef {\n     protected fieldPrototype: FieldPrototype;\n      layout: LayoutDef = new LayoutDef();\n      name: string = "";\n      type: NamedTypeNodeDef | null = null;\n      storeKey: string = "";\n      varName: string = "";\n      path: string = "";\n  }\n')))),(0,o.kt)("p",null,"The field needs to be packaged in this place. The original is TypeScript basic types, i8/u8, etc. need to be packaged into IInt8, Uint8 etc in codec, making it convenient to serialize and deserialize when storing and reading. Then generate getter/setter methods that meet the read and write requirements for each field. The same is generated by the ",(0,o.kt)("inlineCode",{parentName:"p"},"Handlebar")," rendering template. The template is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"    class {{className}} {\n      {{#each fields}}\n      private {{varName}}: {{type.codecType}} | null = null;\n        {{/each}}\n        {{#each fields}}\n        get {{name}}(): {{type.originalType}} {\n          if (this.{{varName}} === null) {\n            const st = new Storage<{{type.codecType}}>(\"{{storeKey}}\");\n            this.{{varName}} = st.load();\n          }\n          {{#eq type.codecType 'ScaleString'}}\n          return this.{{varName}}!.toString();\n          {{/eq}}\n          {{#neq type.codecType 'ScaleString'}}\n            return this.{{varName}}!.unwrap();\n          {{/neq}}\n        }\n        set {{name}}(v: {{type.originalType}}) {\n          this.{{varName}} = new {{type.codecType}}(v);\n          const st = new Storage<{{type.codecType}}>(\"{{storeKey}}\");\n          st.store(this.{{varName}}!);\n        }\n        {{/each}}\n      }\n")),(0,o.kt)("p",null,"The generated code\uff1a "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'    class Planets {\n        private _name: ScaleString | null = null;\n        private _radius: UInt32 | null = null;\n      private _isdwarf: Bool | null = null;\n        get name(): string {\n          if (this._name === null) {\n            const st = new Storage<ScaleString>("Planetsname");\n            this._name = st.load();\n          }\n        return this._name!.toString();\n        }\n        set name(v: string) {\n          this._name = new ScaleString(v);\n          const st = new Storage<ScaleString>("Planetsname");\n          st.store(this._name!);\n        }\n        get radius(): u32 {\n          if (this._radius === null) {\n            const st = new Storage<UInt32>("Planetsradius");\n            this._radius = st.load();\n          }\n            return this._radius!.unwrap();\n        }\n        set radius(v: u32) {\n          this._radius = new UInt32(v);\n          const st = new Storage<UInt32>("Planetsradius");\n          st.store(this._radius!);\n        }\n        get isdwarf(): boolean {\n          if (this._isdwarf === null) {\n            const st = new Storage<Bool>("Planetsisdwarf");\n            this._isdwarf = st.load();\n          }\n        return this._isdwarf!.unwrap();\n        }\n        set isdwarf(v: boolean) {\n          this._isdwarf = new Bool(v);\n          const st = new Storage<Bool>("Planetsisdwarf");\n          st.store(this._isdwarf!);\n        }\n      }\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Expand all the annotations to generate the final contract file for compilation.")),(0,o.kt)("ol",{start:4},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"According to the contract structure information, the metadata.json file is generated through the template engine"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"According to different contract structure information, generate the code of each section in metadata.json. Generate the information of the ",(0,o.kt)("inlineCode",{parentName:"li"},"storage")," field in metadata.json through the ",(0,o.kt)("inlineCode",{parentName:"li"},"@storage")," object information; generate the information of the ",(0,o.kt)("inlineCode",{parentName:"li"},"messages")," field through ",(0,o.kt)("inlineCode",{parentName:"li"},"@message"),"; Generate the information of the ",(0,o.kt)("inlineCode",{parentName:"li"},"constructor")," field through ",(0,o.kt)("inlineCode",{parentName:"li"},"@constructor"),". The code generation logic is completed by the ",(0,o.kt)("inlineCode",{parentName:"li"},"Handlebar")," template engine. When the target code structure needs to be adjusted, you only need to adjust the template."))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Compile the expanded contract file to generate the contract wasm bytecode."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Use ",(0,o.kt)("inlineCode",{parentName:"li"},"asc")," to compile the expanded target code. Compile command: ",(0,o.kt)("inlineCode",{parentName:"li"},"asc --importMemory --initialMemory 2 --maximumMemory 16 --noExportMemory --runtime half --use abort= extension.ts -O2 -b target .wasm "),", get the bytecode that can be run on the wasm virtual machine.")))),(0,o.kt)("p",null,"From the perspective of the contract developer, starting from calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"ask")," command, the workflow of the Preprocessor is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"                               +-------------+\n                           +--\x3e+metadata.json|\n                           |   +-------------+\n                           |\n   +-----------------+     |\n   | ./ask sample.ts +-----|\n   +-----------------+\n                           |   +------------+       +------------+\n                           +--\x3e+extension.ts+-------\x3etarget.wasm |\n                               +------------+       +------------+\n")),(0,o.kt)("p",null,"Below we will use an example to illustrate how to write a contract using Ask! v0.1."),(0,o.kt)("h2",{id:"how-to-use-ask-v01"},"How to use Ask! v0.1"),(0,o.kt)("p",null,"The Ask! project is not yet released, so we need to clone the source code locally.",(0,o.kt)("inlineCode",{parentName:"p"},"git clone https://github.com/patractlabs/ask")),(0,o.kt)("p",null,"In the project, we have established two projects ",(0,o.kt)("inlineCode",{parentName:"p"},"flipper")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"increment")," in the examples directory for your reference. Below we will use a new project ",(0,o.kt)("inlineCode",{parentName:"p"},"solar")," to illustrate how to use Ask!, the complete source code is located ",(0,o.kt)("inlineCode",{parentName:"p"},"example/solar/")," directory."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Write the contract")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Define what storage needs to store: The ",(0,o.kt)("inlineCode",{parentName:"p"},"@storage")," annotation is used in the class to indicate that the data members defined in this class are state variables, and the read and write operations of these data members need to be persistently stored."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@storage\nclass Planets {\n    name: string;\n    radius: u32;\n    isdwarf: boolean;\n}\n")),(0,o.kt)("p",{parentName:"li"},"The above code defines a storage, which has three variables: ",(0,o.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"radius"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"isdwarf"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Write contract content"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@contract")," annotation is used in the class, which means that this class is the entry point of the contract. Ask! only supports a single contract entry point."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@constructor")," annotation is used in the method, which means that this method is only triggered when the contract transaction ",(0,o.kt)("inlineCode",{parentName:"li"},"instantiate")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"instantiate_with_code")," is called, and can be called to set some initialization parameters."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@message")," annotation is used in the method, which means that this method is called when calling the contract transaction ",(0,o.kt)("inlineCode",{parentName:"li"},"call"),".")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'@contract\nclass SolarSystem {\n    protected stored: Planets;\n\n    constructor() {\n        this.stored = new Planets();\n    }\n\n    @constructor\n    default(name: string = "Earth", radius: u32 = 6300, isdwarf: boolean = false): void {\n        this.stored.name = name;\n        this.stored.radius = radius;\n        this.stored.isdwarf = isdwarf;\n    }\n\n    @message\n    set(name: string, radius: u32, isdwarf: boolean): void {\n        if (this.stored.name != name) {\n            this.stored.name = name;\n            this.stored.radius = radius;\n            this.stored.isdwarf = isdwarf;\n        }\n    }\n\n    @message(mutates = false, selector = "0x0a0b0c0d")\n    getRadius(): u32 {\n        return this.stored.radius;\n    }\n}\n')))),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Compile the contract")),(0,o.kt)("p",null,"Compiling the contract needs to be carried out in the terminal environment. Open a terminal and enter the ask project directory. Before compiling the contract, you first need to install the compilation dependencies, execute the following command to install the dependent projects"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm install\n")),(0,o.kt)("p",null,"After the dependent project is installed, execute the following command to compile:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"./assembly/codegen/bin/ask examples/solar/solar.ts\n")),(0,o.kt)("p",null,"After successful compilation, files with the following structure will be generated in the ",(0,o.kt)("inlineCode",{parentName:"p"},"example/solar/")," directory:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},".\n\u251c\u2500\u2500 extension.ts\n\u251c\u2500\u2500 solar.ts\n\u2514\u2500\u2500 target\n    \u251c\u2500\u2500 metadata.json\n    \u2514\u2500\u2500 target.wasm\n")),(0,o.kt)("p",null,"Among them, the ",(0,o.kt)("inlineCode",{parentName:"p"},"extension.ts")," file is the file after all the annotations in the contract ",(0,o.kt)("inlineCode",{parentName:"p"},"solar.ts")," are expanded, and ",(0,o.kt)("inlineCode",{parentName:"p"},"target/metadata.json")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"target/target.wasm")," are the abi and wasm files generated by compilation."),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"Deployment and calling")),(0,o.kt)("p",null,"We deploy and test contract functions in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/europa"},"Europa")," sandbox environment, using ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/polkadot-js/apps"},"polkadot-js")," on the front end as an interactive interface. The test steps are as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"First, we follow the instructions of ",(0,o.kt)("inlineCode",{parentName:"p"},"Europa")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"plokadot-js")," to start nodes and services.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"In the contract interface of ",(0,o.kt)("inlineCode",{parentName:"p"},"polkadot-js"),", upload the ",(0,o.kt)("inlineCode",{parentName:"p"},"metadata.json")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"target.wasm")," files under ",(0,o.kt)("inlineCode",{parentName:"p"},"solar/target"),".\n",(0,o.kt)("img",{alt:"upload",src:n(6914).Z}))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Deploy the uploaded contract.\nAccording to the operation process, we deploy the ",(0,o.kt)("inlineCode",{parentName:"p"},"solar")," contract to the Europa node.\n",(0,o.kt)("img",{alt:"deploy",src:n(8225).Z}),"\nAfter successful deployment, you will get the following results:\n",(0,o.kt)("img",{alt:"deploy-result",src:n(8542).Z}))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Call the ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," method to set a new ",(0,o.kt)("inlineCode",{parentName:"p"},"radius")," value.\nAfter that, we call the ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," method, and set ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Mars"),", and set the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"radius")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"5200"),". After successful execution, the ",(0,o.kt)("inlineCode",{parentName:"p"},"getRadius")," method will return the new ",(0,o.kt)("inlineCode",{parentName:"p"},"radius")," value.\n",(0,o.kt)("img",{alt:"call",src:n(6340).Z})))),(0,o.kt)("p",null,"So far, we have completed the contract upload, deployment, and call operations, and got the expected results."),(0,o.kt)("h2",{id:"about-ask-v02"},"About Ask! v0.2"),(0,o.kt)("p",null,"As mentioned above, we have implemented everything in the proposal except array&map. At the same time, the v0.2 design has been completed, please refer to ","[Treasury proposal for Ask! v0.2]","(",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs"},"https://github.com/patractlabs")," /proposals/blob/main/%E6%8F%90%E6%A1%88/As-ink/v0.2ProposalCN.md)."))}m.isMDXComponent=!0},6340:function(e,t,n){t.Z=n.p+"assets/images/v0.1Report_call-0522ec5e1c7e3595bf175bde262c687d.png"},8225:function(e,t,n){t.Z=n.p+"assets/images/v0.1Report_deploy-6a869216383f482ab93715a8fb404a37.png"},8542:function(e,t,n){t.Z=n.p+"assets/images/v0.1Report_deploy_result-4a32a51752c61d41d1c0b513474079a1.png"},6914:function(e,t,n){t.Z=n.p+"assets/images/v0.1Report_upload-86777dd0394d319f57b0f4782cd31dff.png"}}]);