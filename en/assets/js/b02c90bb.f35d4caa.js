"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[7086],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||r;return n?o.createElement(h,i(i({ref:t},p),{},{components:n})):o.createElement(h,i({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3627:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],l={},s="Patract's proposal about Metis (ink! and Ask! Standard Library)",c={unversionedId:"metis/reports/M1Report",id:"metis/reports/M1Report",isDocsHomePage:!1,title:"Patract's proposal about Metis (ink! and Ask! Standard Library)",description:"Metis will be the Wasm contract standard library developed by Patract Labs. Patract Labs will work with community forces to formulate various Wasm contract standards, develop corresponding implementations of ink! and Ask! versions, and conduct audits by professional institutions.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/metis/reports/M1Report.md",sourceDirName:"metis/reports",slug:"/metis/reports/M1Report",permalink:"/substrate-contracts-book/en/metis/reports/M1Report",editUrl:"https://github.com/patractlabs/substrate-contracts-book/docs/metis/reports/M1Report.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Report for Metis proposals",permalink:"/substrate-contracts-book/en/metis/reports"},next:{title:"Carpo",permalink:"/substrate-contracts-book/en/carpo/introduction"}},p=[{value:"0. Motivation",id:"0-motivation",children:[]},{value:"1. Problem",id:"1-problem",children:[]},{value:"2. Contract Standard Library",id:"2-contract-standard-library",children:[]},{value:"3. ink! component",id:"3-ink-component",children:[]},{value:"4. Overall Roadmap",id:"4-overall-roadmap",children:[]},{value:"5. Detailed timeline of M1 (3 developers * 5 weeks)",id:"5-detailed-timeline-of-m1-3-developers--5-weeks",children:[]},{value:"6. How to verify M1",id:"6-how-to-verify-m1",children:[]}],m={toc:p};function u(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"patracts-proposal-about-metis-ink-and-ask-standard-library"},"Patract's proposal about Metis (ink! and Ask! Standard Library)"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis"},"Metis")," will be the Wasm contract standard library developed by Patract Labs. Patract Labs will work with community forces to formulate various Wasm contract standards, develop corresponding implementations of ink! and Ask! versions, and conduct audits by professional institutions."),(0,r.kt)("h2",{id:"0-motivation"},"0. Motivation"),(0,r.kt)("p",null,"We believe that in the Wasm contract ecosystem, a development library similar to Openzeppelin-contracts is very necessary. This is Metis. For the sake of simplicity and readability, the patterns and meta-language provided by this library should be as consistent with Openzeppelin-contracts as possible, so as to reduce the burden on developers and effectively absorb the experience accumulated in the Solidity ecosystem."),(0,r.kt)("p",null,"But you need to realize that the Wasm contract development based on ink! and Ask! is very different from the EVM contract development based on Solidity. Wasm's mature system support allows developers to use a variety of different languages and tools to develop smart contracts. Based on these mature or rapid iteration platforms, developers can enjoy a large number of underlying facilities support and development experience accumulation, but different languages and tools often have different considerations and trade-offs. This means that developers will use completely different codes to express the same mechanism and design, which will bring huge communication costs and mental burdens to the community."),(0,r.kt)("p",null,'Faced with such problems, we need to summarize and accumulate the implementation model in the development of smart contracts. This idea was introduced in the book "Implementation Patterns" by Kent Beck. The purpose of summarizing the implementation mode is to clearly and accurately express the developer\'s intentions and ideas through these clear patterns, so that "code that others can understand" can be implemented. In contract development, this idea is very important.'),(0,r.kt)("p",null,'From Openzeppelin-contracts, we can see that it summarizes several implementation models in the development of smart contracts, such as the "contract expansion model" based on the Solidity inheritance grammar. These implementation models are valuable experience accumulated in the Solidity ecology. Of course, different languages have different ways of practicing these modes. Metis will implement these modes and provide corresponding support on different platforms. For example, in Rust, it is obvious that you cannot directly use inheritance to implement contract expansion. For this, Metis will provide code implementation examples and provide a series of help libraries to reduce the developer\'s mental cost.'),(0,r.kt)("p",null,"Metis will be more than just a Wasm contract standard library. We hope that through the practice of Metis, we can fully inherit and absorb previous contract development experience while exploring the best practices of Wasm contract development."),(0,r.kt)("h2",{id:"1-problem"},"1. Problem"),(0,r.kt)("p",null,"At present, contract-based developers mainly face the following problems:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Lack of reliable implementation of common contracts (such as ERC20)"),(0,r.kt)("li",{parentName:"ul"},"It is difficult to achieve contract combination and expansion similar to the Solidity inheritance mechanism"),(0,r.kt)("li",{parentName:"ul"},"Lack of a series of reliable public components to implement contracts"),(0,r.kt)("li",{parentName:"ul"},"Lack of experience accumulation and model summary based on ink! development contracts")),(0,r.kt)("p",null,"The above problems severely limit the current ink!-based contract development ecology. Metis will solve these problems while avoiding the existing problems in Solidity."),(0,r.kt)("h2",{id:"2-contract-standard-library"},"2. Contract Standard Library"),(0,r.kt)("p",null,"Metis will implement a series of common components, similar to the Openzeppelin-contracts development library. These components will be thoroughly tested and code audited. These components will be as consistent as possible with Openzeppelin-contracts, which can reduce the burden on developers and effectively absorb the experience accumulated in the Solidity ecosystem."),(0,r.kt)("p",null,"Metis will include the following components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Openzeppelin-contracts-like components, including basic Access and Security components, as well as Token and Governance components"),(0,r.kt)("li",{parentName:"ul"},"Component developed for ink! contracts, wasm-based contracts can support better abstraction mechanisms, and we can implement more complex and practical components"),(0,r.kt)("li",{parentName:"ul"},"Summarizing abstract components from mature contract projects, metis will absorb the experience and accumulation of the community, including both the mature Solidity ecology and emerging blockchain contract projects."),(0,r.kt)("li",{parentName:"ul"},"The expansion of ink! contracts, including basic data structures for different scenarios, etc.")),(0,r.kt)("p",null,"In the previous version of Metis, we will first implement Openzeppelin-contracts-like components for developers to use. These components include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Token: ERC20, ERC721, ERC777, ERC1155 and the expansion contract of the above Token contract"),(0,r.kt)("li",{parentName:"ul"},"Access: Ownable, AccessControl, TimelockController"),(0,r.kt)("li",{parentName:"ul"},"Security: PullPayment, ReentrancyGuard, Pausable")),(0,r.kt)("h2",{id:"3-ink-component"},"3. ink! component"),(0,r.kt)("p",null,"Most of Metis development libraries are composed of contract components. In Solidity, the introduction of contract components can be implemented based on inheritance. Generally, the contract components will include the following parts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Component Storage: The storage state related to the logic of the component itself, these states do not need to be exposed to the outside"),(0,r.kt)("li",{parentName:"ul"},"Component Message: The externally-facing Message of the component"),(0,r.kt)("li",{parentName:"ul"},"Component Event: The event that the component's own logic will  emit"),(0,r.kt)("li",{parentName:"ul"},"Component internal interface: an interface for other logic in the contract to call")),(0,r.kt)("p",null,"For example, common Ownable contracts:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Solidity"},"abstract contract Ownable is Context {\n    // Component Storage\n    address private _owner;\n\n    // Component Event\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    \n    // Component internal interface\n    modifier onlyOwner() {\n        ...\n    }\n\n    // Component Event\n    function renounceOwnership() public virtual onlyOwner {\n        ...\n    }\n\n    ...\n}\n")),(0,r.kt)("p",null,"If a contract needs to be Ownable, just inherit the contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Solidity"},"contract Escrow is Ownable {\n...\n}\n")),(0,r.kt)("p",null,"Similarly, other components can also have Ownable through inheritance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Solidity"},"contract Pausable is Ownable {\n  ...\n  function unpause() public onlyOwner whenPaused {\n      ...\n  }\n}\n")),(0,r.kt)("p",null,"The intention of inheritance here is actually composition rather than an ",(0,r.kt)("inlineCode",{parentName:"p"},"is-a")," relationship. Although excessive use of inheritance in Solidity will cause many problems, inheritance for specific intentions is still an important way to achieve it."),(0,r.kt)("p",null,"In contract development based on ink!, through metis, we can also achieve the same motivation based on generics and traits:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"...\n\n#[metis::contract] // metis contract macro, will use ink_lang::contract auto\nmod flipper {\n    ...\n\n    #[ink(storage)]\n    #[import(ownable)] // flipper import the ownable\n    pub struct Flipper {\n        ownable: ownable::Data<Flipper>, // data by ownable\n\n        value: bool,\n    }\n\n    #[ink(event)]\n    #[metis(ownable)] // TODO: event in ink! will refactor\n    pub struct OwnershipTransferred {\n        ...\n    }\n\n    impl Flipper {\n        ...\n\n        #[ink(message)]\n        pub fn flip(&mut self) {\n            // check owner\n            ownable::Impl::ensure_caller_is_owner(self);\n\n            self.value = !self.value;\n        }\n\n        ...\n\n        #[ink(message)]\n        pub fn renounce_ownership(&mut self) {\n            ownable::Impl::renounce_ownership(self) // owner message\n        }\n\n        ...\n    }\n}\n")),(0,r.kt)("p",null,"Metis assists developers to achieve the same function through a series of helper macros. In order to improve the auditability of the contract, here we hope that users clearly implement storage, event and message declarations."),(0,r.kt)("p",null,"At the same time, metis has improved the implementation of components:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"...\n\n// Storage\n#[metis::component::storage]\npub struct Data<E>\nwhere\n    E: Env,\n{\n    owner: Lazy<Option<E::AccountId>>,\n}\n\n// Event trait\npub trait EventEmit<E: Env>: EnvAccess<E> {\n    ...\n}\n\n// Impl trait\npub trait Impl<E: Env>: Storage<E> + EventEmit<E> {\n    // logics\n    fn init(&mut self) {\n        self.get_mut().set_ownership(&Some(Self::caller()));\n    }\n\n    fn renounce_ownership(&mut self) {\n        self.ensure_caller_is_owner();\n\n        self.emit_event_ownership_transferred(\n            self.get().get_ownership().clone(),\n            None);\n\n        self.get_mut().set_ownership(&None);\n    }\n\n    ...\n\n    /// Panic if `owner` is not an owner\n    fn ensure_owner(&self, owner: &E::AccountId) {\n        assert!(&self.get().get_ownership().clone().unwrap() == owner);\n    }\n\n    ...\n}\n\n")),(0,r.kt)("p",null,"Such components can extend their functions by inheriting other components, such as an ERC20 component with the function of destroying tokens:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"...\n\npub trait Impl<E>: erc20::Impl<E>\nwhere\n    E: Env,\n{\n    fn _burn(&mut self, account: &E::AccountId, amount: E::Balance) -> Result<()> {\n        ...\n    }\n\n    fn burn(&mut self, amount: E::Balance) -> Result<()> {\n        self._burn(&Self::caller(), amount)\n    }\n\n    fn burn_from(&mut self, account: &E::AccountId, amount: E::Balance) -> Result<()> {\n        ...\n    }\n}\n")),(0,r.kt)("p",null,"Based on metis, we can implement various contract combination modes implemented by Solidity through inheritance under limited intent, and at the same time, with the help of rust's zero-cost abstraction, these abstractions will not bring additional performance consumption."),(0,r.kt)("h2",{id:"4-overall-roadmap"},"4. Overall Roadmap"),(0,r.kt)("p",null,"Metis for ink! is divided into several milestones:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"[M1]")," Implement basic component macros and components, improve component testing support, developers can build regular DAPPs based on Metis"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"[M2]")," Complete component macros, complete component development support, developers can build custom components. Complete the api support corresponding to the metis component."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"[M3]")," Rich component library, complete component and API support for governance and financial mechanism, perfect mathematical library suitable for contract development to support DeFi-type contracts that require complex calculations.")),(0,r.kt)("p",null,"Considering that the current ink! and contract-pallet are still in iteration, some metis features will be implemented based on subsequent improvements, including:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Contract proxy and upgradeable support will depend on the improvement of subsequent contract calls, by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/paritytech/ink/issues/739"},"739"),"."),(0,r.kt)("li",{parentName:"ul"},"The Event in the component, the Event in the current ink! cannot be independent of the contract, by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/paritytech/ink/issues/759"},"759"),", the event in the current component is only an early implementation, and it will be refactored based on the improvement of ink! in the future.")),(0,r.kt)("p",null,"With the richness and completeness of the ink! contract community, metis will further implement more public components and libraries to assist developers in developing large-scale contract projects. Therefore, we may arrange ","[MR]"," milestones. It will be developed based on the iterative schedule of ink!"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"[MR]")," According to the ink!'s iterative progress, community feedback, contract upgrades, contract proxy and cross-contract call support, refactor Event-related implementations, improve basic components and add development assistance macros to reduce duplication while ensuring auditability Code.")),(0,r.kt)("h2",{id:"5-detailed-timeline-of-m1-3-developers--5-weeks"},"5. Detailed timeline of M1 (3 developers * 5 weeks)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Week 1: ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"M1.1 Design and develop macros that support the development of metis components, and determine the component development paradigm"),(0,r.kt)("li",{parentName:"ul"},"M1.2 Design and develop macros that support the introduction of metis components into contracts, and determine the development paradigm for contract expansion and introduction of components"))),(0,r.kt)("li",{parentName:"ul"},"Week 2:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"M1.3 Design and develop unit test support for components"),(0,r.kt)("li",{parentName:"ul"},"M1.4 design and develop integration test support based on Redspot"))),(0,r.kt)("li",{parentName:"ul"},"Week 3:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"M1.5 Complete the implementation and testing of Access related components"),(0,r.kt)("li",{parentName:"ul"},"M1.6 Complete the implementation and testing of Security related components"))),(0,r.kt)("li",{parentName:"ul"},"Week 4:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"M1.7 Complete the implementation and testing of Token related components"),(0,r.kt)("li",{parentName:"ul"},"M1.8 Complete the detailed Metis component design document"))),(0,r.kt)("li",{parentName:"ul"},"Week 5:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"M1.9 Complete documentation and examples of metis components")))),(0,r.kt)("p",null,"Cost of M1 (15 developers ","*"," weeks):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Operating activities: $3000 ( Rent and Devices: $200 per employee ","*"," week )"),(0,r.kt)("li",{parentName:"ul"},"Developer payments: $28500 ( $1900 per developer ","*"," week )"),(0,r.kt)("li",{parentName:"ul"},"Total Cost: $31500"),(0,r.kt)("li",{parentName:"ul"},"Treasury Proposal: 1166 DOT ($27/DOT)")),(0,r.kt)("h2",{id:"6-how-to-verify-m1"},"6. How to verify M1"),(0,r.kt)("p",null,"Complete the macros and tests related to the metis component, and all the tests can pass. Complete the detailed metis component design document. Complete the implementation and testing of the following contract components, all tests can pass:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ERC20 and its expansion components (including increasingly issuance, destruction, etc.)"),(0,r.kt)("li",{parentName:"ul"},"ERC721 and its expansion components"),(0,r.kt)("li",{parentName:"ul"},"ERC777 and its expansion components"),(0,r.kt)("li",{parentName:"ul"},"ERC1155 and its expansion components"),(0,r.kt)("li",{parentName:"ul"},"Ownable"),(0,r.kt)("li",{parentName:"ul"},"AccessControl"),(0,r.kt)("li",{parentName:"ul"},"TimelockController"),(0,r.kt)("li",{parentName:"ul"},"PullPayment"),(0,r.kt)("li",{parentName:"ul"},"ReentrancyGuard"),(0,r.kt)("li",{parentName:"ul"},"Pausable")),(0,r.kt)("p",null,"Complete the documentation and examples of the above contract components."))}u.isMDXComponent=!0}}]);