"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[826],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return u}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),l=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=l(e.components);return o.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,h=c(e,["components","mdxType","originalType","parentName"]),d=l(n),u=a,p=d["".concat(s,".").concat(u)]||d[u]||m[u]||r;return n?o.createElement(p,i(i({ref:t},h),{},{components:n})):o.createElement(p,i({ref:t},h))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=d;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var l=2;l<r;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9250:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return h},default:function(){return d}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],c={},s="Contract model",l={unversionedId:"contracts/model",id:"contracts/model",isDocsHomePage:!1,title:"Contract model",description:"Background Information",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/contracts/model.md",sourceDirName:"contracts",slug:"/contracts/model",permalink:"/en/contracts/model",editUrl:"https://github.com/patractlabs/substrate-contracts-book/docs/contracts/model.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Contract overview",permalink:"/en/contracts/overview"},next:{title:"Contract language",permalink:"/en/contracts/language"}},h=[{value:"Background Information",id:"background-information",children:[]},{value:"Wasm virtual machine",id:"wasm-virtual-machine",children:[]},{value:"EVM contract model",id:"evm-contract-model",children:[]},{value:"Pallet-contracts contract model",id:"pallet-contracts-contract-model",children:[]},{value:"Use Wasm virtual machine to implement other contract models",id:"use-wasm-virtual-machine-to-implement-other-contract-models",children:[]},{value:"Other contract models",id:"other-contract-models",children:[{value:"EOS contract model",id:"eos-contract-model",children:[]},{value:"Asynchronous contract model",id:"asynchronous-contract-model",children:[]}]}],m={toc:h};function d(e){var t=e.components,c=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},m,c,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"contract-model"},"Contract model"),(0,r.kt)("h2",{id:"background-information"},"Background Information"),(0,r.kt)("p",null,"The contract sandbox only represents the environment in which the contract is run, but how the contract is run, how the contract interacts with the contract, and how the contract interacts with the data of the chain. These problems belong to the contract model problem. In other words, the contract model refers to the model in which the contract runs in the contract sandbox/virtual machine."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(5214).Z})),(0,r.kt)("p",null,"As shown in the figure above, the contract model and the contract virtual machine can be decoupled in nature, and the relationship only exists whether the contract virtual machine supports the contract model required by the upper layer. To facilitate the understanding of the contract model, you can refer to the following examples."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Bitcoin's virtual machine is the stack executor of Bitcoin scripts. Because the executor design is a non-Turing complete OP_CODE, the upper-level contract model can only support Bitcoin scripts."),(0,r.kt)("li",{parentName:"ul"},"Following the inspiration of Bitcoin, Ethereum designed a Turing-complete OP_CODE, namely EVM . The OP_CODE of EVM is relatively simple, and only has a stack design without the concept of a heap. But EVM introduces the OP_CODE of read and write state, so the contract model can support the state model from the virtual machine mechanism. As described by Gavin Wood in the Ethereum Yellow Paper, EVM is also regarded as a state transition machine that performs state transitions. The state model is actually a more general abstract model. Most models can be simulated with the state model, for example, the UTXO model is constructed in the state model. In theory, as long as the OP_CODE of the EVM continues to be improved, the upper layer of the EVM can also construct other contract models."),(0,r.kt)("li",{parentName:"ul"},"libra believes that the core of the blockchain lies in the processing of assets, and proposed the concept of Move's virtual machine model MVM (Move Virtual Machine). From the model of restricting the contract on the virtual machine, it can be understood as a set of OP_CODE with specialized logic. Therefore, the upper layer of MVM can only run the Move model.")),(0,r.kt)("p",null,"As described above , I believe you have a clearer understanding of the concept of the contract model, and realize the limitations of the virtual machine on the upper-level contract model."),(0,r.kt)("h2",{id:"wasm-virtual-machine"},"Wasm virtual machine"),(0,r.kt)("p",null,"The following describes the contract model that the Wasm virtual machine can run and the contract model composition of pallet-contracts."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://webassembly.org/"},"WebAssembly")," (abbreviated as Wasm) is a binary instruction format that runs on a stack-based virtual machine, so the model structure of Wasm is similar to that of mainstream computer programs. On the other hand,  Wasm is designed into a more general form, and WASI is designed and supports the free definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"host function")," in the operating environment. Therefore, although Wasm evolved from a browser, the current usage scenarios are not limited to browsers, and begin to play a role in edge computing, hot updates, and Serverless platforms."),(0,r.kt)("p",null,"If the ability of a virtual machine is measured by the completeness of instructions, the EVM is at the level of a semi-finished product, which is more restrictive and not flexible enough. The instructions of the JVM and Wasm virtual machines are relatively complete, with few restrictions and strong functionality. On the other hand, the rationality of the instruction design will also affect the execution efficiency of the virtual machine to a certain extent, and the implementation scheme adopted by the virtual machine will also have a relatively large impact on the execution efficiency. For example, EVM currently can only be run in the form of an interpreter, and the current implementation process body (Go, C++, etc.) does not see optimization for the interpreter, and the execution efficiency is relatively low, while virtual machines such as JVM and Wasm use JIT The execution efficiency is quite high, even approaching the performance of local execution."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note")," The ",(0,r.kt)("inlineCode",{parentName:"p"},"pallet-contracts")," currently can only use wasmi (interpreter) to execute Wasm code, so the execution performance of the contract is not as good as the execution performance of Runtime using wasmtime."),(0,r.kt)("p",null,"However, compared with virtual machines such as JVM, the Wasm virtual machine is light, fast, and highly customizable, and the function of the host function gives the Wasm virtual machine a channel for interaction with the host. Therefore, compared with other virtual machines, It is easier to combine the Wasm virtual machine as a blockchain contract sandbox with the functions of the chain."),(0,r.kt)("p",null,"At the same time, Wasm is a better abstraction layer between the underlying code and the upper code, and its complexity and completeness are far beyond EVM, which can better meet the needs of the blockchain contract field."),(0,r.kt)("p",null,"The sandbox environment provided by the Wasm virtual machine meets the following requirements on the premise that the contract sandbox is satisfied:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Complete instructions, rich functionality, and high execution efficiency."),(0,r.kt)("li",{parentName:"ul"},"There is a suitable interface to interact with the host (here refers to the environment where Wasm is running, that is, the chain) to facilitate the host to provide the required functions.")),(0,r.kt)("h2",{id:"evm-contract-model"},"EVM contract model"),(0,r.kt)("p",null,"Ethereum is a blockchain that stores state, so the EVM contract model requires basic functions of reading and writing state. If the process of each contract operation is regarded as a process from the start of the program to the end of its execution, then the changes in the state data correspond to the changes in the data that the program needs to persist. For the read and write status, Ethereum's EVM provides two instructions,",(0,r.kt)("inlineCode",{parentName:"p"},"SLOAD "),"and ",(0,r.kt)("inlineCode",{parentName:"p"},"SSTORE"),"."),(0,r.kt)("p",null,"On the other hand, Ethereum describes an account that uses the account model, that is, the contract and the user calling the contract are regarded as an account. Under this account, there are concepts such as balance. Therefore, EVM provides a series of instructions such as ",(0,r.kt)("inlineCode",{parentName:"p"},"CALLER")," ,",(0,r.kt)("inlineCode",{parentName:"p"},"ORIGIN"),",",(0,r.kt)("inlineCode",{parentName:"p"},"CALLVALUE"),", etc. to describe This model."),(0,r.kt)("p",null,"At the same time, in the abstract system of EVM, the contract and the user are considered to be consistent, so there is a model of contract calling contract, namely ",(0,r.kt)("inlineCode",{parentName:"p"},"CALL"),",",(0,r.kt)("inlineCode",{parentName:"p"},"DELEGATECALL ")," and other instructions, which brings the composability of the contract and achieves the prosperity of Ethereum's ecology. In EVM, a contract relies on one EVM to run, so the contract calling contract starts another EVM in one EVM, and loads instructions for execution."),(0,r.kt)("p",null,"The original intention of the EVM virtual machine is to solve the problem of non-Turing completeness of the Bitcoin script. In order to solve this problem and ensure that the downtime problem does not occur, the instruction Gas billing model is introduced."),(0,r.kt)("p",null,"In summary, the EVM contract model has the following characteristics:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The data processing model is the state machine model, and the state change is triggered by external calls (similar to the process of calling the state change function)."),(0,r.kt)("li",{parentName:"ol"},"The contract model requires chain-related features."),(0,r.kt)("li",{parentName:"ol"},"Treat the contract as consistent with the user and allow the contract to call the contract."),(0,r.kt)("li",{parentName:"ol"},"Introduce an instruction billing model.")),(0,r.kt)("h2",{id:"pallet-contracts-contract-model"},"Pallet-contracts contract model"),(0,r.kt)("p",null,"Although pallet-contracts uses the Wasm virtual machine to execute code, its contract model is basically the same as the EVM contract model. Therefore, the contract model of pallet-contracts also has the four characteristics of the EVM contract model mentioned above. Based on the storage lease model, storage lease charging is added:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The data processing model is a state machine model, and the change of state is triggered by external calls."),(0,r.kt)("li",{parentName:"ol"},"The contract model requires chain-related features."),(0,r.kt)("li",{parentName:"ol"},"Treat the contract as consistent with the user and allow the contract to call the contract."),(0,r.kt)("li",{parentName:"ol"},"Introduce an instruction billing model."),(0,r.kt)("li",{parentName:"ol"},"Storage lease model.")),(0,r.kt)("p",null,"The contract execution environment and contract model can be decoupled, but because EVM was designed earlier, there is no concept of decoupling. Therefore, SLOAD, SSTORE, and similar chain-related instructions in the instructions are merged with other EVM instructions. Wasm was not originally designed for blockchain, so there are no instructions related to the chain environment."),(0,r.kt)("p",null,"The host function of Wasm is used to accomplish this. As the host , the chain only needs to provide the Wasm virtual machine with the methods it thinks the contract may use, and let it import these function objects, which can be used during the execution of the contract. Therefore, through the host function and pallet-contracts contract module, you can have the functions of 1, 2, and 4, and will provide some of the functions required by the third point, and the fifth feature (rental billing) can also be introduced. And the implementation of the third function above is also consistent with EVM. When there is a part of the contract calling the contract, the host function is used to return to the pallet-contracts module from Wasm, and a new Wasm virtual machine is started to execute the called contract. (This part will be elaborated in a future article).In summary, the contract model of pallet-contracts has the following characteristics:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The contract model is consistent with the EVM contract model, and a storage billing model is added on this basis."),(0,r.kt)("li",{parentName:"ul"},"The interaction with the chain is realized through the host function feature of Wasm.")),(0,r.kt)("h2",{id:"use-wasm-virtual-machine-to-implement-other-contract-models"},"Use Wasm virtual machine to implement other contract models"),(0,r.kt)("p",null,"The above describes how pallet-contracts implements the contract model on the Wasm virtual machine. It has also been mentioned in the previous document that the virtual machine and the contract model can be decoupled, so other things can also be implemented on the Wasm virtual machine. Contract model."),(0,r.kt)("p",null,"If the Move virtual machine is also transplanted to the Wasm virtual machine, there are two possible ways to implement."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Analogous to running the EVM implementation in the Runtime Wasm environment, the MVM implementation can also be compiled into the form of Wasm (for example, named ",(0,r.kt)("inlineCode",{parentName:"li"},"pallet-mvm"),") and run in the Runtime Wasm.")),(0,r.kt)("p",null,"Based on this implementation, Move can still be compiled in the normal way, and the compiled result of Solidity runs on ",(0,r.kt)("inlineCode",{parentName:"p"},"pallet-evm")," consistent with that of Solidity, and the compiled result of Move is run on a platform such as ",(0,r.kt)("inlineCode",{parentName:"p"},"pallet-mvm"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Abstract one level of MVM, ownership, and chain-related features into the form of pallet-contracts, and design to compile the intermediate code IR compiled by the Move language to Wasm.")),(0,r.kt)("p",null,"Based on this realization, Move can be compiled into Wasm and run in the Wasm virtual machine."),(0,r.kt)("h2",{id:"other-contract-models"},"Other contract models"),(0,r.kt)("h3",{id:"eos-contract-model"},"EOS contract model"),(0,r.kt)("p",null,"EOS's contract model is similar to EVM, while strengthening the concept of account model. Therefore, the way EOS uses Wasm is also based on the execution of Wasm, and introduces chain-related functions by ",(0,r.kt)("inlineCode",{parentName:"p"},"host function"),"."),(0,r.kt)("p",null,"The main difference between the EOS and EVM models is that the EOS contract calls the contract in the form of transaction calls, and the EOS resource model is a mortgage model. At present, it is generally believed that EOS has not succeeded because of the EOS mortgage model."),(0,r.kt)("h3",{id:"asynchronous-contract-model"},"Asynchronous contract model"),(0,r.kt)("p",null,"Pallet-actor is the beginning of substrate's attempt to implement an asynchronous contract model, but there is currently no progress. For details, please refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://corepaper.org/contract/actor/"},"Actor-based contract model"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"pallet-actor")," model intends to use the Wasm virtual machine as the operating environment, and on this basis add asynchronous functions to improve performance. There are also a few other studies on asynchronous contract models, but they are all in the preliminary stage, so I won't elaborate on them here."))}d.isMDXComponent=!0},5214:function(e,t,n){t.Z=n.p+"assets/images/engcontract_model_1-78a55603f316264f3cdf9440ceb1c27f.jpg"}}]);