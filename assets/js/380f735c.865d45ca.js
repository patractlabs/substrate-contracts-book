"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[8122],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=r,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8072:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={},l="Mechanism",c={unversionedId:"ask/guides/mechanism",id:"ask/guides/mechanism",isDocsHomePage:!1,title:"Mechanism",description:"Ask!'s design starting point is to use decorator to simplify the contract writing process and separate the logic of the contract from the contract runtime; at the same time, decorators are also used to generate the metadata.json file of the contract.",source:"@site/docs/ask/guides/mechanism.md",sourceDirName:"ask/guides",slug:"/ask/guides/mechanism",permalink:"/substrate-contracts-book/ask/guides/mechanism",editUrl:"https://github.com/patractlabs/substrate-contracts-book/edit/master/docs/ask/guides/mechanism.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Cross Contract Calling",permalink:"/substrate-contracts-book/ask/guides/cross-contract"},next:{title:"Examples",permalink:"/substrate-contracts-book/ask/guides/examples"}},p=[{value:"Runtime",id:"runtime",children:[]},{value:"Preprocessor",id:"preprocessor",children:[]},{value:"Compiler",id:"compiler",children:[]}],m={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"mechanism"},"Mechanism"),(0,o.kt)("p",null,"Ask!'s design starting point is to use decorator to simplify the contract writing process and separate the logic of the contract from the contract runtime; at the same time, decorators are also used to generate the metadata.json file of the contract."),(0,o.kt)("h2",{id:"runtime"},"Runtime"),(0,o.kt)("p",null,"At the contract runtime layer, Ask! provides objects such as ",(0,o.kt)("inlineCode",{parentName:"p"},"AccountId"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Block"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Crypto"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Gas"),". These objects encapsulate the underlying logic and API calls, and provide upper-level semantics and methods for writing contracts and preprocessors. "),(0,o.kt)("h2",{id:"preprocessor"},"Preprocessor"),(0,o.kt)("p",null,"At the Preprocessor level, it needs to compile the written contract into the target contract WebAssembly bytecode."),(0,o.kt)("h2",{id:"compiler"},"Compiler"),(0,o.kt)("p",null,"From the perspective of the compiler, the work of Preprocessor is divided into the following steps "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Use ",(0,o.kt)("inlineCode",{parentName:"li"},"asc")," to compile the contract into a Program object to obtain code syntax information.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The code is a program written in accordance with the contract structure, so the syntax information of the program can be obtained through compilation.")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"After the Program is compiled, the semantic information of the program can be obtained. By analyzing the decorators in the semantic information, the points in the contract that require code injection and the structural information of the contract can be obtained.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@contract")," decorator indicates that the class is a contract entry."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@state")," decorator indicates that the class property object is a contract storage object."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@message")," decorator indicates that this method is a contract method that can be called externally as an RPC."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@constructor")," decorator indicates that this is the method to instantiate the contract"),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@event")," decorator indicates that this is the event class "),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"@topic")," sub-decorator acts on a member variable of the class, which means that this variable can be filtered out on the chain. Its implementation is to store the hash of the topic variable in the topic buffer, and store all the variables in the data buffer, The value is then sent to the chain through the ",(0,o.kt)("inlineCode",{parentName:"li"},"seal_deposit_event")," method.")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"For different decorators, obtain the relevant structural information that needs to generate the target contract code.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When a class contains the decorator ",(0,o.kt)("inlineCode",{parentName:"li"},"@contract"),", such as:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  @contract\n  class SolarSystem {\n  }\n")))),(0,o.kt)("p",null,"Then ",(0,o.kt)("inlineCode",{parentName:"p"},"@constructor"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'  @constructor\n  default(name: string = "Earth", radius: u32 = 6300, isdwarf: boolean = false): void {\n      this.name = name;\n      this.radius = radius;\n      this.isdwarf = isdwarf;\n  }\n')),(0,o.kt)("p",null,"Through semantic information, the ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionPrototype")," information of the default function can be obtained, and the description information ",(0,o.kt)("inlineCode",{parentName:"p"},"declaration")," of the Function can be obtained by parsing the ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionPrototype")," object. Then get the function information of ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionDef")," such as methodName, method parameter list and return value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'  export class FunctionDef {  \n      private funcProto: FunctionPrototype;\n      methodName: string = "";\n           parameters: ParameterNodeDef[] = new Array();\n       isReturnable: boolean = false;\n       returnType: NamedTypeNodeDef | undefined;\n  }\n')),(0,o.kt)("p",null,"According to the exported ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionDef")," information, the main.tpl (see below) is rendered through ",(0,o.kt)("inlineCode",{parentName:"p"},"Handlebar")," to generate the deploy function. In the way of templates, you can easily adjust, deploy function structure and implementation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  export function deploy(): i32 {\n    let {{contract.instanceName}} = new {{contract.className}}();\n     {{#each contract.cntrFuncDefs}}\n      const {{methodName}}Selector: u8[] = {{#selector methodName}}{{u8Arr}}{{/selector}};\n            if (msg.isSelector({{methodName}}Selector)) {\n        {{#neq parameters.length 0}}\n        const fnParameters = new FnParameters(msg.data);\n         {{/neq}}\n      {{#each parameters}}\n      let p{{_index}} = fnParameters.get<{{type.codecType}}>();\n      {{/each}}\n      {{../contract.instanceName}}.{{methodName}}({{#joinParams parameters}}{{/joinParams}}{{ctrDefaultVals}});\n      }\n    {{/each}}\n    return 0;\n  }\n")),(0,o.kt)("p",null,"The deploy method obtained after rendering:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  export function deploy(): i32 {\n    let solarSystem = new SolarSystem();\n\n   const defaultSelector: u8[] = [0xed,0x4b,0x9d,0x1b];\n    if (msg.isSelector(defaultSelector)) {\n      const fnParameters = new FnParameters(msg.data);\n      let p0 = fnParameters.get<ScaleString>();\n      let p1 = fnParameters.get<UInt32>();\n      let p2 = fnParameters.get<Bool>();\n      solarSystem.default(p0.toString(),p1.unwrap(),p2.unwrap());\n    }\n    return 0;\n  }\n")),(0,o.kt)("p",null,"In the same way, to obtain the method annotated as ",(0,o.kt)("inlineCode",{parentName:"p"},"@message"),", obtain the method name, method parameter list and return value and other information by analyzing the ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionPrototype"),", and generate the call distribution logic of the ",(0,o.kt)("inlineCode",{parentName:"p"},"call")," entry function."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When a property is marked with ",(0,o.kt)("inlineCode",{parentName:"li"},"@state"),". Need to get the field information in the class. By analyzing the ",(0,o.kt)("inlineCode",{parentName:"li"},"FieldPrototype")," to obtain the field parameter name, field type and other information ",(0,o.kt)("inlineCode",{parentName:"li"},"FieldDef"),", where storeKey is used to store the object key. The key will be generated by the blake2 hash.",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'  export class FieldDef {\n     protected fieldPrototype: FieldPrototype;\n      layout: LayoutDef = new LayoutDef();\n      name: string = "";\n      type: NamedTypeNodeDef | null = null;\n      storeKey: string = "";\n      varName: string = "";\n      path: string = "";\n  }\n')))),(0,o.kt)("p",null,"The field needs to be packaged in this place. The original is TypeScript basic types, i8/u8, etc. need to be packaged into IInt8, Uint8 etc in codec, making it convenient to serialize and deserialize when storing and reading. Then generate getter/setter methods that meet the read and write requirements for each field. The same is generated by the ",(0,o.kt)("inlineCode",{parentName:"p"},"Handlebar")," rendering template. The template is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"    class {{className}} {\n      {{#each fields}}\n      private {{varName}}: {{type.codecType}} | null = null;\n        {{/each}}\n        {{#each fields}}\n        get {{name}}(): {{type.originalType}} {\n          if (this.{{varName}} === null) {\n            const st = new Storage<{{type.codecType}}>(\"{{storeKey}}\");\n            this.{{varName}} = st.load();\n          }\n          {{#eq type.codecType 'ScaleString'}}\n          return this.{{varName}}!.toString();\n          {{/eq}}\n          {{#neq type.codecType 'ScaleString'}}\n            return this.{{varName}}!.unwrap();\n          {{/neq}}\n        }\n        set {{name}}(v: {{type.originalType}}) {\n          this.{{varName}} = new {{type.codecType}}(v);\n          const st = new Storage<{{type.codecType}}>(\"{{storeKey}}\");\n          st.store(this.{{varName}}!);\n        }\n        {{/each}}\n      }\n")),(0,o.kt)("p",null,"The generated code\uff1a "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'    class Planets {\n        private _name: ScaleString | null = null;\n        private _radius: UInt32 | null = null;\n      private _isdwarf: Bool | null = null;\n        get name(): string {\n          if (this._name === null) {\n            const st = new Storage<ScaleString>("Planetsname");\n            this._name = st.load();\n          }\n        return this._name!.toString();\n        }\n        set name(v: string) {\n          this._name = new ScaleString(v);\n          const st = new Storage<ScaleString>("Planetsname");\n          st.store(this._name!);\n        }\n        get radius(): u32 {\n          if (this._radius === null) {\n            const st = new Storage<UInt32>("Planetsradius");\n            this._radius = st.load();\n          }\n            return this._radius!.unwrap();\n        }\n        set radius(v: u32) {\n          this._radius = new UInt32(v);\n          const st = new Storage<UInt32>("Planetsradius");\n          st.store(this._radius!);\n        }\n        get isdwarf(): boolean {\n          if (this._isdwarf === null) {\n            const st = new Storage<Bool>("Planetsisdwarf");\n            this._isdwarf = st.load();\n          }\n        return this._isdwarf!.unwrap();\n        }\n        set isdwarf(v: boolean) {\n          this._isdwarf = new Bool(v);\n          const st = new Storage<Bool>("Planetsisdwarf");\n          st.store(this._isdwarf!);\n        }\n      }\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Expand all the decorators to generate the final contract file for compilation.")),(0,o.kt)("ol",{start:4},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"According to the contract structure information, the metadata.json file is generated through the template engine"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"According to different contract structure information, generate the code of each section in metadata.json. Generate the information of the ",(0,o.kt)("inlineCode",{parentName:"li"},"storage")," field in metadata.json through the ",(0,o.kt)("inlineCode",{parentName:"li"},"@state")," class property information; generate the information of the ",(0,o.kt)("inlineCode",{parentName:"li"},"messages")," field through ",(0,o.kt)("inlineCode",{parentName:"li"},"@message"),"; Generate the information of the ",(0,o.kt)("inlineCode",{parentName:"li"},"constructor")," field through ",(0,o.kt)("inlineCode",{parentName:"li"},"@constructor"),". The code generation logic is completed by the ",(0,o.kt)("inlineCode",{parentName:"li"},"Handlebar")," template engine. When the target code structure needs to be adjusted, you only need to adjust the template."))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Compile the expanded contract file to generate the contract wasm bytecode."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Use ",(0,o.kt)("inlineCode",{parentName:"li"},"asc")," to compile the expanded target code. Compile command: ",(0,o.kt)("inlineCode",{parentName:"li"},"asc --importMemory --initialMemory 2 --maximumMemory 16 --noExportMemory --runtime half --use abort= extension.ts -O2 -b target .wasm "),", get the bytecode that can be run on the wasm virtual machine.")))),(0,o.kt)("p",null,"From the perspective of the contract developer, starting from calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"ask")," command, the workflow of the Preprocessor is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"                               +-------------+\n                           +--\x3e+metadata.json|\n                           |   +-------------+\n                           |\n   +-----------------+     |\n   | erc20.ts +-----|\n   +-----------------+\n                           |   +------------+       +------------+\n                           +--\x3e+extension/erc20.ts+-------\x3eerc20.wasm |\n                               +------------+       +------------+\n")))}d.isMDXComponent=!0}}]);