"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[4967],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return c}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=p(t),c=a,k=m["".concat(s,".").concat(c)]||m[c]||u[c]||o;return t?r.createElement(k,l(l({ref:n},d),{},{components:t})):r.createElement(k,l({ref:n},d))}));function c(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=m;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var p=2;p<o;p++)l[p]=t[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8513:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return d},default:function(){return m}});var r=t(7462),a=t(3366),o=(t(7294),t(3905)),l=["components"],i={},s="ERC721",p={unversionedId:"metis/guides/tokens/erc721",id:"metis/guides/tokens/erc721",isDocsHomePage:!1,title:"ERC721",description:"Details of ERC721 can be found in ERC721.",source:"@site/docs/metis/guides/tokens/erc721.md",sourceDirName:"metis/guides/tokens",slug:"/metis/guides/tokens/erc721",permalink:"/substrate-contracts-book/metis/guides/tokens/erc721",editUrl:"https://github.com/patractlabs/substrate-contracts-book/edit/master/docs/metis/guides/tokens/erc721.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"ERC20",permalink:"/substrate-contracts-book/metis/guides/tokens/erc20"},next:{title:"ERC777",permalink:"/substrate-contracts-book/metis/guides/tokens/erc777"}},d=[{value:"Dependency",id:"dependency",children:[]},{value:"Storage",id:"storage",children:[]},{value:"Mutable Message",id:"mutable-message",children:[{value:"approve",id:"approve",children:[]},{value:"transfer_from",id:"transfer_from",children:[]},{value:"set_approval_for_all",id:"set_approval_for_all",children:[]},{value:"safe_transfer_from",id:"safe_transfer_from",children:[]},{value:"safe_transfer_from_with_data",id:"safe_transfer_from_with_data",children:[]}]},{value:"Immutable Message",id:"immutable-message",children:[{value:"name",id:"name",children:[]},{value:"symbol",id:"symbol",children:[]},{value:"token_url",id:"token_url",children:[]},{value:"balance_of",id:"balance_of",children:[]},{value:"owner_of",id:"owner_of",children:[]},{value:"get_approved",id:"get_approved",children:[]},{value:"is_approved_for_all",id:"is_approved_for_all",children:[]}]},{value:"Internal Message",id:"internal-message",children:[{value:"_exists",id:"_exists",children:[]},{value:"_mint",id:"_mint",children:[]},{value:"_safe_mint",id:"_safe_mint",children:[]},{value:"_safe_mint_with_data",id:"_safe_mint_with_data",children:[]},{value:"_burn",id:"_burn",children:[]}]},{value:"Hooks",id:"hooks",children:[{value:"_before_token_transfer",id:"_before_token_transfer",children:[]},{value:"_base_url",id:"_base_url",children:[]}]},{value:"Events",id:"events",children:[{value:"Transfer",id:"transfer",children:[]},{value:"Approval",id:"approval",children:[]},{value:"ApprovalForAll",id:"approvalforall",children:[]}]},{value:"Extensions",id:"extensions",children:[{value:"ERC721Pausable",id:"erc721pausable",children:[]},{value:"ERC721Burnable",id:"erc721burnable",children:[]},{value:"ERC721URIStorage",id:"erc721uristorage",children:[]}]},{value:"Usage Example",id:"usage-example",children:[]}],u={toc:d};function m(e){var n=e.components,t=(0,a.Z)(e,l);return(0,o.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"erc721"},"ERC721"),(0,o.kt)("p",null,"Details of ERC721 can be found in ",(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-721"},"ERC721"),"."),(0,o.kt)("h2",{id:"dependency"},"Dependency"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'metis_erc721 = { git = "https://github.com/patractlabs/metis", default-features = false }\n')),(0,o.kt)("h2",{id:"storage"},"Storage"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg_attr(feature = "std", derive(::ink_storage::traits::StorageLayout))]\n#[derive(Debug, SpreadLayout)]\npub struct Data<E: Env> {\n    /// Symbols of ERC721 Token, by (name, symbol)\n    pub symbols: Lazy<(String, String)>,\n\n    /// Mapping from token ID to owner address\n    pub owners: StorageHashMap<TokenId, E::AccountId>,\n\n    /// Mapping owner address to token count\n    pub balances: StorageHashMap<E::AccountId, u64>,\n\n    /// Mapping from token ID to approved address\n    pub token_approvals: StorageHashMap<TokenId, E::AccountId>,\n\n    /// Mapping from owner to operator approvals\n    pub operator_approvals: StorageHashMap<(E::AccountId, E::AccountId), bool>,\n}\n')),(0,o.kt)("h2",{id:"mutable-message"},"Mutable Message"),(0,o.kt)("h3",{id:"approve"},"approve"),(0,o.kt)("p",null,"Gives permission to ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," to transfer ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," token to another account.\nThe approval is cleared when the token is transferred."),(0,o.kt)("p",null,"Only a single account can be approved at a time, so approving the\nzero address clears previous approvals."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The caller must own the token or be an approved operator."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," must exist.")),(0,o.kt)("p",null,"Emits an ",(0,o.kt)("inlineCode",{parentName:"p"},"Approval")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn approve(&mut self, to: Option<E::AccountId>, token_id: &TokenId) {\n        let owner = self.owner_of(token_id);\n        let caller = Self::caller();\n\n        assert!(\n            to.is_none() || to.as_ref().unwrap() != &owner,\n            "ERC721: approval to current owner"\n        );\n\n        assert!(\n            caller == owner || self.is_approved_for_all(&owner, &caller),\n            "ERC721: approve caller is not owner nor approved for all"\n        );\n\n        self._approve(to, token_id);\n    }\n')),(0,o.kt)("h3",{id:"transfer_from"},"transfer_from"),(0,o.kt)("p",null,"Transfers ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," token from ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"to"),"."),(0,o.kt)("p",null,"WARNING: Usage of this method is discouraged,\nuse ",(0,o.kt)("inlineCode",{parentName:"p"},"safe_transfer_from")," whenever possible."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"from")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"to")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," token must be owned by ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),"."),(0,o.kt)("li",{parentName:"ul"},"If the caller is not ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),", it must be approved to move this token by either ",(0,o.kt)("inlineCode",{parentName:"li"},"approve")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"set_approval_for_all"),".")),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn transfer_from(\n        &mut self,\n        from: E::AccountId,\n        to: E::AccountId,\n        token_id: TokenId,\n    ) -> Result<()> {\n        assert!(\n            self._is_approved_or_owner(&Self::caller(), &token_id),\n            "ERC721: transfer caller is not owner nor approved"\n        );\n\n        self._transfer(&from, &to, &token_id)\n    }\n')),(0,o.kt)("h3",{id:"set_approval_for_all"},"set_approval_for_all"),(0,o.kt)("p",null,"Approve or remove ",(0,o.kt)("inlineCode",{parentName:"p"},"operator")," as an operator for the caller.\nOperators can call ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer_from")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"safe_transfer_from")," for\nany token owned by the caller."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"operator")," cannot be the caller.")),(0,o.kt)("p",null,"Emits an ",(0,o.kt)("inlineCode",{parentName:"p"},"ApprovalForAll")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn set_approval_for_all(&mut self, operator: E::AccountId, approved: bool) {\n        let caller = Self::caller();\n        assert!(operator != caller, "ERC721: approve to caller");\n\n        self.get_mut()\n            .set_approval_for_all(caller.clone(), operator.clone(), approved);\n        self.emit_event_approval_for_all(caller, operator, approved);\n    }\n')),(0,o.kt)("h3",{id:"safe_transfer_from"},"safe_transfer_from"),(0,o.kt)("p",null,"Safely transfers ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," token from ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"to"),", checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"from")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"to")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," token must exist and be owned by ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),"."),(0,o.kt)("li",{parentName:"ul"},"If the caller is not ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),", it must be have been allowed to move this token by either ",(0,o.kt)("inlineCode",{parentName:"li"},"approve")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"set_approval_for_all"),"."),(0,o.kt)("li",{parentName:"ul"},"If ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," refers to a smart contract, it must implement ",(0,o.kt)("inlineCode",{parentName:"li"},"on_erc721_received"),", which is called upon a safe transfer.")),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn safe_transfer_from(\n        &mut self,\n        from: E::AccountId,\n        to: E::AccountId,\n        token_id: TokenId,\n    ) -> Result<()> {\n        self.safe_transfer_from_with_data(from, to, token_id, Vec::default())\n    }\n")),(0,o.kt)("h3",{id:"safe_transfer_from_with_data"},"safe_transfer_from_with_data"),(0,o.kt)("p",null,"Safely transfers ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," token from ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"to"),"."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"from")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"to")," cannot be the zero address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," token must exist and be owned by ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),"."),(0,o.kt)("li",{parentName:"ul"},"If the caller is not ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),", it must be approved to move this token by either ",(0,o.kt)("inlineCode",{parentName:"li"},"approve")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"set_approval_for_all"),"."),(0,o.kt)("li",{parentName:"ul"},"If ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," refers to a smart contract, it must implement ",(0,o.kt)("inlineCode",{parentName:"li"},"on_erc721_received"),", which is called upon a safe transfer.")),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn safe_transfer_from_with_data(\n        &mut self,\n        from: E::AccountId,\n        to: E::AccountId,\n        token_id: TokenId,\n        data: Vec<u8>,\n    ) -> Result<()> {\n        assert!(\n            self._is_approved_or_owner(&Self::caller(), &token_id),\n            "ERC721: transfer caller is not owner nor approved"\n        );\n\n        self._safe_transfer(from, to, token_id, data)\n    }\n')),(0,o.kt)("h2",{id:"immutable-message"},"Immutable Message"),(0,o.kt)("h3",{id:"name"},"name"),(0,o.kt)("p",null,"Returns the name of the token."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Returns the name of the token.\n    fn name(&self) -> String {\n        self.get().name().clone()\n    }\n")),(0,o.kt)("h3",{id:"symbol"},"symbol"),(0,o.kt)("p",null,"Returns the symbol of the token, usually a shorter version of the name."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn symbol(&self) -> String {\n        self.get().symbol().clone()\n    }\n")),(0,o.kt)("h3",{id:"token_url"},"token_url"),(0,o.kt)("p",null,"Returns the Uniform Resource Identifier (URI) for ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," token."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn token_url(&self, token_id: &TokenId) -> String {\n        assert!(\n            self._exists(token_id),\n            "ERC721Metadata: URI query for nonexistent token"\n        );\n\n        let mut base_url = self._base_url().clone();\n\n        match base_url.len() {\n            0 => String::from(""),\n            _ => {\n                base_url.push_str(token_id.to_string().as_str());\n                base_url\n            }\n        }\n    }\n')),(0,o.kt)("h3",{id:"balance_of"},"balance_of"),(0,o.kt)("p",null,"Returns the number of tokens in ",(0,o.kt)("inlineCode",{parentName:"p"},"owner"),"'s account."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn balance_of(&self, account: &E::AccountId) -> u64 {\n        self.get().balance_of(account)\n    }\n")),(0,o.kt)("h3",{id:"owner_of"},"owner_of"),(0,o.kt)("p",null,"Returns the owner of the ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," token."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," must exist.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn owner_of(&self, token_id: &TokenId) -> E::AccountId {\n        match self.get().owners.get(token_id) {\n            Some(owner) => owner.clone(),\n            None => panic!("ERC721: owner query for nonexistent token"),\n        }\n    }\n')),(0,o.kt)("h3",{id:"get_approved"},"get_approved"),(0,o.kt)("p",null,"Returns the account approved for ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," token."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," must exist.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn get_approved(&self, token_id: &TokenId) -> Option<E::AccountId> {\n        assert!(\n            self._exists(token_id),\n            "ERC721: approved query for nonexistent token"\n        );\n\n        match self.get().token_approvals.get(token_id) {\n            Some(a) => Some(a.clone()),\n            None => None,\n        }\n    }\n')),(0,o.kt)("h3",{id:"is_approved_for_all"},"is_approved_for_all"),(0,o.kt)("p",null,"Returns if the ",(0,o.kt)("inlineCode",{parentName:"p"},"operator")," is allowed to manage all of the assets of ",(0,o.kt)("inlineCode",{parentName:"p"},"owner"),"."),(0,o.kt)("p",null,"See ",(0,o.kt)("inlineCode",{parentName:"p"},"set_approval_for_all")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn is_approved_for_all(&self, owner: &E::AccountId, operator: &E::AccountId) -> bool {\n        self.get()\n            .is_approved_for_all(owner.clone(), operator.clone())\n    }\n")),(0,o.kt)("h2",{id:"internal-message"},"Internal Message"),(0,o.kt)("p",null,"If the contract need make some logic by token, developers can based on this apis:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_exists")," : is a token_id exists"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_mint"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"_safe_mint")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"_safe_mint_with_data")," : mint token to a account with amount"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"_burn")," : burn token from a account by amount")),(0,o.kt)("h3",{id:"_exists"},"_exists"),(0,o.kt)("p",null,"Returns whether ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," exists."),(0,o.kt)("p",null,"Tokens can be managed by their owner or approved accounts via\n",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"set_approval_for_all"),"."),(0,o.kt)("p",null,"Tokens start existing when they are minted (",(0,o.kt)("inlineCode",{parentName:"p"},"_mint"),"),\nand stop existing when they are burned (",(0,o.kt)("inlineCode",{parentName:"p"},"_burn"),")."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _exists(&self, token_id: &TokenId) -> bool {\n        match self.get().owners.get(token_id) {\n            Some(_) => true,\n            None => false,\n        }\n    }\n")),(0,o.kt)("h3",{id:"_mint"},"_mint"),(0,o.kt)("p",null,"Mints ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," and transfers it to ",(0,o.kt)("inlineCode",{parentName:"p"},"to"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"WARNING: Usage of this method is discouraged, use ",(0,o.kt)("inlineCode",{parentName:"p"},"_safe_mint")," whenever possible")),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," must not exist."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"to")," cannot be the zero address.")),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn _mint(&mut self, to: &E::AccountId, token_id: &TokenId) -> Result<()> {\n        assert!(\n            *to != E::AccountId::default(),\n            "ERC721: mint to the zero address"\n        );\n        assert!(!self._exists(token_id), "ERC721: token already minted");\n\n        self._before_token_transfer(None, Some(to.clone()), token_id)?;\n\n        self.get_mut().balance_inc(to);\n        self.get_mut().owners.insert(token_id.clone(), to.clone());\n\n        self.emit_event_transfer(None, Some(to.clone()), token_id.clone());\n\n        Ok(())\n    }\n')),(0,o.kt)("h3",{id:"_safe_mint"},"_safe_mint"),(0,o.kt)("p",null,"Safely mints ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," and transfers it to ",(0,o.kt)("inlineCode",{parentName:"p"},"to"),"."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," must not exist."),(0,o.kt)("li",{parentName:"ul"},"If ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," refers to a smart contract, it must implement ",(0,o.kt)("inlineCode",{parentName:"li"},"on_erc721_received"),", which is called upon a safe transfer.")),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _safe_mint(&mut self, to: E::AccountId, token_id: TokenId) -> Result<()> {\n        self._safe_mint_with_data(to, token_id, Vec::default())\n    }\n")),(0,o.kt)("h3",{id:"_safe_mint_with_data"},"_safe_mint_with_data"),(0,o.kt)("p",null,"Same as ",(0,o.kt)("inlineCode",{parentName:"p"},"_safe_mint"),", with an additional ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," parameter which is forwarded in ",(0,o.kt)("inlineCode",{parentName:"p"},"on_erc721_received")," to contract recipients."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    fn _safe_mint_with_data(\n        &mut self,\n        to: E::AccountId,\n        token_id: TokenId,\n        data: Vec<u8>,\n    ) -> Result<()> {\n        self._mint(&to, &token_id)?;\n\n        assert!(\n            self._check_on_erc721_received(E::AccountId::default(), to, token_id, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n\n        Ok(())\n    }\n')),(0,o.kt)("h3",{id:"_burn"},"_burn"),(0,o.kt)("p",null,"Destroys ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id"),".\nThe approval is cleared when the token is burned."),(0,o.kt)("p",null,"Requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," must exist.")),(0,o.kt)("p",null,"Emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _burn(&mut self, token_id: &TokenId) -> Result<()> {\n        let owner = self.owner_of(token_id);\n\n        self._before_token_transfer(Some(owner.clone()), None, token_id)?;\n\n        // Clear approvals\n        self._approve(None, token_id);\n\n        self.get_mut().balance_dec(&owner);\n\n        self.get_mut().owners.take(token_id);\n\n        self.emit_event_transfer(Some(owner), None, *token_id);\n\n        Ok(())\n    }\n")),(0,o.kt)("h2",{id:"hooks"},"Hooks"),(0,o.kt)("p",null,"ERC721 have two hooks : ",(0,o.kt)("inlineCode",{parentName:"p"},"_before_token_transfer")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"_base_url"),":"),(0,o.kt)("h3",{id:"_before_token_transfer"},"_before_token_transfer"),(0,o.kt)("p",null,"Hook that is called before any token transfer. This includes minting and burning."),(0,o.kt)("p",null,"Calling conditions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When ",(0,o.kt)("inlineCode",{parentName:"li"},"from")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," are both non-zero, ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),"'s ",(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," will be\ntransferred to ",(0,o.kt)("inlineCode",{parentName:"li"},"to"),"."),(0,o.kt)("li",{parentName:"ul"},"When ",(0,o.kt)("inlineCode",{parentName:"li"},"from")," is zero, ",(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," will be minted for ",(0,o.kt)("inlineCode",{parentName:"li"},"to"),"."),(0,o.kt)("li",{parentName:"ul"},"When ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," is zero, ",(0,o.kt)("inlineCode",{parentName:"li"},"from"),"'s ",(0,o.kt)("inlineCode",{parentName:"li"},"token_id")," will be burned."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"from")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"to")," are never both zero.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _before_token_transfer(\n        &mut self,\n        from: Option<E::AccountId>,\n        to: Option<E::AccountId>,\n        token_id: &TokenId,\n    ) -> Result<()>;\n")),(0,o.kt)("h3",{id:"_base_url"},"_base_url"),(0,o.kt)("p",null,"Base URI for computing ",(0,o.kt)("inlineCode",{parentName:"p"},"token_url"),". If set, the resulting URI for each\ntoken will be the concatenation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"baseURI")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id"),". Empty\nby default, can be overriden in child contracts."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn _base_url(&self) -> String;\n")),(0,o.kt)("h2",{id:"events"},"Events"),(0,o.kt)("h3",{id:"transfer"},"Transfer"),(0,o.kt)("p",null,"Emitted when ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," token is transferred from ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"to"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc721)]\n    pub struct Transfer {\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        pub token_id: TokenId,\n    }\n")),(0,o.kt)("h3",{id:"approval"},"Approval"),(0,o.kt)("p",null,"Emitted when ",(0,o.kt)("inlineCode",{parentName:"p"},"owner")," enables ",(0,o.kt)("inlineCode",{parentName:"p"},"approved")," to manage the ",(0,o.kt)("inlineCode",{parentName:"p"},"token_id")," token."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc721)]\n    pub struct Approval {\n        #[ink(topic)]\n        pub owner: AccountId,\n        #[ink(topic)]\n        pub spender: Option<AccountId>,\n        pub token_id: TokenId,\n    }\n")),(0,o.kt)("h3",{id:"approvalforall"},"ApprovalForAll"),(0,o.kt)("p",null,"Emitted when ",(0,o.kt)("inlineCode",{parentName:"p"},"owner")," enables or disables (",(0,o.kt)("inlineCode",{parentName:"p"},"approved"),") ",(0,o.kt)("inlineCode",{parentName:"p"},"operator")," to manage all of its assets."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(event)]\n    #[metis(erc721)]\n    pub struct ApprovalForAll {\n        #[ink(topic)]\n        pub owner: AccountId,\n        #[ink(topic)]\n        pub operator: AccountId,\n        pub approved: bool,\n    }\n")),(0,o.kt)("h2",{id:"extensions"},"Extensions"),(0,o.kt)("h3",{id:"erc721pausable"},"ERC721Pausable"),(0,o.kt)("p",null,"ERC721 token with pausable token transfers, minting and burning."),(0,o.kt)("p",null,"Useful for scenarios such as preventing trades until the end of an evaluation period, or having an emergency switch for freezing all token transfers in the event of a large bug."),(0,o.kt)("p",null,"FUNCTIONS"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"_beforeTokenTransfer(from, to, tokenId)")),(0,o.kt)("p",null,"For details, please refer ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/crates/components/token/erc721/src/extensions/pausable.rs"},"ERC721Pausable")," for source code."),(0,o.kt)("p",null,"Usage examples can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/example/contracts/token/erc721-pausable/lib.rs"},"here")," "),(0,o.kt)("h3",{id:"erc721burnable"},"ERC721Burnable"),(0,o.kt)("p",null,"ERC721 Token that can be irreversibly burned (destroyed)."),(0,o.kt)("p",null,"FUNCTIONS"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"burn(tokenId)")),(0,o.kt)("p",null,"For details, please refer ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/crates/components/token/erc721/src/extensions/burnable.rs"},"ERC721Burnable")," for source code."),(0,o.kt)("p",null,"Usage examples can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/example/contracts/token/erc721-burnable/lib.rs"},"here")," "),(0,o.kt)("h3",{id:"erc721uristorage"},"ERC721URIStorage"),(0,o.kt)("p",null,"ERC721 token with storage based token URI management."),(0,o.kt)("p",null,"FUNCTIONS"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"tokenURI(tokenId)")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"_setTokenURI(tokenId, _tokenURI)")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"_burn(tokenId)")),(0,o.kt)("p",null,"For details, please refer ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/2a322d7c202708383df20739bd90ed75c2c03e4a/crates/components/token/erc20/src/extensions/capped.rs"},"ERC20Capped")," for source code."),(0,o.kt)("p",null,"Usage examples can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/blob/main/example/contracts/token/erc20-capped/lib.rs"},"here")," "),(0,o.kt)("h2",{id:"usage-example"},"Usage Example"),(0,o.kt)("p",null,"To make a new erc721-like token, we should import erc721 at first:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[metis_lang::contract]\npub mod contract {\n    use ink_prelude::{\n        string::String,\n        vec::Vec,\n    };\n    use metis_erc721 as erc721;\n    pub use metis_erc721::{\n        Error,\n        Result,\n        TokenId,\n    };\n    use metis_lang::{\n        import,\n        metis,\n    };\n\n    /// A ERC721 contract.\n    #[ink(storage)]\n    #[import(erc721)]\n    pub struct Erc721 {\n        erc721: erc721::Data<Erc721>,\n    }\n\n    // other logics\n}\n")),(0,o.kt)("p",null,"Then add the event for erc721:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Emitted when `token_id` token is transferred from `from` to `to`.\n    #[ink(event)]\n    #[metis(erc721)]\n    pub struct Transfer {\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        pub token_id: TokenId,\n    }\n\n    /// Emitted when `owner` enables `approved` to manage the `token_id` token.\n    #[ink(event)]\n    #[metis(erc721)]\n    pub struct Approval {\n        #[ink(topic)]\n        pub owner: AccountId,\n        #[ink(topic)]\n        pub spender: Option<AccountId>,\n        pub token_id: TokenId,\n    }\n\n    /// Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n    #[ink(event)]\n    #[metis(erc721)]\n    pub struct ApprovalForAll {\n        #[ink(topic)]\n        pub owner: AccountId,\n        #[ink(topic)]\n        pub operator: AccountId,\n        pub approved: bool,\n    }\n")),(0,o.kt)("p",null,"Then implement the component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    #[cfg(not(feature = "ink-as-dependency"))]\n    impl erc721::Impl<Erc721> for Erc721 {\n        /// Hook that is called before any token transfer. This includes minting\n        /// and burning.\n        ///\n        /// Calling conditions:\n        ///\n        /// - When `from` and `to` are both non-zero, `from`\'s `token_id` will be\n        /// transferred to `to`.\n        /// - When `from` is zero, `token_id` will be minted for `to`.\n        /// - When `to` is zero, `from`\'s `token_id` will be burned.\n        /// - `from` and `to` are never both zero.\n        fn _before_token_transfer(\n            &mut self,\n            _from: Option<AccountId>,\n            _to: Option<AccountId>,\n            _token_id: &TokenId,\n        ) -> Result<()> {\n            Ok(())\n        }\n\n        /// Base URI for computing `token_url`. If set, the resulting URI for each\n        /// token will be the concatenation of the `baseURI` and the `token_id`. Empty\n        /// by default, can be overriden in child contracts.\n        fn _base_url(&self) -> String {\n            String::from("https://test/")\n        }\n    }\n')),(0,o.kt)("p",null,"impl the constructor for contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"impl Erc721 {\n        /// the constructor of the contract\n        #[ink(constructor)]\n        pub fn new(name: String, symbol: String) -> Self {\n            let mut instance = Self {\n                erc721: erc721::Data::new(),\n            };\n\n            erc721::Impl::init(&mut instance, name, symbol);\n\n            // other logic\n\n            instance\n        }\n  }\n")),(0,o.kt)("p",null,"Then implement the messages for contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    impl Erc721 {\n        /// Returns the name of the token.\n        #[ink(message)]\n        pub fn name(&self) -> String {\n            erc721::Impl::name(self)\n        }\n\n        /// Returns the symbol of the token, usually a shorter version of the name.\n        #[ink(message)]\n        pub fn symbol(&self) -> String {\n            erc721::Impl::symbol(self)\n        }\n\n        /// Returns the Uniform Resource Identifier (URI) for `token_id` token.\n        #[ink(message)]\n        pub fn token_url(&self, token_id: TokenId) -> String {\n            erc721::Impl::token_url(self, &token_id)\n        }\n\n        /// @dev Returns the number of tokens in ``owner``'s account.\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> u64 {\n            erc721::Impl::balance_of(self, &owner)\n        }\n\n        /// @dev Returns the owner of the `token_id` token.\n        ///\n        /// Requirements:\n        ///\n        /// - `token_id` must exist.\n        #[ink(message)]\n        pub fn owner_of(&self, token_id: TokenId) -> AccountId {\n            erc721::Impl::owner_of(self, &token_id)\n        }\n\n        /// @dev Returns the account approved for `token_id` token.\n        ///\n        /// Requirements:\n        ///\n        /// - `token_id` must exist.\n        #[ink(message)]\n        pub fn get_approved(&self, token_id: TokenId) -> Option<AccountId> {\n            erc721::Impl::get_approved(self, &token_id)\n        }\n\n        /// @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n        ///\n        /// See {setApprovalForAll}\n        #[ink(message)]\n        pub fn is_approved_for_all(\n            &self,\n            owner: AccountId,\n            operator: AccountId,\n        ) -> bool {\n            erc721::Impl::is_approved_for_all(self, &owner, &operator)\n        }\n\n        /// @dev Gives permission to `to` to transfer `token_id` token to another account.\n        /// The approval is cleared when the token is transferred.\n        ///\n        /// Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n        ///\n        /// Requirements:\n        ///\n        /// - The caller must own the token or be an approved operator.\n        /// - `token_id` must exist.\n        ///\n        /// Emits an {Approval} event.\n        #[ink(message)]\n        pub fn approve(&mut self, to: Option<AccountId>, token_id: TokenId) {\n            erc721::Impl::approve(self, to, &token_id)\n        }\n\n        /// @dev Approve or remove `operator` as an operator for the caller.\n        /// Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n        ///\n        /// Requirements:\n        ///\n        /// - The `operator` cannot be the caller.\n        ///\n        /// Emits an {ApprovalForAll} event.\n        #[ink(message)]\n        pub fn set_approval_for_all(&mut self, operator: AccountId, approved: bool) {\n            erc721::Impl::set_approval_for_all(self, operator, approved)\n        }\n\n        /// @dev Transfers `token_id` token from `from` to `to`.\n        ///\n        /// WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n        ///\n        /// Requirements:\n        ///\n        /// - `from` cannot be the zero address.\n        /// - `to` cannot be the zero address.\n        /// - `token_id` token must be owned by `from`.\n        /// - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n        ///\n        /// Emits a {Transfer} event.\n        #[ink(message)]\n        pub fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            token_id: TokenId,\n        ) -> Result<()> {\n            erc721::Impl::transfer_from(self, from, to, token_id)\n        }\n\n        /// @dev Safely transfers `token_id` token from `from` to `to`, checking first that contract recipients\n        /// are aware of the ERC721 protocol to prevent tokens from being forever locked.\n        ///\n        /// Requirements:\n        ///\n        /// - `from` cannot be the zero address.\n        /// - `to` cannot be the zero address.\n        /// - `token_id` token must exist and be owned by `from`.\n        /// - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n        /// - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n        ///\n        /// Emits a {Transfer} event.\n        #[ink(message)]\n        pub fn safe_transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            token_id: TokenId,\n        ) -> Result<()> {\n            erc721::Impl::safe_transfer_from(self, from, to, token_id)\n        }\n\n        /// @dev Safely transfers `token_id` token from `from` to `to`.\n        ///\n        /// Requirements:\n        ///\n        /// - `from` cannot be the zero address.\n        /// - `to` cannot be the zero address.\n        /// - `token_id` token must exist and be owned by `from`.\n        /// - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n        /// - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n        ///\n        /// Emits a {Transfer} event.\n        #[ink(message)]\n        pub fn safe_transfer_from_with_data(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            token_id: TokenId,\n            data: Vec<u8>,\n        ) -> Result<()> {\n            erc721::Impl::safe_transfer_from_with_data(self, from, to, token_id, data)\n        }\n    }\n")),(0,o.kt)("p",null,"In the end, we can add some other messages."))}m.isMDXComponent=!0}}]);