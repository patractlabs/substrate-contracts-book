"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6934],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=l(n),m=r,f=d["".concat(c,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8656:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return d}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={},c="ERC20",l={unversionedId:"metis/tokens",id:"metis/tokens",isDocsHomePage:!1,title:"ERC20",description:"metis provides trait_definition and calling stub between contracts that fully complies with the ERC20 standard. com/patractlabs/metis/tree/master/stubs/token/erc20)",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/metis/tokens.md",sourceDirName:"metis",slug:"/metis/tokens",permalink:"/en/metis/tokens",editUrl:"https://github.com/patractlabs/substrate-contracts-book/docs/metis/tokens.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Metis",permalink:"/en/metis/introduction"},next:{title:"Access Control",permalink:"/en/metis/access-control"}},u=[{value:"Trait Definition",id:"trait-definition",children:[{value:"erc20 trait source code analysis",id:"erc20-trait-source-code-analysis",children:[]},{value:"Use erc20-trait to implement the contract",id:"use-erc20-trait-to-implement-the-contract",children:[]}]},{value:"Call stub across contracts",id:"call-stub-across-contracts",children:[{value:"erc20 stub source code analysis",id:"erc20-stub-source-code-analysis",children:[]},{value:"Cross-contract call through erc20 stub",id:"cross-contract-call-through-erc20-stub",children:[]}]}],p={toc:u};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"erc20"},"ERC20"),(0,o.kt)("p",null,"metis provides ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/tree/master/traits/token/erc20"},"trait_definition")," and ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/tree/master/traits/token/erc20"},"calling stub between contracts")," that fully complies with the ",(0,o.kt)("inlineCode",{parentName:"p"},"ERC20")," standard. com/patractlabs/metis/tree/master/stubs/token/erc20)\nAnd the standard implementation of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/patractlabs/metis/tree/master/impls/token/erc20"},"erc20 contract"),"."),(0,o.kt)("p",null,"The following is a detailed introduction to the use of the erc20 trait and stub provided by metis."),(0,o.kt)("h2",{id:"trait-definition"},"Trait Definition"),(0,o.kt)("p",null,"By processing macros with ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink::trait_definition]"),", developers can define their own trait definitions, which can then be implemented by ink! smart contract. This allows the definition of shared smart contract interfaces for different specific implementations. Note that this ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink::trait_definition]")," can be defined anywhere, even in another crate!"),(0,o.kt)("h3",{id:"erc20-trait-source-code-analysis"},"erc20 trait source code analysis"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\n// Note: The tarit definition needs to be exported here for other packages to use\npub use self::erc20::{Error, IErc20, Result};\npub mod events {\n    // pub use crate::erc20::{Transfer, Approval};\n}\n\nuse ink_lang as ink;\n#[ink::contract]\nmod erc20 {\n    use ink_lang as ink;\n    use ink_prelude::string::String;\n    /// The ERC-20 result type.\n    pub type Result<T> = core::result::Result<T, Error>;\n\n    /// Event emitted when a token transfer occurs.\n    #[ink(event)]\n    pub struct Transfer {\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        #[ink(topic)]\n        pub value: Balance,\n    }\n    /// Event emitted when an approval occurs that `spender` is allowed to withdraw\n    /// up to the amount of `value` tokens from `owner`.\n    #[ink(event)]\n    pub struct Approval {\n        #[ink(topic)]\n        pub owner: AccountId,\n        #[ink(topic)]\n        pub spender: AccountId,\n        #[ink(topic)]\n        pub value: Balance,\n    }\n\n    /// The ERC-20 error types.\n    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]\n    pub enum Error {\n        /// Returned if not enough balance to fulfill a request is available.\n        InsufficientBalance,\n        /// Returned if not enough allowance to fulfill a request is available.\n        InsufficientAllowance,\n    }\n\n    /// Trait implemented by all ERC-20 respecting smart contracts.\n    #[ink::trait_definition]\n    pub trait IErc20 {\n        /// Creates a new ERC-20 contract with the specified initial supply.\n        #[ink(constructor)]\n        fn new(\n            initial_supply: Balance,\n            name: Option<String>,\n            symbol: Option<String>,\n            decimals: Option<u8>,\n        ) -> Self;\n\n        /// Returns the token name.\n        #[ink(message)]\n        fn token_name(&self) -> Option<String>;\n\n        /// Returns the token symbol.\n        #[ink(message)]\n        fn token_symbol(&self) -> Option<String>;\n\n        /// Returns the token decimals.\n        #[ink(message)]\n        fn token_decimals(&self) -> Option<u8>;\n        /// Returns the total token supply.\n        #[ink(message)]\n        fn total_supply(&self) -> Balance;\n        /// Returns the account balance for the specified `owner`.\n        #[ink(message)]\n        fn balance_of(&self, owner: AccountId) -> Balance;\n\n        /// Transfers `value` amount of tokens from the caller\'s account to account `to`.\n        #[ink(message)]\n        fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()>;\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.\n        #[ink(message)]\n        fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance;\n\n        /// Transfers `value` tokens on the behalf of `from` to the account `to`.\n        #[ink(message)]\n        fn transfer_from(&mut self, from: AccountId, to: AccountId, value: Balance) -> Result<()>;\n\n        /// Allows `spender` to withdraw from the caller\'s account multiple times, up to\n        /// the `value` amount.\n        #[ink(message)]\n        fn approve(&mut self, spender: AccountId, value: Balance) -> Result<()>;\n    }\n\n    // TODO tmp hack struct for passing compile\n    #[ink(storage)]\n    pub struct Phantom;\n    impl Phantom {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Phantom {}\n        }\n        #[ink(message)]\n        pub fn message(&self) {}\n    }\n}\n')),(0,o.kt)("p",null,"First, you must define ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink::trait_definition]"),", where a trait interface of ",(0,o.kt)("inlineCode",{parentName:"p"},"IErc20")," is defined. At least one of ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink(constructor)]")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink(message)]")," must be defined in trait_definition.\nAll interfaces have only declarations, not implementations."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"#[ink::trait_definition]")," can be defined separately from ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink::contract]"),". For simple traits, you only need to define trait_definition, as defined in the introduction. But in this erc20 trait\nIn the implementation, the reason why it is defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink::contract]")," is because of the existence of ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink(event)]"),". We hope to not only provide interfaces, but also provide some event and error definitions, so that developers When using our erc20-trait package, you can clearly know that it will\nWhich events are triggered and what errors occur, but the catch is that ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink(event)]")," cannot be separated from the separate definition of ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink::contract]"),", so we can only temporarily implement a ",(0,o.kt)("inlineCode",{parentName:"p"},"Phantom")," contract and store it. Make the compilation pass. We have submitted this issue as an official issue\n(Https://github.com/paritytech/ink/issues/683)."),(0,o.kt)("p",null,"After defining ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink::trait_definition]"),", pay attention to exporting the trait, such as: ",(0,o.kt)("inlineCode",{parentName:"p"},"pub use self::erc20::{Error, IErc20, Result};"),", only after exporting can it be used by other crates ."),(0,o.kt)("h3",{id:"use-erc20-trait-to-implement-the-contract"},"Use erc20-trait to implement the contract"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Create a new contract")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"cargo contract new myerc20\n")),(0,o.kt)("p",null,"Note: The ink! dependencies of all contracts in metis are the codes in the latest ink warehouse, so you need to change the dependencies in the newly created contract project to the latest, otherwise it will cause version conflicts, as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nink_primitives = { version = "3.0.0-rc3", git = "https://github.com/paritytech/ink", default-features = false }\nink_metadata = { version = "3.0.0-rc3", git = "https://github.com/paritytech/ink", default-features = false, features = ["derive"], optional = true }\nink_env = { version = "3.0.0-rc3", git = "https://github.com/paritytech/ink", default-features = false }\nink_storage = { version = "3.0.0-rc3", git = "https://github.com/paritytech/ink", default-features = false }\nink_lang = { version = "3.0.0-rc3", git = "https://github.com/paritytech/ink", default-features = false }\nink_prelude = { version = "3.0.0-rc3", git = "https://github.com/paritytech/ink", default-features = false }\n')),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Add the ",(0,o.kt)("inlineCode",{parentName:"li"},"erc20-trait")," package to the ",(0,o.kt)("inlineCode",{parentName:"li"},"cargo.toml")," dependency of the new contract project")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nerc20-trait = { git = "https://github.com/patractlabs/metis", default-features = false, features = ["ink-as-dependency"] }\n\n[features]\ndefault = ["std"]\nstd = [\n    "erc20-trait/std",\n]\n')),(0,o.kt)("p",null,"When adding a dependency here, the ",(0,o.kt)("inlineCode",{parentName:"p"},'features = ["ink-as-dependency"]')," feature is enabled because it is in ink! As a dependency, the Chinese contract needs to be turned on and modified."),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"Implement the erc20 trait in the new contract project")),(0,o.kt)("p",null,"The complete code is at: ",(0,o.kt)("inlineCode",{parentName:"p"},"https://github.com/patractlabs/metis/blob/master/impls/token/erc20")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod erc20 {\n    // Here you need to import the interface and errors defined in erc20_trait\n    use erc20_trait::{Error, IErc20, Result};\n    use ink_prelude::string::String;\n\n    /// Basic version of StandardToken, with no allowances.\n    #[ink(storage)]\n    pub struct Erc20 {\n        /// Total token supply.\n        total_supply: Lazy<Balance>,\n        /// Mapping from owner to number of owned token.\n        balances: StorageHashMap<AccountId, Balance>,\n        /// Mapping of the token amount which an account is allowed to withdraw\n        /// from another account.\n        allowances: StorageHashMap<(AccountId, AccountId), Balance>,\n        /// Name of the token\n        name: Option<String>,\n        /// Symbol of the token\n        symbol: Option<String>,\n        /// Decimals of the token\n        decimals: Option<u8>,\n    }\n\n    impl IErc20 for Erc20 {\n        #[ink(constructor)]\n        fn new(\n            initial_supply: Balance,\n            name: Option<String>,\n            symbol: Option<String>,\n            decimals: Option<u8>,\n        ) -> Self {\n            // implementation ...\n        }\n\n        // Omitted part of interface\n        \n        #[ink(message)]\n        fn transfer_from(&mut self, from: AccountId, to: AccountId, value: Balance) -> Result<()> {\n            // implementation ...\n        }\n        \n        #[ink(message)]\n        fn approve(&mut self, spender: AccountId, value: Balance) -> Result<()> {\n            // implementation ...\n        }\n    }\n}\n')),(0,o.kt)("h2",{id:"call-stub-across-contracts"},"Call stub across contracts"),(0,o.kt)("p",null,"Before that, we have implemented the standard erc20 contract through the erc20 trait, and it is essential to interact with the erc20 contract in some complex dapps. Metis provides ",(0,o.kt)("inlineCode",{parentName:"p"},"erc20-stub")," to support cross-contract calls. We have implemented the erc20 contract."),(0,o.kt)("h3",{id:"erc20-stub-source-code-analysis"},"erc20 stub source code analysis"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\n// Need to export Erc20Stub for sub-contract call\npub use self::erc20::Erc20Stub;\nuse ink_lang as ink;\n\n#[ink::contract]\nmod erc20 {\n    use ink_prelude::string::String;\n\n    /// The ERC-20 error types.\n    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]\n    pub enum Error {\n        /// Returned if not enough balance to fulfill a request is available.\n        InsufficientBalance,\n        /// Returned if not enough allowance to fulfill a request is available.\n        InsufficientAllowance,\n    }\n\n    /// The ERC-20 result type.\n    pub type Result<T> = core::result::Result<T, Error>;\n\n    #[ink(storage)]\n    pub struct Erc20Stub {}\n\n    impl Erc20Stub {\n        /// Creates a new ERC-20 contract with the specified initial supply.\n        #[ink(constructor)]\n        pub fn new(\n            _initial_supply: Balance,\n            _name: Option<String>,\n            _symbol: Option<String>,\n            _decimals: Option<u8>,\n        ) -> Self {\n            unimplemented!()\n        }\n\n        /// Returns the token name.\n        #[ink(message, selector = "0x6b1bb951")]\n        pub fn token_name(&self) -> Option<String> {\n            unimplemented!()\n        }\n\n        /// Returns the token symbol.\n        #[ink(message, selector = "0xb42c3368")]\n        pub fn token_symbol(&self) -> Option<String> {\n            unimplemented!()\n        }\n\n        /// Returns the token decimals.\n        #[ink(message, selector = "0xc64b0eb2")]\n        pub fn token_decimals(&self) -> Option<u8> {\n            unimplemented!()\n        }\n\n        /// Returns the total token supply.\n        #[ink(message, selector = "0x143862ae")]\n        pub fn total_supply(&self) -> Balance {\n            unimplemented!()\n        }\n\n        /// Returns the account balance for the specified `owner`.\n        #[ink(message, selector = "0xb7d968c9")]\n        pub fn balance_of(&self, _owner: AccountId) -> Balance {\n            unimplemented!()\n        }\n\n        /// Transfers `value` amount of tokens from the caller\'s account to account `to`.\n        #[ink(message, selector = "0x10d455c2")]\n        pub fn transfer(&mut self, _to: AccountId, _value: Balance) -> Result<()> {\n            unimplemented!()\n        }\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.\n        #[ink(message, selector = "0xc04aa300")]\n        pub fn allowance(&self, _owner: AccountId, _spender: AccountId) -> Balance {\n            unimplemented!()\n        }\n\n        /// Transfers `value` tokens on the behalf of `from` to the account `to`.\n        #[ink(message, selector = "0xbb399017")]\n        pub fn transfer_from(\n            &mut self,\n            _from: AccountId,\n            _to: AccountId,\n            _value: Balance,\n        ) -> Result<()> {\n            unimplemented!()\n        }\n\n        /// Allows `spender` to withdraw from the caller\'s account multiple times, up to\n        /// the `value` amount.\n        #[ink(message, selector = "0x4ce0e831")]\n        pub fn approve(&mut self, _spender: AccountId, _value: Balance) -> Result<()> {\n            unimplemented!()\n        }\n    }\n}\n')),(0,o.kt)("p",null,"From the above code, we can know that there is no erc20 specific logic implementation in the stub contract, only an empty implementation of the interface is provided, and the contract will be instantiated by the child contract as the parent contract.\nAnd you can call the interface of the parent contract in the child contract."),(0,o.kt)("p",null,"Note: In the erc20-stub contract, the ",(0,o.kt)("inlineCode",{parentName:"p"},"selector")," of each contract method is set with a fixed value, where the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"selector")," is determined by ",(0,o.kt)("inlineCode",{parentName:"p"},'BLAKE2("IErc20::{message_func_name}".to_string().as_bytes ())[0..4]'),"\nThe formula is calculated."),(0,o.kt)("p",null,"The calculation method of ",(0,o.kt)("inlineCode",{parentName:"p"},"selector")," in the ink! system is different from that of solidity. In solidity, the method signature is hashed, while in ink! there is a set of calculation methods. The simplest one is for ",(0,o.kt)("inlineCode",{parentName:"p"},"{message_func_name} "),"\nPerform hash operation, but when message is implemented by ",(0,o.kt)("inlineCode",{parentName:"p"},"#[ink::trait_definition]"),", use {trait_name} + {message_func_name} mixed hash method, detailed calculation rules,\nYou can check ink! Source code (",(0,o.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/blob/master/crates/lang/ir/src/ir/item_impl/callable.rs#L190"},"https://github.com/paritytech/ink/blob/master/crates/lang/ir/src/ir/item_impl/callable.rs#L190"),")."),(0,o.kt)("p",null,"Therefore, erc20-stub is only applicable to cross-contract calls of the erc20 contract implemented in metis (implemented through the IErc20 trait). If it is an erc20 contract implemented in other ways, this stub cannot be used due to the mismatch of ",(0,o.kt)("inlineCode",{parentName:"p"},"selector"),"."),(0,o.kt)("h3",{id:"cross-contract-call-through-erc20-stub"},"Cross-contract call through erc20 stub"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Add the ",(0,o.kt)("inlineCode",{parentName:"li"},"erc20-stub")," package to the ",(0,o.kt)("inlineCode",{parentName:"li"},"cargo.toml")," dependency of the new contract project")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nerc20-stub = {git = "https://github.com/patractlabs/metis", default-features = false, features = ["ink-as-dependency"]}\n\n[features]\ndefault = ["std"]\nstd = [\n    "erc20-stub/std",\n]\n')),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Instantiate erc20 stub in the new contract")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod delegate {\n    use erc20_stub::Erc20Stub;\n    use ink_env::call::FromAccountId;\n    use ink_storage::Lazy;\n\n    #[ink(storage)]\n    pub struct CrossCall {\n        callee: Lazy<Erc20Stub>,\n    }\n\n    impl CrossCall {\n        #[ink(constructor)]\n        pub fn new(callee: AccountId) -> Self {\n            let token: Erc20Stub = FromAccountId::from_account_id(callee);\n            Self { callee: Lazy::new(token) }\n        }\n\n        #[ink(message)]\n        pub fn transfer(&mut self, owner: AccountId, amount: Balance) {\n            self.callee.transfer(owner, amount).unwrap();\n        }\n    }\n}\n')),(0,o.kt)("p",null,"In the ink! contract, you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"FromAccountId")," to instantiate the contract object (not to create a new contract), and then you can use the contract object to make cross-contract calls to contract methods."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("inlineCode",{parentName:"p"},"ink_storage::Lazy")," manages data entities and delays the execution of read/write operations on the storage. Only when it is determined that reading/writing is really needed, it will be executed on the storage.")))}d.isMDXComponent=!0}}]);