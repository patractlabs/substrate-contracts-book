"use strict";(self.webpackChunksubstrate_contracts_book=self.webpackChunksubstrate_contracts_book||[]).push([[9128],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return d}});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=o.createContext({}),i=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=i(e.components);return o.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},p=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=i(t),d=r,_=p["".concat(s,".").concat(d)]||p[d]||m[d]||a;return t?o.createElement(_,l(l({ref:n},u),{},{components:t})):o.createElement(_,l({ref:n},u))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,l=new Array(a);l[0]=p;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,l[1]=c;for(var i=2;i<a;i++)l[i]=t[i];return o.createElement.apply(null,l)}return o.createElement.apply(null,t)}p.displayName="MDXCreateElement"},7152:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return i},toc:function(){return u},default:function(){return p}});var o=t(7462),r=t(3366),a=(t(7294),t(3905)),l=["components"],c={},s="Access Control Enumerable",i={unversionedId:"metis/guides/access-control/access-control-enumerable",id:"metis/guides/access-control/access-control-enumerable",isDocsHomePage:!1,title:"Access Control Enumerable",description:"Extension of Access Control Component that allows enumerating the members of each role.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/metis/guides/access-control/access-control-enumerable.md",sourceDirName:"metis/guides/access-control",slug:"/metis/guides/access-control/access-control-enumerable",permalink:"/substrate-contracts-book/en/metis/guides/access-control/access-control-enumerable",editUrl:"https://github.com/patractlabs/substrate-contracts-book/docs/metis/guides/access-control/access-control-enumerable.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Access Control",permalink:"/substrate-contracts-book/en/metis/guides/access-control/access-control"},next:{title:"Timelock Controller",permalink:"/substrate-contracts-book/en/metis/guides/governance/timelock-controller"}},u=[{value:"Dependency",id:"dependency",children:[]},{value:"Storage",id:"storage",children:[]},{value:"Immutable Messages",id:"immutable-messages",children:[{value:"get_role_member",id:"get_role_member",children:[]},{value:"get_role_member_count",id:"get_role_member_count",children:[]}]},{value:"Example Usage",id:"example-usage",children:[]}],m={toc:u};function p(e){var n=e.components,t=(0,r.Z)(e,l);return(0,a.kt)("wrapper",(0,o.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"access-control-enumerable"},"Access Control Enumerable"),(0,a.kt)("p",null,"Extension of ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control")," Component that allows enumerating the members of each role."),(0,a.kt)("h2",{id:"dependency"},"Dependency"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'metis_access_control_enumerable = { git = "https://github.com/patractlabs/metis", default-features = false }\n')),(0,a.kt)("h2",{id:"storage"},"Storage"),(0,a.kt)("p",null,"As the ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control Enumerable")," is the extension of ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control"),", it has ",(0,a.kt)("inlineCode",{parentName:"p"},"role_members")," for check mapping between ",(0,a.kt)("inlineCode",{parentName:"p"},"roleId")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"accountId"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Data<E: Env> {\n    role_members: StorageHashMap<RoleId, Vec<E::AccountId>>,\n}\n")),(0,a.kt)("h2",{id:"immutable-messages"},"Immutable Messages"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control Enumerable")," add ",(0,a.kt)("inlineCode",{parentName:"p"},"get_role_member")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"get_role_member_count")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control"),"."),(0,a.kt)("h3",{id:"get_role_member"},"get_role_member"),(0,a.kt)("p",null,"Returns one of the accounts that have ",(0,a.kt)("inlineCode",{parentName:"p"},"role"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"index")," must be a value between 0 and ",(0,a.kt)("inlineCode",{parentName:"p"},"get_role_member_count"),", non-inclusive."),(0,a.kt)("p",null,"Role bearers are not sorted in any particular way, and their ordering may change at any point."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"WARNING: When using ",(0,a.kt)("inlineCode",{parentName:"p"},"get_role_member")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"get_role_member_count"),", make sure\nyou perform all queries on the same block. See the following\n",(0,a.kt)("a",{parentName:"p",href:"https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296"},"forum post"),"\nfor more information.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'    fn get_role_member(&self, role: &RoleId, index: usize) -> E::AccountId {\n        match Storage::<E, Data<E>>::get(self).role_members.get(role) {\n            None => panic!("no found role by id"),\n            Some(members) => members[index].clone(), // will panic when out of index\n        }\n    }\n')),(0,a.kt)("h3",{id:"get_role_member_count"},"get_role_member_count"),(0,a.kt)("p",null,"Returns the number of accounts that have ",(0,a.kt)("inlineCode",{parentName:"p"},"role"),". Can be used together with {getRoleMember} to enumerate all bearers of a role."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'    fn get_role_member_count(&self, role: &RoleId) -> usize {\n        match Storage::<E, Data<E>>::get(self).role_members.get(role) {\n            None => panic!("no found role by id"),\n            Some(members) => members.len(),\n        }\n    }\n')),(0,a.kt)("h2",{id:"example-usage"},"Example Usage"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Access Control Enumerable")," is the extension of ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control"),", to use this, need import ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[metis_lang::contract]\npub mod contracts {\n    pub use access_control_enumerable::{\n        Error,\n        Result,\n        RoleId,\n    };\n    use metis_access_control_enumerable as access_control_enumerable;\n    use metis_access_control as access_control;\n    use metis_lang::{\n        import,\n        metis,\n    };\n\n    #[ink(storage)]\n    #[import(access_control, access_control_enumerable)]\n    pub struct AccessControl {\n        access_control: access_control::Data<AccessControl>,\n        access_control_enumerable : access_control_enumerable::Data<AccessControl>,\n\n        value: bool,\n    }\n\n    // ...\n}\n")),(0,a.kt)("p",null,"Then Impl the ",(0,a.kt)("inlineCode",{parentName:"p"},"access_control_enumerable")," for contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    // Note `use metis_access_control_enumerable as access_control_enumerable;`\n    impl access_control_enumerable::Impl<AccessControl> for AccessControl{}\n")),(0,a.kt)("p",null,"Define the events by ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control Enumerable")," Component:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Emitted when `new_admin_role` is set as ``role``'s admin role,\n    /// replacing `previous_admin_role`\n    #[ink(event)]\n    #[metis(access_control)]\n    pub struct RoleAdminChanged {\n        #[ink(topic)]\n        pub role: RoleId,\n        #[ink(topic)]\n        pub previous_admin_role: Option<RoleId>,\n        #[ink(topic)]\n        pub new_admin_role: RoleId,\n    }\n\n    /// Emitted when `account` is granted `role`.\n    ///\n    /// `sender` is the account that originated the contract call, an admin role\n    /// bearer except when using {_setup_role}.\n    #[ink(event)]\n    #[metis(access_control)]\n    pub struct RoleGranted {\n        #[ink(topic)]\n        pub role: RoleId,\n        #[ink(topic)]\n        pub account: AccountId,\n        #[ink(topic)]\n        pub sender: AccountId,\n    }\n\n    /// Emitted when `account` is revoked `role`.\n    ///\n    /// `sender` is the account that originated the contract call:\n    ///   - if using `revoke_role`, it is the admin role bearer\n    ///   - if using `renounce_role`, it is the role bearer (i.e. `account`)\n    #[ink(event)]\n    #[metis(access_control)]\n    pub struct RoleRevoked {\n        #[ink(topic)]\n        pub role: RoleId,\n        #[ink(topic)]\n        pub account: AccountId,\n        #[ink(topic)]\n        pub sender: AccountId,\n    }\n")),(0,a.kt)("p",null,"Other is same as ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control")," Component, Need to use ",(0,a.kt)("inlineCode",{parentName:"p"},"access_control_enumerable")," as it changed some logic for ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control")," Component."),(0,a.kt)("p",null,"Impl the constructor:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    #[ink(constructor)]\n    pub fn new(\n        fliper: AccountId,\n        setter: AccountId,\n        admin: AccountId,\n    ) -> Self {\n        // need new both `access_control` and `access_control_enumerable`\n        let mut instance = Self {\n            access_control: access_control::Data::new(),\n            access_control_enumerable: access_control_enumerable::Data::new(),\n\n            // other logics\n        };\n\n        // use _setup_role to initialize the role\n        access_control_enumerable::Impl::_setup_role(&mut instance, ROLE_ID_A, fliper);\n        access_control_enumerable::Impl::_setup_role(&mut instance, ROLE_ID_B, setter);\n        access_control_enumerable::Impl::_setup_role(&mut instance, ROLE_ID_C, admin);\n\n        // use _set_role_admin to initialize the admin role\n        access_control_enumerable::Impl::_set_role_admin(\n            &mut instance,\n            ROLE_ID_A,\n            ROLE_ID_C,\n        );\n\n        // create the default role\n        instance\n    }\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"WARNNING")," : MUST use ",(0,a.kt)("inlineCode",{parentName:"p"},"access_control_enumerable::Impl::xxxx")," function call to use access_control_enumerable")),(0,a.kt)("p",null,"Define Messages for ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control")," Component:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Returns `true` if `account` has been granted `role`.\n    #[ink(message)]\n    pub fn has_role(&self, role: RoleId, account: AccountId) -> bool {\n        access_control_enumerable::Impl::has_role(self, role, account)\n    }\n\n    /// Returns the admin role that controls `role`. See {grant_role} and\n    /// {revoke_role}.\n    ///\n    /// To change a role's admin, use {_set_role_admin}.\n    #[ink(message)]\n    pub fn get_role_admin(&self, role: RoleId) -> Option<RoleId> {\n        access_control_enumerable::Impl::get_role_admin(self, role)\n    }\n\n    /// Grants `role` to `account`.\n    ///\n    /// If `account` had not been already granted `role`, emits a {RoleGranted}\n    /// event.\n    ///\n    /// Requirements:\n    ///\n    /// - the caller must have ``role``'s admin role.\n    #[ink(message)]\n    pub fn grant_role(&mut self, role: RoleId, account: AccountId) {\n        access_control_enumerable::Impl::grant_role(self, role, account)\n    }\n\n    /// Revokes `role` from `account`.\n    ///\n    /// If `account` had been granted `role`, emits a {RoleRevoked} event.\n    ///\n    /// Requirements:\n    ///\n    /// - the caller must have ``role``'s admin role.\n    #[ink(message)]\n    pub fn revoke_role(&mut self, role: RoleId, account: AccountId) {\n        access_control_enumerable::Impl::revoke_role(self, role, account)\n    }\n\n    /// Revokes `role` from the calling account.\n    ///\n    /// Roles are often managed via {grant_role} and {revoke_role}: this function's\n    /// purpose is to provide a mechanism for accounts to lose their privileges\n    /// if they are compromised (such as when a trusted device is misplaced).\n    ///\n    /// If the calling account had been granted `role`, emits a {RoleRevoked}\n    /// event.\n    ///\n    /// Requirements:\n    ///\n    /// - the caller must be `account`.\n    #[ink(message)]\n    pub fn renounce_role(&mut self, role: RoleId, account: AccountId) {\n        access_control_enumerable::Impl::renounce_role(self, role, account)\n    }\n")),(0,a.kt)("p",null,"Note the message from ",(0,a.kt)("inlineCode",{parentName:"p"},"Access Control Enumerable")," Component:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Returns one of the accounts that have `role`. `index` must be a\n    /// value between 0 and {get_role_member_count}, non-inclusive.\n    ///\n    /// Role bearers are not sorted in any particular way, and their ordering may\n    /// change at any point.\n    ///\n    /// WARNING: When using {get_role_member} and {get_role_member_count}, make sure\n    /// you perform all queries on the same block.\n    #[ink(message)]\n    pub fn get_role_member(&self, role: RoleId, index: u32) -> AccountId {\n        access_control_enumerable::Impl::get_role_member(self, &role, index as usize)\n    }\n\n    /// Returns the number of accounts that have `role`. Can be used\n    /// together with {getRoleMember} to enumerate all bearers of a role.\n    #[ink(message)]\n    pub fn get_role_member_count(&self, role: RoleId) -> u32 {\n        access_control_enumerable::Impl::get_role_member_count(self, &role) as u32\n    }\n")),(0,a.kt)("p",null,"To Use Roles to control the access in contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"        // set the state of contract, need setter role\n        #[ink(message)]\n        pub fn set(&mut self, value: bool) {\n            access_control_enumerable::Impl::ensure_caller_role(self, ROLE_ID_SETTER);\n\n            self.value = value;\n        }\n")),(0,a.kt)("p",null,"This functions can use:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"ensure_role : Panic if ",(0,a.kt)("inlineCode",{parentName:"li"},"owner")," is not an owner"),(0,a.kt)("li",{parentName:"ul"},"ensure_caller_role : Panic if caller is not granted role"),(0,a.kt)("li",{parentName:"ul"},"ensure_admin_role : Panic error if ",(0,a.kt)("inlineCode",{parentName:"li"},"account")," is missing the admin role of the ",(0,a.kt)("inlineCode",{parentName:"li"},"role"),"."),(0,a.kt)("li",{parentName:"ul"},"check_role : Return error if ",(0,a.kt)("inlineCode",{parentName:"li"},"account")," is missing ",(0,a.kt)("inlineCode",{parentName:"li"},"role"),"."),(0,a.kt)("li",{parentName:"ul"},"check_admin_role : Return error if ",(0,a.kt)("inlineCode",{parentName:"li"},"account")," is missing the admin role of the ",(0,a.kt)("inlineCode",{parentName:"li"},"role"),".")),(0,a.kt)("p",null,"In ",(0,a.kt)("a",{parentName:"p",href:"/substrate-contracts-book/en/metis/guides/access-control/access-control#internal_functions"},"Access Control APIs")))}p.isMDXComponent=!0}}]);