(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{514:function(t,e,a){t.exports=a.p+"assets/img/language_1.d4e9c39c.jpg"},515:function(t,e,a){t.exports=a.p+"assets/img/englanguage_2.dde13a7e.jpg"},593:function(t,e,a){"use strict";a.r(e);var n=a(6),o=Object(n.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"contract-language"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#contract-language"}},[t._v("#")]),t._v(" Contract language")]),t._v(" "),n("h2",{attrs:{id:"background-information"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background-information"}},[t._v("#")]),t._v(" Background Information")]),t._v(" "),n("p",[t._v("Corresponding to the concept of contract model, the concept of contract language can be derived.  In the previous chapter, we have separated the structure of the contract sandbox and contract model. In practical applications, some new contract platforms do not invent a new Solidity contract language like EVM, but choose some existing languages, such as Rust, C++,  AssemblyScript  and other languages. Based on this language, it adds contract-related constraints and functional logic to the existing language in the dimensions of hack syntax analysis and macros. Therefore, in many cases, it will exist in the form of frameworks, libraries, etc., such as the Rust contract language framework ink! of Frame Contract Pallet. And this kind of frameworks and libraries are not the dimensions of libraries used in usual program development. Some contract languages need to be modified to the compiler dimension, Therefore, we sometimes call it the contract language framework.")]),t._v(" "),n("h2",{attrs:{id:"correspondence-between-contract-language-and-contract-model"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#correspondence-between-contract-language-and-contract-model"}},[t._v("#")]),t._v(" Correspondence between contract language and contract model")]),t._v(" "),n("p",[n("img",{attrs:{src:a(514),alt:""}})]),t._v(" "),n("p",[t._v("As shown in the figure above, the upper part describes the relationship between EVM and Solidity. EVM and Solidity proposed earlier, and their model is consistent with the usual model relationship between computer virtual machine and language. The lower part is the correspondence between the language part after separating the contract model. Here, I will focus on the lower part of the figure. In the upper part, you can analyze it based on your own experience in Ethereum  contract development compared with the introduction later.")]),t._v(" "),n("p",[t._v("In the system of compiled languages, for the convenience of the following introduction, first briefly define the following concepts (non-rigorous terms):")]),t._v(" "),n("ul",[n("li",[t._v("S language: The original language (Source) for programmers to write code. For example, if C++ is compiled into assembly, then C++ is the original language S.")]),t._v(" "),n("li",[t._v("T language: the language (Target) generated after the original language is compiled by the compiler. For example, if C++ is compiled into assembly, the assembly is the target language T.")])]),t._v(" "),n("p",[t._v("The previous article introduced that the environment for running the contract system can be logically split into a contract model and a contract virtual machine. The contract model manages the business logic of the contract, and the contract virtual machine manages how to run the code of the contract. Correspondingly, the contract language part can also be split into the contract language and the S language compiled into the contract virtual machine.")]),t._v(" "),n("p",[t._v("According to this definition, it is clear that Solidity is a product that has both contract language and S language features.")]),t._v(" "),n("ol",[n("li",[t._v("Solidity has a Turing complete language system, so Solidity is a language (compared with BTC scripts).")]),t._v(" "),n("li",[t._v("The grammar of Solidity has many keywords with contract characteristics, corresponding to the concept of contract language. Such as：\n| keywords              | Description                         |\n|:----|:----|\n|mapping|Typical case of contract storage|\n|msg.sender、msg.value|Variables related to contract calls|\n|view、pure|Modifier，Play a modifying role|\n|call、delegate_cal|Keywords related to contract call|")])]),t._v(" "),n("p",[t._v("The above concept does not exist to support the logic that the Solidity language can execute, but to serve the business logic of the Ethereum contract virtual machine.")]),t._v(" "),n("p",[t._v("The purpose of the contract language is to correspond to the business logic of the contract model. What kind of contract model requires what kind of contract language. For example, the bottom layer of EVM is K/V type storage, so the "),n("code",[t._v("mapping")]),t._v(" designed in Solidity cannot be traversed unless extra storage is attached. The contract model of EVM contract interaction is designed as a contract calling contract mode, so the "),n("code",[t._v("call")]),t._v(" and "),n("code",[t._v("delegate_call")]),t._v(" keywords are provided in Solidity. The same applies to other contract systems.")]),t._v(" "),n("p",[t._v("The contract language is an additional function built on the S language, so the functions provided by the contract language are ultimately compiled to the T language corresponding to the S language. Some of the features required by the Blockchain, such as deterministic requirements and interface features that do not allow the use of operating system calls, will be constrained at this level. Therefore, in addition to the contract language itself providing the contract model function for the S language itself, it also needs to impose certain constraints on the language itself. This step is also a difficult place in the development and understanding of the contract language. At the same time, it is precisely because of this that contract developers have a lot of discomfort in the process of using the contract model framework. Languages such as Solidity and Move are new languages developed for contract platforms. Although there are traces of grammatical simulation of other languages, they are more friendly to contract developers in terms of constraints. The contract language that adds the contract language function to the existing language does not handle this aspect very well, which is one of the reasons why it is more difficult for contract developers to use the framework function.")]),t._v(" "),n("p",[t._v("Take ink! as an example:")]),t._v(" "),n("ul",[n("li",[t._v("The use of float should be avoided in the blockchain, because floating-point numbers may produce indeterminate behavior. Therefore, in contract/runtime development, if you need to use floating-point numbers, or when overflowing numbers are multiplied and divided, you need to introduce fixed-point numbers to deal with. Therefore, the fixed-point library provided by Substrate runtime can be introduced into the ink! contract for processing.")]),t._v(" "),n("li",[t._v("Since the contract model of "),n("code",[t._v("pallet-contracts")]),t._v(" is basically the same as EVM, the contract storage of "),n("code",[t._v("pallet-contracts")]),t._v(" is also composed of K/V. Then the contract model framework needs to deal with the various collection types provided in the standard library. Therefore, the collection types that may be used in the standard library are rewritten in ink!, and the process of processing the collection element types into K/V data is added. Therefore, in the ink! contract storage, if a collection type is designed, then only the types provided in the ink! standard library can be used. On the other hand, since the return value of ink! needs to export metadata for third-party processing, and the current metadata interface implementation is only implemented for the collection in the standard library, so the collection of the return value of the ink! method can only use the collection type of the standard library. The code example is as follows.")])]),t._v(" "),n("div",{staticClass:"language-rust extra-class"},[n("pre",{pre:!0,attrs:{class:"language-rust"}},[n("code",[n("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[ink::contract]")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mod")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token module-declaration namespace"}},[t._v("test")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Introduce Vec realized by ink")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("ink_storage"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("collections"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StorageVec")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Introduce the Vec of the standard library")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("ink_prelude"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("vec"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[ink(storage)]")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Test")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        owners"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StorageVec")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountId")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Only ink's Vec can be used")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[t._v("#[ink(message)]")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("get_owners")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountId")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Convert Vec implemented by ink to Vec implemented by standard library")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("owners"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("iter")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Clone")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("clone"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("collect")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("In summary, in the model structure:")]),t._v(" "),n("ul",[n("li",[t._v("The contract language and the contract model are in correspondence, and the characteristics of the contract language will match the contract model.")]),t._v(" "),n("li",[t._v("The contract language provides the S language with business functions for the contract model. At the same time, it also restricts the S language itself according to the requirements of the contract business logic.")])]),t._v(" "),n("p",[t._v("Because Solidity itself is positioned as a language designed for contract writing, many contract-related functions can be designed as keywords. If a language itself is not designed for contracts, then a contract language corresponding to the contract model needs to be designed based on this contract. Because it is adding new functions to this language, it is generally difficult to integrate with the language itself deeply. The final result is related to the ability of this language to expand the syntax tree. If the language itself provides more flexible interfaces (macros, plug-ins, etc.) for modifying or adding syntax trees, then the contract language can achieve more functions. If the language itself provides few such extensibility functions, then the contract language can only consider modifying the syntax required by the compiler and extensions to support the contract model, so that the final language becomes a dialect of the original language. Therefore, the former can exist in the form of a library/framework, while the latter becomes a new language, which is why this model is called a contract language.")]),t._v(" "),n("h2",{attrs:{id:"pallet-contracts-and-the-corresponding-contract-language"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pallet-contracts-and-the-corresponding-contract-language"}},[t._v("#")]),t._v(" Pallet-contracts and the corresponding contract language")]),t._v(" "),n("p",[n("img",{attrs:{src:a(515),alt:""}})]),t._v(" "),n("p",[t._v("With the concept of the contract language model, we can nest the contract model framework on Substrate's Wasm contract system.")]),t._v(" "),n("p",[t._v("The realization of ink! The whole system corresponds to the contract model of "),n("code",[t._v("pallet-contracts")]),t._v(". ink! 3.0 introduces the functional logic corresponding to "),n("code",[t._v("pallet-contracts")]),t._v(" into Rust through the system of process macros (2.0 through declaration macros). Therefore, the S language in this system is Rust, and the T language is Wasm bytecode. Ink! uses the auxiliary tool "),n("code",[t._v("cargo-contract")]),t._v(" to compile the Rust code using the ink! framework into the Wasm bytecode of the contract. The environment in which Wasm  bytecode runs on the chain is wasmi. In the future, JIT-type operating environments such as Wasmtime will also be introduced.")]),t._v(" "),n("p",[t._v("And because the execution environment of "),n("code",[t._v("pallet-contracts")]),t._v("  is Wasm bytecode, a language that can be compiled into Wasm bytecode and a contract language that conforms to the "),n("code",[t._v("pallet-contracts")]),t._v(" contract model can be generated and run on the contract platform of "),n("code",[t._v("pallet-contracts")]),t._v("  Contract. For "),n("code",[t._v("pallet-contracts")]),t._v(", you can design a contract system in different languages for you to choose, and you can use different languages to develop Wasm contracts.")]),t._v(" "),n("h2",{attrs:{id:"more-information"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#more-information"}},[t._v("#")]),t._v(" More information")]),t._v(" "),n("p",[t._v("In addition to Rust's ink!, the contract languages currently supported to run on pallet-contracts also have the following projects:")]),t._v(" "),n("ul",[n("li",[t._v("Ask!：Developed by Patract, it is a contract language based on the  AssemblyScript language . (It is being developed)")]),t._v(" "),n("li",[t._v("Solang： It is a tool that is developed by hyperledger-labs and supports the compilation of Solidity to Wasm of pallet-contracts.")])])])}),[],!1,null,null,null);e.default=o.exports}}]);