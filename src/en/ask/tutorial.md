# Getting Started

> At present, Ask! has only been in the development of the second phase of the Kusama Treasury proposal, and the function is not stable yet, so it has not been released to public repositories such as npm.

This document assumes that the user has a basic AssemblyScript or Typescript programming foundation. If the user has not touched [AssemblyScript](https://www.assemblyscript.org/) before, you need to have a basic understanding of it.

## Download

At present, the Ask project code has not been uploaded to npm, so you need to clone the warehouse directly. After the function development is stable, it will be released to npm.

```bash
git clone https://github.com/patractlabs/ask
```

Enter the directory to download dependencies:

```bash
yarn
```

## Started

### Case contract

Some basic example contracts such as `flipper`, `incrementer`, etc. are maintained in the `/examples` directory of the Ask! project. Developers can refer to these examples to write smart contracts.
The following smart contract writing process takes the contract in the `/examples/flipper` directory as an example to illustrate.

First, we create a new file `flipper.ts` as the entry point, and the `export` section in the wasm code generated by subsequent compilation corresponds to the function exported after the file is compiled. In fact, the AS single file can be used as a project, but here we need to introduce development dependencies through package.json.

You can also use the [asbuild](https://github.com/AssemblyScript/asbuild/) build tool officially provided by AssemblyScript to generate the initial project.

After the project is created, we begin to define contract storage.
Ask! uses the decorator `@storage` to define a contract storage class. This process is similar to the `#[ink(storage)]` macro in ink!. For example, in this case, we define the following contract storage class:

```ts
@storage
class Stored {
  flag: bool;
}
```

In this way, `Stored` can be used as a storage class in the contract. The definition of the contract class is shown below.

Ask! provides the `@contract` decorator to define a contract class, which is similar to the `#[ink::contract]` macro in ink!. `@contract` supports inheritance.

```ts
@contract
class Flipper {
  // ...
}
```

Ask! provides `@constructor` and `@message` decorators to decorate non-static methods in the `@contract` contract class. They are similar to `#[ink(constructor)]` and `#[ink in ink! (message)]`.

-The method decorated by `@constructor` will become an initialization function of the contract. Each class decorated by `@contract` must have at least one `@constructor` method (excluding the parent class). The initialization function of the parent class will not be directly Become a function of contract initialization.
-The method decorated by `@message` will become a method call of the contract. Each class decorated by `@contract` must have at least one `@message` method (including the parent class), and the child class will inherit the contract of the parent class by default Method, the user can override the method of the inherited contract.

Note: Each contract class needs to define a parameterless constructor to instantiate the contract. The `@constructor` function is called after the constructor is called.

Then we implement the specific logic of Flipper:

```ts
@contract
class Flipper {
  private stored: Stored;

  constructor() {
    this.stored = new Stored();
  }

  @constructor
  default(initFlag: bool): void {
    this.stored.flag = initFlag;
  }

  @message
  flip(): void {
    const v = this.stored.flag;
    this.stored.flag = !v;
  }

  @message(mutates = false)
  get(): bool {
    return this.stored.flag;
  }
}
```

It provides a contract initialization function and two contract methods, among which the `get` method is read-only because it sets `mutates = false`.

Here is a brief introduction to the `@storage` and `@contract` decorators, and we have implemented a minimal contract example.

### Compilation

Suppose we compile the contract under the **root directory** of the Ask! project, and the path of the current contract is located in `examples/flipper/flipper.ts` (you can also replace it with the path of your own contract file), then the compilation command is:

```bash
npx ask examples/flipper/flipper.ts
```

After executing this command, a directory `extension` will be generated under the directory of the contract file, which stores the expanded code, and the compiled product of the contract is located in the `target` directory under the contract file directory:

- `metadata.json` describes the ABI of this contract, which can be provided to chains or tools that support this specification.
- `target.wasm` is the final wasm contract code, which can be executed when deployed on the corresponding chain.

### On-chain environmental testing

Ask! currently does not support unit testing.

Developers can use the contract execution environment sandbox [Europa](../europa/introduction.md) provided by Patract to deploy and test contracts.

After starting Europa, developers can deploy and call contracts in the `target` directory through [https://polkadot.js.org/apps](https://polkadot.js.org/apps). This process is similar to Ink! The operation process of the contract is the same.
