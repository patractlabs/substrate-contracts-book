# Ask! Decorator

Ask! provides a set of decorators to implement smart contracts and configure the behavior of decorators by passing parameter objects. At present, the decorator is divided into two layers: class decorator and field decorator. The field decorator must match the corresponding class decorator correctly.

When the decorator used does not add parameters, the parentheses `()` can be omitted.

> Note: The following decorator designs are only applicable to the current version. Many features are not stable yet and may change in the future.

## @contract

Class decorator

The decorated class will automatically become an instance of the smart contract. Its sub-fields support `@constructor` and `@message` decorator decoration.

An `AS` file can only define one `@contract` class.

## @constructor

Field decorator

This decorator is used for the non-static public method of @contract, which does not allow return value (that is, the return type is void). The decorated method serves as an initial construction method of the contract. A contract needs to define at least one `@constructor` method.

The `@constructor` method is executable when the contract is instantiated. A contract can define multiple construction methods, allowing users of the contract to instantiate the contract in many different ways.

The configuration of the contract construction method is always `payable = true` and `mutates = true`.

Example:

```ts
@contract
class Flipper {
  private stored: Stored;

  constructor() {
    this.stored = new Stored();
  }

  @constructor
  init(initFlag: bool): void {
    this.stored.flag = initFlag;
  }

  // ...
}
```

## @doc

`@doc` is used to provide documentation for the information generated by `metadata.json`. It can add documentation comments to `@contract`/`@event`/`@message`/`@constructor` declarations.

## @message

Field decorator

This decorator is used for non-static public methods of @contract. The decorated method serves as the message API of the contract for users to call the contract. A contract needs to define at least one `@constructor` method or inherit other contracts.

The `@message` method is called when the contract is executed. The contract can define multiple message methods. The return value of the message method will be returned to the user, so the `Codec` interface needs to be implemented. If you need to return some collection types, then you need to use some collection types provided by ask! that implement the `Codec` interface.

The default configuration of the contract message method is `payable = false` and `mutates = true`. When the configuration is `true`, the contract will perform corresponding checks at runtime.

-`payable` indicates that the method can accept the value
-`mutates` indicates whether the method can change the value of the stored variable

Example:

```ts
@contract
class Flipper {
  private stored: Stored;
  constructor() {
    this.stored = new Stored();
  }

  @constructor
  default(initFlag: bool): void {
    this.stored.flag = initFlag;
  }

  @message
  flip(): void {
    const v = this.stored.flag;
    this.stored.flag = !v;
  }

  @message(mutates = false)
  get(): bool {
    return this.stored.flag;
  }
}
```

## @storage

Class decorator

Define a contract storage class. This class should only be used as a field of the `@contract` class.

## @event

Class decorator

See [Event](./basics.md#Events) for details.

## @topic

Field decorator

The attribute field decorated with `@topic` will generate an additional topic index. There is a limit to the number of indexes for each event (the default maximum is 4).

## @dynamic

Class decorator

The `@dynamic` decorator is used to decorate the APIs of a contract that already exists on the chain. By declaring the contract interface on the chain in the `@dynamic` class, ask will automatically generate the corresponding cross-contract call code.

Example:

Suppose the following contract A already exists on the chain:

```ts
@contract
class Libadd {
  constructor() {}

  @constructor
  default(): void {}

  @message(mutates = false)
  add(a: i32, b: i32): i32 {
    return a + b;
  }
}
```

We want to call the contract in contract B, then we can declare a `@dynamic` class to describe its interface:

```ts
@dynamic
export class Libadd {
  // 注意这里的方法体会被实际的代码覆盖，这样写主要是为了通过编译
  add(a: i32, b: i32): i32 {
    return 0;
  }
}

@contract
class LibaddCaller {
  constructor() {}

  @constructor
  default(): void {}

  @message(mutates = false)
  callAddFromExternal(outAddress: AccountId, a: i32, b: i32): i32 {
    let outContract = new Libadd(outAddress);
    let val = outContract.add(a, b);
    return val;
  }
}
```

Here `outAddress` is the instance address of contract `Libadd`.

This function can also call contracts written in other smart contract languages, such as ink!, as long as it follows the compatible metadata.json specification.
